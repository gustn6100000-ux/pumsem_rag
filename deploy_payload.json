[{"name": "clarify.ts", "content": "﻿// clarify.ts - Intent analysis + graph-based clarification\nimport { DEEPSEEK_API_KEY, DEEPSEEK_URL } from \"./config.ts\";\nimport type { IntentAnalysis, ChatMessage, SessionContext, ClarifyResult, ClarifyOption } from \"./types.ts\";\nexport type { ClarifyResult };\n// ━━━ [E] 의도 감지 + 명확화 ━━━\n\nconst COST_KEYWORDS = [\n    \"비용\", \"단가\", \"가격\", \"원\", \"얼마\", \"일위대가\",\n    \"재료비\", \"노무비\", \"경비\", \"합계\", \"산출\", \"견적\",\n    \"공사비\", \"원가\", \"금액\",\n];\n\nexport function detectCostIntent(question: string): boolean {\n    return COST_KEYWORDS.some((kw) => question.includes(kw));\n}\n\nconst SPEC_PATTERNS = [\n    /D\\d+/i,        // D80, D100\n    /\\d+mm/i,       // 100mm, 200mm\n    /\\d+톤/,        // 10톤, 25톤\n    /\\d+m[³²]?/,    // 0.7m³, 100m²\n    /\\d+-\\d+-\\d+/,  // 25-180-12 (레미콘 규격)\n];\n\nexport function extractSpec(question: string): string | null {\n    for (const pattern of SPEC_PATTERNS) {\n        const match = question.match(pattern);\n        if (match) return match[0];\n    }\n    return null;\n}\n\n// ─── E-1. DeepSeek v3.2 기반 의도 분석 ───\n// Why: 규칙 기반 의도 분류의 한계(영문 약어, 동의어, 맥락 이해 불가)를\n//      LLM 구조화 출력으로 해결. 비용 ~₩1/호출로 무시 가능.\nconst INTENT_SYSTEM_PROMPT = `당신은 건설 공사 품셈 검색 시스템의 의도 분석기입니다.\n사용자의 질문을 분석하여 반드시 다음 JSON만 반환하십시오.\n\n## ⚠️ 중요: intent는 반드시 아래 5개 중 하나만 사용\n\n{\n  \"intent\": \"search\" | \"clarify_needed\" | \"followup\" | \"greeting\" | \"quantity_input\",\n  \"work_name\": \"공종명 한글 (예: 강관용접, 잡철물, TIG용접) 또는 null\",\n  \"spec\": \"규격 (예: 200 SCH 40, D110, 2톤) 또는 null\",\n  \"keywords\": [\"검색용\", \"키워드\"],\n  \"ambiguity_reason\": \"모호한 이유 또는 null\"\n}\n\n## 의도 판별 기준\n\n### search (바로 검색 가능)\n- 공종명이 명확하고, 규격이 특정되어 단일 품셈을 바로 찾을 수 있는 경우\n- 예: \"강관용접 200mm SCH 40 품셈\", \"콘크리트 타설 인력\", \"거푸집 설치\"\n\n### clarify_needed (되물어야 함) ← 의심스러우면 이것 선택\n- 공종명은 있지만 규격별 세분화가 필요한데 규격 미지정 → clarify_needed\n  예: \"강관용접 품셈\" → 규격 필요\n- 공종명이 넓은 범위여서 하위 분류 선택이 필요 → clarify_needed\n  예: \"잡철물 제작\", \"용접\", \"배관\" → 구체적 공종/규격 확인 필요\n- 수량(2톤, 10m)은 있지만 상세 규격/종류가 불명확 → clarify_needed\n  예: \"잡철물 2톤 제작\" → 잡철물의 종류(규격철물? 현장제작?) 확인 필요\n- 약어/영문만 있어 확인 필요 → clarify_needed\n  예: \"tig\" → TIG용접 확인 필요\n\n### followup (이전 대화 후속)\n- 이전 대화 맥락의 추가 질문. 예: \"SCH 80은?\", \"장비는?\"\n\n### greeting (인사/도움말)\n- \"안녕\", \"뭘 할 수 있어?\"\n\n### quantity_input (수량 계산)\n- 이전에 품셈이 이미 검색된 상태에서 수량만 입력. 예: \"10개소\", \"50m 계산해줘\"\n\n## 키워드 추출 규칙\n- 영문 약어 → 한글 변환: \"tig\" → [\"TIG\", \"TIG용접\"]\n- ⭐ 한글 외래어 → 영문 원어 번역 (필수!): 건설 용어가 한글로 들어오면 영문 원어도 keywords에 반드시 포함\n  예: \"크러셔\" → [\"크러셔\", \"Crusher\"], \"플랜지\" → [\"플랜지\", \"Flange\"], \"그라인딩\" → [\"그라인딩\", \"Grinding\"]\n  예: \"에이치빔\" → [\"에이치빔\", \"H-Beam\"], \"피브이씨\" → [\"피브이씨\", \"PVC\"], \"티그\" → [\"티그\", \"TIG\"]\n  예: \"히터\" → [\"히터\", \"Heater\"], \"탱크\" → [\"탱크\", \"Tank\", \"STORAGE TANK\"]\n  예: \"지엔에스에스\" → [\"지엔에스에스\", \"GNSS\"], \"스토리지\" → [\"스토리지\", \"STORAGE\"]\n- ⭐ work_name도 동일하게: 한글 외래어가 공종명이면 영문 원어를 work_name에 사용\n  예: \"크러셔 운전\" → work_name: \"Crusher\", \"플랜지 취부\" → work_name: \"Flange 취부\"\n- 규격 정규화: \"200mm\" → \"200\", \"SCH40\" → \"SCH 40\"\n- 불용어 제외: \"품셈\", \"알려줘\", \"얼마\", \"인력\", \"투입\", \"관련\"\n- 동의어 확장: \"PE관\" → [\"PE관\", \"HDPE관\"], \"HDPE관\" → [\"HDPE관\", \"PE관\", \"PE드럼\", \"폴리에틸렌\"]\n- ⭐ 약어/접두어 확장: HDPE는 PE의 하위 종류이므로 반드시 PE관 등 한글 복합어로 keywords에 포함\n  예: \"HDPE관\" → keywords: [\"HDPE관\", \"PE관\", \"PE드럼\", \"폴리에틸렌\"], work_name: \"PE관\"\n- ⛔ 금지: \"PE\", \"PV\" 같은 2글자 영문 약어를 단독으로 keywords에 넣지 마세요! 반드시 한글과 결합한 복합어로 (PE관, PE드럼, PVC관)\n\n## 대화 히스토리 활용\n- 이전 대화에서 확정된 공종명을 후속 질문에 복원\n  예: 이전 \"강관용접 200mm SCH 40\" → 현재 \"SCH 80은?\" → work_name: \"강관용접\", spec: \"SCH 80\"`;\n\n// ─── 규칙 기반 의도 분석 (DeepSeek 폴백) ───\n// Why: API 키 미설정 또는 API 장애 시에도 기본적인 키워드 추출 보장\n\n// 한글 외래어 → 영문 원어 번역 딕셔너리\n// Why: DeepSeek이 처리하는 것이 정석이지만, API 장애 시에도\n//      \"크러셔\" → \"Crusher\", \"플랜지\" → \"Flange\" 변환 보장\nexport const KO_EN_DICT: Record<string, string[]> = {\n    \"크러셔\": [\"Crusher\"], \"크라셔\": [\"Crusher\"],\n    \"플랜지\": [\"Flange\"], \"플렌지\": [\"Flange\"],\n    \"그라인딩\": [\"Grinding\"], \"그라인더\": [\"Grinding\"],\n    \"에이치빔\": [\"H-Beam\"], \"히터\": [\"Heater\"],\n    \"피브이씨\": [\"PVC\"], \"스토리지\": [\"STORAGE\"],\n    \"탱크\": [\"Tank\", \"STORAGE TANK\"],\n    \"티그\": [\"TIG\", \"TIG용접\"], \"미그\": [\"MIG\"],\n    \"지엔에스에스\": [\"GNSS\"], \"인버터\": [\"Inverter\"],\n    \"컨베이어\": [\"Conveyor\"], \"호퍼\": [\"Hopper\"],\n    \"콤프레서\": [\"Compressor\"], \"컴프레셔\": [\"Compressor\"],\n    \"펌프\": [\"Pump\"], \"밸브\": [\"Valve\"],\n    \"보일러\": [\"Boiler\"], \"덕트\": [\"Duct\"],\n    \"에이치디피이\": [\"HDPE\", \"PE\"], \"피이\": [\"PE\"],\n    \"트랜스\": [\"Transformer\"], \"케이블\": [\"Cable\"],\n    \"브레이커\": [\"Breaker\"], \"불도저\": [\"Bulldozer\"],\n    \"로더\": [\"Loader\"], \"덤프\": [\"Dump\"],\n    \"롤러\": [\"Roller\"], \"크레인\": [\"Crane\"],\n    \"백호우\": [\"Backhoe\"], \"그래더\": [\"Grader\"],\n    \"스크레이퍼\": [\"Scraper\"], \"페이버\": [\"Paver\"],\n    \"피니셔\": [\"Finisher\"], \"스프레더\": [\"Spreader\"],\n    \"바이브레이터\": [\"Vibrator\"], \"해머\": [\"Hammer\"],\n    \"앵커\": [\"Anchor\"], \"와이어\": [\"Wire\"],\n    \"배럴\": [\"Barrel\"], \"실링\": [\"Sealing\"],\n    \"코킹\": [\"Caulking\"], \"프라이머\": [\"Primer\"],\n};\n\nexport function ruleBasedIntent(question: string): IntentAnalysis {\n    // 인사 감지\n    if (/^(안녕|반가|도움|뭘\\s*할|할\\s*수|help)/i.test(question)) {\n        return { intent: \"greeting\", work_name: null, spec: null, keywords: [], ambiguity_reason: null };\n    }\n\n    // 불용어 제거 후 한글 키워드 추출\n    const stopWords = new Set([\"품셈\", \"인력\", \"인공\", \"수량\", \"단위\", \"장비\", \"자재\", \"알려줘\", \"얼마\", \"관련\", \"제작\", \"설치\", \"시공\", \"공사\"]);\n    const koreanWords = question.match(/[가-힣]{2,}/g) || [];\n    const workKeywords = koreanWords.filter(w => !stopWords.has(w));\n\n    // ⭐ 한글 외래어 → 영문 번역 (폴백 보장)\n    const translatedKeywords: string[] = [];\n    for (const kw of workKeywords) {\n        if (KO_EN_DICT[kw]) {\n            translatedKeywords.push(...KO_EN_DICT[kw]);\n        }\n    }\n    const allKeywords = [...workKeywords, ...translatedKeywords];\n\n    // 영문 키워드도 질문에서 직접 추출 (Crusher, Flange 등)\n    const englishWords = question.match(/[A-Za-z][-A-Za-z]{1,}/g) || [];\n    const engStopWords = new Set([\"SCH\", \"mm\", \"ton\", \"help\"]);\n    const engKeywords = englishWords.filter(w => !engStopWords.has(w) && w.length >= 2);\n    allKeywords.push(...engKeywords);\n\n    // ⭐ 영문 약어 확장 (HDPE→PE관, PVC→PVC관 등 한글 복합어로)\n    const ENG_EXPAND: Record<string, string[]> = {\n        \"HDPE\": [\"PE관\", \"PE드럼\", \"HDPE관\", \"폴리에틸렌\"],\n        \"PVC\": [\"PVC관\"],\n    };\n    for (const ek of engKeywords) {\n        const upper = ek.toUpperCase();\n        if (ENG_EXPAND[upper]) allKeywords.push(...ENG_EXPAND[upper]);\n    }\n\n    // 규격 추출 (2t, 200mm, SCH 40, D110 등)\n    let spec: string | null = null;\n    const specMatch = question.match(/(\\d+)\\s*(t|ton|mm|A|㎜)/i);\n    if (specMatch) spec = `${specMatch[1]}${specMatch[2]}`;\n    const schMatch = question.match(/SCH\\s*(\\d+)/i);\n    if (schMatch) spec = (spec ? spec + \" \" : \"\") + `SCH ${schMatch[1]}`;\n\n    // 공종명 = 첫 번째 의미 있는 키워드 (영문 번역 우선)\n    const work_name = translatedKeywords.length > 0\n        ? translatedKeywords[0]  // 영문 원어 우선 (DB 엔티티명과 매칭)\n        : (workKeywords.length > 0 ? workKeywords[0] : null);\n\n    // 수량 감지 (10개소, 2t, 50m 등)\n    const qtyMatch = question.match(/(\\d+)\\s*(개소|개|m|㎡|㎥|t|ton|본)/i);\n    if (qtyMatch && work_name) {\n        return {\n            intent: \"search\",\n            work_name,\n            spec,\n            keywords: allKeywords,\n            ambiguity_reason: null,\n        };\n    }\n\n    console.log(`[ruleBasedIntent] work_name=${work_name}, spec=${spec}, keywords=${allKeywords.join(\",\")}, translated=${translatedKeywords.join(\",\")}`);\n    return {\n        intent: work_name ? \"search\" : \"greeting\",\n        work_name,\n        spec,\n        keywords: allKeywords,\n        ambiguity_reason: null,\n    };\n}\n\nexport async function analyzeIntent(\n    question: string,\n    history: ChatMessage[],\n    sessionContext?: SessionContext\n): Promise<IntentAnalysis> {\n    // DeepSeek API 키가 없으면 규칙 기반 폴백\n    if (!DEEPSEEK_API_KEY) {\n        console.warn(\"[analyzeIntent] DEEPSEEK_API_KEY 미설정 → 규칙 기반 폴백\");\n        return ruleBasedIntent(question);\n    }\n\n    try {\n        // 세션 컨텍스트가 있으면 시스템 프롬프트에 부착\n        let systemContent = INTENT_SYSTEM_PROMPT;\n        if (sessionContext?.last_entity_id) {\n            systemContent += `\\n\\n## 현재 세션 상태\\n` +\n                `last_entity_id: ${sessionContext.last_entity_id}\\n` +\n                `last_work_name: ${sessionContext.last_work_name || '없음'}\\n` +\n                `last_spec: ${sessionContext.last_spec || '없음'}\\n` +\n                `last_quantity: ${sessionContext.last_quantity || '없음'}\\n` +\n                `last_section_id: ${sessionContext.last_section_id || '없음'}`;\n        }\n\n        const response = await fetch(DEEPSEEK_URL, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": `Bearer ${DEEPSEEK_API_KEY}`,\n            },\n            body: JSON.stringify({\n                model: \"deepseek-chat\",\n                messages: [\n                    { role: \"system\", content: systemContent },\n                    // 최근 3턴만 전달 (토큰 절약)\n                    ...history.slice(-3).map(h => ({\n                        role: h.role === \"user\" ? \"user\" as const : \"assistant\" as const,\n                        content: h.content,\n                    })),\n                    { role: \"user\" as const, content: question },\n                ],\n                response_format: { type: \"json_object\" },\n                temperature: 0.1,\n                max_tokens: 300,\n            }),\n        });\n\n        if (!response.ok) {\n            console.error(`[analyzeIntent] DeepSeek API failed: ${response.status} → 규칙 기반 폴백`);\n            return ruleBasedIntent(question);\n        }\n\n        const data = await response.json();\n        const content = data.choices?.[0]?.message?.content ?? \"{}\";\n        const parsed = JSON.parse(content) as IntentAnalysis;\n\n        // 안전성 보장: intent가 유효하지 않으면 폴백\n        const validIntents = [\"search\", \"clarify_needed\", \"followup\", \"greeting\", \"quantity_input\", \"cost_calculate\", \"modify_request\", \"report_request\", \"complex_estimate\"];\n        if (!validIntents.includes(parsed.intent)) {\n            parsed.intent = parsed.ambiguity_reason ? \"clarify_needed\" : \"search\";\n        }\n        if (parsed.intent === \"search\" && parsed.ambiguity_reason) {\n            parsed.intent = \"clarify_needed\";\n        }\n        // Fix A: greeting으로 분류됐더라도 공종 관련 단어가 있으면 clarify_needed로 교정\n        // - LLM이 공종 쿼리를 greeting으로 오분류하는 케이스를 question 원문으로 직접 차단\n        const workTermPattern = /설치|용접|배관|시공|제작|타설|철거|해체|보온|도장|미장|조적|플랜지|강관|덕트|콘크리트|거푸집|철근|굴착|성토|절토|포장/;\n        if (parsed.intent === \"greeting\" && workTermPattern.test(question)) {\n            parsed.intent = \"clarify_needed\";\n            parsed.ambiguity_reason = parsed.ambiguity_reason ?? \"공종명이 포함되어 있어 clarify_needed로 재분류\";\n            if (!parsed.work_name && parsed.keywords.length > 0) {\n                parsed.work_name = parsed.keywords[0];\n            }\n        }\n        parsed.keywords = parsed.keywords || [];\n\n        console.log(`[analyzeIntent] intent=${parsed.intent}, work_name=${parsed.work_name}, spec=${parsed.spec}, keywords=${parsed.keywords.join(\",\")}${parsed.modify_type ? `, modify_type=${parsed.modify_type}` : ''}${parsed.quantity != null ? `, quantity=${parsed.quantity}` : ''}`);\n        return parsed;\n    } catch (err) {\n        console.error(\"[analyzeIntent] error:\", err, \"→ 규칙 기반 폴백\");\n        return ruleBasedIntent(question);\n    }\n}\n\n// ─── E-2. 그래프 기반 명확화 (graphClarify) ───\n// Why: 모호한 질문에 대해 그래프의 Section→WorkType 계층을 탐색하여\n//      실제 존재하는 후보만 제시.\n// Phase 3: 2단계 drill-down\n//   sectionId 없음 → Step 1: 섹션(분야) 선택\n//   sectionId 있음 → Step 2: 해당 섹션 내 하목 선택\n// ClarifyResult is imported from types.ts\n\n// ═══ graphClarify: resolve.ts의 resolveSection + presentClarify를 호출하는 thin wrapper ═══\n// Why: 기존 graphClarify의 656줄 모놀리식 로직을 resolve.ts로 분리.\n//      이 함수는 기존 caller(index.ts, handleChat)와의 호환성을 유지하는 역할.\nimport { resolveSection, presentClarify } from \"./resolve.ts\";\nimport type { ResolveContext } from \"./resolve.ts\";\n\nexport async function graphClarify(analysis: IntentAnalysis, sectionId?: string): Promise<ClarifyResult> {\n    const { work_name, keywords } = analysis;\n    const searchTerms = work_name ? [work_name, ...keywords] : keywords;\n\n    // searchTerms 비어있으면 안내 반환\n    if (searchTerms.length === 0 && !sectionId) {\n        return {\n            message: \"검색하고 싶은 품셈 항목을 좀 더 구체적으로 알려주세요.\\n예: \\\"강관용접 200mm SCH 40\\\", \\\"콘크리트 타설\\\", \\\"거푸집 설치\\\"\",\n            options: [\n                { label: \"강관용접\", query: \"강관용접 품셈\" },\n                { label: \"콘크리트 타설\", query: \"콘크리트 타설 품셈\" },\n                { label: \"거푸집 설치\", query: \"거푸집 설치 품셈\" },\n            ],\n        };\n    }\n\n    // sub_section 상태 파싱: sectionId에 \":sub=\" 인코딩이 있으면 분리\n    let actualSectionId = sectionId;\n    let subSectionName: string | undefined;\n    if (sectionId && sectionId.includes(':sub=')) {\n        const parts = sectionId.split(':sub=');\n        actualSectionId = parts[0];\n        subSectionName = decodeURIComponent(parts[1]);\n    }\n\n    const ctx: ResolveContext = {\n        analysis,\n        sectionId: actualSectionId,\n        subSectionName,\n    };\n\n    const resolved = await resolveSection(ctx);\n    return presentClarify(resolved, searchTerms, work_name);\n}\n\n// ━━━ [E-3] 규격 정규화 ━━━\n// Why: 사용자가 입력하는 규격 표기가 다양함 (인치, 파이, SCH 붙여쓰기 등)\n//      DB의 표준 표기(mm, SCH 띄어쓰기)로 통일하여 검색 정확도 향상\nexport function normalizeSpec(spec: string | null): string | null {\n    if (!spec) return spec;\n    let s = spec;\n\n    // 인치 → mm 변환 (1인치 = 25.4mm, 반올림)\n    const inchMap: Record<string, string> = {\n        '1/2': '15', '3/4': '20', '1': '25', '1-1/4': '32', '1-1/2': '40',\n        '2': '50', '2-1/2': '65', '3': '80', '4': '100', '5': '125',\n        '6': '150', '8': '200', '10': '250', '12': '300', '14': '350',\n        '16': '400', '18': '450', '20': '500', '24': '600',\n    };\n\n    // \"8인치\" → \"200mm\"\n    const inchMatch = s.match(/^(\\d+(?:-\\d+\\/\\d+|\\d*\\/\\d+)?)\\s*(?:인치|inch|\"|″)/i);\n    if (inchMatch) {\n        const mmVal = inchMap[inchMatch[1]];\n        if (mmVal) {\n            s = s.replace(inchMatch[0], `${mmVal}mm`);\n        }\n    }\n\n    // \"파이200\" → \"200mm\" (파이 = 직경 표기)\n    s = s.replace(/파이\\s*(\\d+)/g, '$1mm');\n    // \"Φ200\" or \"ø200\" → \"200mm\"\n    s = s.replace(/[Φφø]\\s*(\\d+)/g, '$1mm');\n\n    // \"SCH40\" → \"SCH 40\" (띄어쓰기 정규화)\n    s = s.replace(/SCH\\s*(\\d+)/gi, 'SCH $1');\n\n    // \"200A\" → \"200mm\" (A = mm in KS 표기)\n    s = s.replace(/(\\d+)\\s*A\\b/g, '$1mm');\n\n    return s;\n}"}, {"name": "config.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// config.ts — 환경 설정, Supabase 클라이언트, CORS, Rate Limit\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2\";\n\n// ━━━ 환경변수 ━━━\nexport const GEMINI_API_KEY = Deno.env.get(\"GEMINI_API_KEY\")!;\nexport const SUPABASE_URL = Deno.env.get(\"SUPABASE_URL\")!;\nexport const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get(\"SUPABASE_SERVICE_ROLE_KEY\")!;\nexport const RAG_API_KEY = Deno.env.get(\"RAG_API_KEY\") || \"\";\n// DeepSeek v3.2 — 의도 분석 전용 LLM\nexport const DEEPSEEK_API_KEY = Deno.env.get(\"DEEPSEEK_API_KEY\") || \"\";\nexport const DEEPSEEK_URL = \"https://api.deepseek.com/chat/completions\";\n\n// ━━━ Supabase 클라이언트 ━━━\nexport const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);\n\n// ━━━ CORS ━━━\n// (Codex F1) CORS allowlist — '*' 금지\nexport const ALLOWED_ORIGINS = [\n    \"http://localhost:3000\",\n    \"http://localhost:5500\",\n    \"http://127.0.0.1:5500\",\n    \"https://pumsem-chat.pages.dev\",\n    \"https://antigravity-chatbot.pages.dev\",\n];\n// Cloudflare Pages preview URL 패턴 (ex: 1e3f64d6.antigravity-chatbot.pages.dev)\nexport const ALLOWED_SUFFIXES = [\n    \".antigravity-chatbot.pages.dev\",\n    \".pumsem-chat.pages.dev\",\n];\n\nexport function getCorsHeaders(req: Request): Record<string, string> {\n    const origin = req.headers.get(\"Origin\") || \"\";\n    const isAllowed = ALLOWED_ORIGINS.includes(origin) ||\n        ALLOWED_SUFFIXES.some(suffix => {\n            try { return new URL(origin).hostname.endsWith(suffix); } catch { return false; }\n        });\n    return {\n        \"Access-Control-Allow-Origin\": isAllowed ? origin : \"\",\n        \"Access-Control-Allow-Methods\": \"POST, OPTIONS\",\n        \"Access-Control-Allow-Headers\": \"Content-Type, x-api-key\",\n        \"Vary\": \"Origin\",\n    };\n}\n\n// ━━━ Rate Limiting ━━━\n// (Codex F1) IP 기반 Rate Limiting — 분당 10회\nexport const rateLimitMap = new Map<string, { count: number; resetAt: number }>();\nexport const RATE_LIMIT_MAX = 10;\nexport const RATE_LIMIT_WINDOW_MS = 60_000;\n\nexport function checkRateLimit(ip: string): boolean {\n    const now = Date.now();\n    const entry = rateLimitMap.get(ip);\n    if (!entry || now > entry.resetAt) {\n        rateLimitMap.set(ip, { count: 1, resetAt: now + RATE_LIMIT_WINDOW_MS });\n        return true;\n    }\n    entry.count++;\n    return entry.count <= RATE_LIMIT_MAX;\n}\n"}, {"name": "context.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// context.ts — LLM 컨텍스트 조합 + 응답 조립 헬퍼\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nimport type {\n    EntityResult, RelatedResource, IlwiItem, ChunkResult,\n    ChatResponse, SearchInfo, TokenUsage, SourceInfo,\n    ClarifyOption, ClarificationInfo, SelectorPanel, LLMResult,\n} from \"./types.ts\";\n\n// ━━━ 응답 조립 헬퍼 ━━━\n// Why: handleChat 내 6곳+ 반복되는 응답 객체 조립을 통합하여 유지보수성 향상\n// 응답 구조 변경 시 이 함수만 수정하면 됨\n\n/**\n * 빈 SearchInfo 생성 (entities/relations 없는 간단 응답용)\n */\nexport function makeEmptySearchInfo(startTime: number): SearchInfo {\n    return {\n        entities_found: 0,\n        relations_expanded: 0,\n        ilwi_matched: 0,\n        chunks_retrieved: 0,\n        latency_ms: Date.now() - startTime,\n    };\n}\n\n/**\n * \"answer\" 타입 응답 생성\n * @param answer - LLM 답변 텍스트\n * @param startTime - 처리 시작 시간 (latency 계산용)\n * @param opts - 선택적 응답 데이터 (sources, entities, relations, llmResult 등)\n */\nexport function makeAnswerResponse(\n    answer: string,\n    startTime: number,\n    opts?: {\n        sources?: SourceInfo[];\n        entities?: EntityResult[];\n        relations?: RelatedResource[][];\n        ilwi?: IlwiItem[];\n        chunks?: ChunkResult[];\n        embeddingTokens?: number;\n        llmResult?: LLMResult;\n    }\n): ChatResponse {\n    const searchInfo: SearchInfo = {\n        entities_found: opts?.entities?.length || 0,\n        relations_expanded: opts?.relations\n            ? opts.relations.reduce((sum, r) => sum + r.length, 0)\n            : 0,\n        ilwi_matched: opts?.ilwi?.length || 0,\n        chunks_retrieved: opts?.chunks?.length || 0,\n        latency_ms: Date.now() - startTime,\n    };\n\n    // token_usage는 llmResult가 있을 때만 포함\n    if (opts?.llmResult) {\n        const et = opts.embeddingTokens || 0;\n        const totalTokens = et + opts.llmResult.inputTokens + opts.llmResult.outputTokens;\n        searchInfo.token_usage = {\n            embedding_tokens: et,\n            llm_input_tokens: opts.llmResult.inputTokens,\n            llm_output_tokens: opts.llmResult.outputTokens,\n            total_tokens: totalTokens,\n            estimated_cost_krw: parseFloat((totalTokens * 0.0002).toFixed(2)),\n        };\n    }\n\n    return {\n        type: \"answer\",\n        answer,\n        sources: opts?.sources || [],\n        search_info: searchInfo,\n    };\n}\n\n/**\n * \"clarify\" 타입 응답 생성\n * @param message - 사용자에게 보여줄 메시지\n * @param startTime - 처리 시작 시간\n * @param clarification - 명확화 옵션 데이터\n * @param opts - 추가 검색 정보 (entities 수 등)\n */\nexport function makeClarifyResponse(\n    message: string,\n    startTime: number,\n    clarification: {\n        options: ClarifyOption[];\n        reason: string;\n        original_query: string;\n        selector?: SelectorPanel;\n    },\n    opts?: {\n        entities?: EntityResult[];\n    }\n): ChatResponse {\n    return {\n        type: \"clarify\",\n        answer: message,\n        sources: [],\n        search_info: {\n            entities_found: opts?.entities?.length || 0,\n            relations_expanded: 0,\n            ilwi_matched: 0,\n            chunks_retrieved: 0,\n            latency_ms: Date.now() - startTime,\n        },\n        clarification: clarification as ClarificationInfo,\n    };\n}\n\n"}, {"name": "embedding.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// embedding.ts — Gemini 임베딩 생성\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nimport { GEMINI_API_KEY } from \"./config.ts\";\n\n// Why gemini-embedding-001: Step 2.7에서 동일 모델로 임베딩 생성\nconst EMBEDDING_URL =\n    \"https://generativelanguage.googleapis.com/v1beta/models/gemini-embedding-001:embedContent\";\n\nexport async function generateEmbedding(text: string): Promise<number[]> {\n    // DB에 768차원으로 저장됨 → outputDimensionality 명시 필수\n    // gemini-embedding-001 기본 출력 3072차원이므로 미지정 시 벡터 파싱 실패\n    const embeddingBody = {\n        model: \"models/gemini-embedding-001\",\n        content: { parts: [{ text }] },\n        outputDimensionality: 768,\n    };\n\n    const response = await fetch(`${EMBEDDING_URL}?key=${GEMINI_API_KEY}`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(embeddingBody),\n    });\n\n    if (!response.ok) {\n        // 1회 재시도 (Codex 권장 폴백)\n        const retry = await fetch(`${EMBEDDING_URL}?key=${GEMINI_API_KEY}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(embeddingBody),\n        });\n        if (!retry.ok) {\n            throw new Error(`Embedding API failed: ${retry.status}`);\n        }\n        const data = await retry.json();\n        return data.embedding?.values ?? [];\n    }\n\n    const data = await response.json();\n    return data.embedding?.values ?? [];\n}\n"}, {"name": "graph.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// graph.ts — 그래프 확장 (1-hop 관계 + 계층) + 일위대가 + 원문 청크\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nimport { supabase } from \"./config.ts\";\nimport type { EntityResult, RelatedResource, IlwiItem, ChunkResult } from \"./types.ts\";\n\n// C-2. 그래프 확장 (1-hop 관계 + 계층)\n// skipSectionExpansion: true → 동일 section의 형제 WorkType 확장 생략\n//   Phase -1에서 entity_id가 직접 전달된 경우 사용\n//   Why: 사용자가 특정 규격(50 SCH20 등)을 선택했을 때,\n//        같은 section의 모든 WorkType(15,20,25,...,600)을 확장하면\n//        수백 개 관계가 context에 포함되어 LLM이 혼동함\nexport async function expandGraph(\n    entityId: string,\n    entityType: string,\n    skipSectionExpansion: boolean = false\n): Promise<RelatedResource[]> {\n    // 1-hop 관계 조회\n    const { data: relations, error: relErr } = await supabase.rpc(\n        \"get_related_resources\",\n        { p_entity_id: entityId }\n    );\n\n    if (relErr) {\n        console.error(\"expandGraph error:\", relErr.message);\n        return [];\n    }\n\n    let allRelations = (relations || []) as RelatedResource[];\n\n    // ─── 동일 Section의 WorkType 확장 함수 (재사용) ───\n    // Why: Section, WorkType, Note, Standard 등 어떤 엔티티에서든\n    //      source_section이 같으면 해당 절의 전체 자원을 탐색해야 함\n    async function expandSectionWorkTypes(sourceSection: string): Promise<void> {\n        const { data: workTypes } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id, name, type, properties\")\n            .eq(\"source_section\", sourceSection)\n            .eq(\"type\", \"WorkType\")\n            .limit(30);\n\n        if (!workTypes || workTypes.length === 0) return;\n\n        // 이미 allRelations에 포함된 WorkType ID 수집 (중복 방지)\n        const existingIds = new Set(\n            allRelations\n                .filter(r => r.related_type === \"WorkType\")\n                .map(r => r.related_id)\n        );\n\n        // 각 WorkType의 관계를 병렬 조회\n        const workRelPromises = (workTypes as any[]).map(async (wt: any) => {\n            const { data: wtRels } = await supabase.rpc(\n                \"get_related_resources\",\n                { p_entity_id: wt.id }\n            );\n            return { workType: wt, relations: (wtRels || []) as RelatedResource[] };\n        });\n\n        const workRelResults = await Promise.all(workRelPromises);\n\n        for (const { workType, relations: wtRels } of workRelResults) {\n            // WorkType 자체를 가상 관계로 추가 (중복 제외)\n            if (!existingIds.has(workType.id)) {\n                allRelations.push({\n                    direction: \"outbound\",\n                    relation: \"CONTAINS_WORK\",\n                    related_id: workType.id,\n                    related_name: workType.name,\n                    related_type: \"WorkType\",\n                    properties: workType.properties || {},\n                });\n            }\n            // WorkType의 REQUIRES_LABOR, REQUIRES_EQUIPMENT, USES_MATERIAL 관계 추가\n            // Why: 각 관계에 work_type_name을 주입하여, 출력 시 어떤 규격(15mm, SCH 20 등)의 인력인지 표시\n            // Phase 5: sub_section 속성이 있으면 [sub_section] 접두사 추가 → context.ts에서 그룹별 출력\n            const subSection = (workType.properties as any)?.sub_section;\n            const displayWtName = subSection ? `[${subSection}] ${workType.name}` : workType.name;\n            const relevantRels = wtRels.filter((r: RelatedResource) =>\n                [\"REQUIRES_LABOR\", \"REQUIRES_EQUIPMENT\", \"USES_MATERIAL\", \"HAS_NOTE\"].includes(r.relation)\n            );\n            relevantRels.forEach(r => {\n                (r.properties as any).work_type_name = displayWtName;\n            });\n            allRelations = allRelations.concat(relevantRels);\n\n            // Fix A3: REQUIRES_LABOR 관계 없지만 properties에 quantity/unit이 있는 WT\n            // Why: 986개 WT 중 285개가 이 패턴 (LLM이 관계 대신 properties에 직접 저장)\n            //      → 가상 REQUIRES_LABOR 관계를 생성하여 인력 테이블에 포함\n            const hasLaborRel = relevantRels.some(r => r.relation === \"REQUIRES_LABOR\");\n            const wtProps = workType.properties || {} as any;\n            if (!hasLaborRel && wtProps.quantity && wtProps.unit) {\n                allRelations.push({\n                    direction: \"outbound\",\n                    relation: \"REQUIRES_LABOR\",\n                    related_id: workType.id + \"_prop\",\n                    related_name: wtProps.unit?.includes(\"인\") ? workType.name : workType.name,\n                    related_type: \"Labor\",\n                    properties: {\n                        quantity: wtProps.quantity,\n                        unit: wtProps.unit,\n                        work_type_name: displayWtName,\n                        source: \"properties\",\n                    },\n                });\n            }\n\n            // Phase 1: Labor 관계도 없고 properties에도 quantity 없는 WT → unit_costs 원문 폴백\n            // Why: TIG용접 등 그래프에 규격별 인력 미저장 WT는 unit_costs 원문 테이블을 직접 활용\n            if (!hasLaborRel && !(wtProps.quantity && wtProps.unit)) {\n                const { data: rawData } = await supabase\n                    .from(\"unit_costs\")\n                    .select(\"content, name\")\n                    .ilike(\"content\", `%${workType.name}%`)\n                    .limit(1);\n\n                if (rawData && rawData.length > 0) {\n                    allRelations.push({\n                        direction: \"outbound\",\n                        relation: \"RAW_TABLE\",\n                        related_id: workType.id + \"_raw\",\n                        related_name: (rawData[0] as any).name || workType.name,\n                        related_type: \"RawTable\",\n                        properties: {\n                            raw_content: (rawData[0] as any).content,\n                            work_type_name: workType.name,\n                            source: \"unit_costs_fallback\",\n                        },\n                    });\n                    console.log(`[expandGraph] RAW_TABLE fallback for ${workType.name}`);\n                }\n            }\n        }\n    }\n\n    // ─── Section 타입: 계층 + WorkType 확장 ───\n    if (entityType === \"Section\") {\n        const { data: hierarchy, error: hierErr } = await supabase.rpc(\n            \"get_entity_hierarchy\",\n            { p_entity_id: entityId }\n        );\n\n        if (!hierErr && hierarchy) {\n            allRelations = allRelations.concat(hierarchy as RelatedResource[]);\n        }\n\n        // source_section 기준으로 WorkType 2-hop 확장 (skipSectionExpansion이면 생략)\n        if (!skipSectionExpansion) {\n            const { data: sectionEntities } = await supabase\n                .from(\"graph_entities\")\n                .select(\"source_section\")\n                .eq(\"id\", entityId)\n                .limit(1);\n\n            const sectionEntity = (sectionEntities as any[])?.[0];\n            if (sectionEntity?.source_section) {\n                await expandSectionWorkTypes(sectionEntity.source_section);\n            }\n        }\n    }\n\n    // ─── WorkType/Note/Standard 타입: 형제 WorkType 확장 ───\n    // Why: \"TIG용접\"(WorkType)을 검색하면 W-0634만 나오고,\n    //      같은 section(13-2-3)의 강관용접(W-0792~) → REQUIRES_LABOR가 누락됨.\n    //      Note/Standard도 마찬가지 — 해당 section 전체 자원을 보여줘야 함.\n    // skipSectionExpansion이면 생략: 사용자가 이미 특정 entity를 선택한 상태\n    if (!skipSectionExpansion && [\"WorkType\", \"Note\", \"Standard\"].includes(entityType)) {\n        // 현재 엔티티의 source_section 조회\n        const { data: selfEntities } = await supabase\n            .from(\"graph_entities\")\n            .select(\"source_section\")\n            .eq(\"id\", entityId)\n            .limit(1);\n\n        const selfEntity = (selfEntities as any[])?.[0];\n        if (selfEntity?.source_section) {\n            await expandSectionWorkTypes(selfEntity.source_section);\n        }\n    }\n\n    // ─── HAS_NOTE 관계의 실제 내용 보강 ───\n    // get_related_resources는 대상 엔티티의 properties를 반환하지 않으므로\n    // Note 엔티티의 properties.content를 별도 조회하여 관계에 주입\n    const noteRelations = allRelations.filter(r => r.relation === \"HAS_NOTE\");\n    if (noteRelations.length > 0) {\n        const noteIds = [...new Set(noteRelations.map(r => r.related_id))];\n        const { data: noteEntities } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id, properties\")\n            .in(\"id\", noteIds);\n\n        if (noteEntities) {\n            const noteContentMap = new Map(\n                (noteEntities as any[]).map((e: any) => [\n                    e.id,\n                    e.properties?.content || null\n                ])\n            );\n            noteRelations.forEach(r => {\n                const content = noteContentMap.get(r.related_id);\n                if (content) {\n                    (r.properties as any).note_content = content;\n                }\n            });\n        }\n    }\n\n    return allRelations;\n}\n\n// C-3. 일위대가 검색\nexport async function searchIlwi(\n    name: string,\n    spec: string | null\n): Promise<IlwiItem[]> {\n    const { data, error } = await supabase.rpc(\"search_ilwi\", {\n        search_name: name,\n        search_spec: spec,\n    });\n\n    if (error) {\n        console.error(\"searchIlwi error:\", error.message);\n        return [];\n    }\n\n    return (data || []) as IlwiItem[];\n}\n\n// C-4. 원문 청크 보강\n// specFilter: entity 선택 시 해당 spec(두께 등)에 해당하는 tables 행만 포함\n// Why: 강판 전기아크용접(두께=4) 선택 시 전 범위(3~50) 데이터가 context에 범람하는 문제 방지\nexport async function retrieveChunks(\n    entities: EntityResult[],\n    specFilter?: string   // 예: \"4\" (두께=4mm만 필터링)\n): Promise<ChunkResult[]> {\n    // entity.source_section → graph_chunks.section_id 매칭 (Codex F3)\n    const sectionIds = entities\n        .map((e) => e.source_section)\n        .filter((s): s is string => !!s);\n\n    if (sectionIds.length === 0) return [];\n\n    // 중복 제거\n    const uniqueSectionIds = [...new Set(sectionIds)];\n\n    const { data, error } = await supabase\n        .from(\"graph_chunks\")\n        .select(\"id, section_id, title, department, chapter, section, text, tables\")\n        .in(\"section_id\", uniqueSectionIds)\n        .limit(15); // 강관용접 등 11개 chunk 커버\n\n    if (error) {\n        console.error(\"retrieveChunks error:\", error.message);\n        return [];\n    }\n\n    const rawChunks = (data || []) as any[];\n\n    // section_id별 그룹화 → 동일 섹션의 여러 chunk를 하나로 병합\n    // Why: 강관용접(13-2-3) 등은 11개 chunk에 tables 분산 → 하나로 합쳐야 LLM이 전체 표 확인 가능\n    const sectionMap = new Map<string, any>();\n    for (const chunk of rawChunks) {\n        const sid = chunk.section_id;\n        if (!sectionMap.has(sid)) {\n            sectionMap.set(sid, { ...chunk, _allTables: [] });\n        }\n        const merged = sectionMap.get(sid)!;\n        // tables 수집\n        if (chunk.tables && Array.isArray(chunk.tables)) {\n            merged._allTables.push(...chunk.tables);\n        }\n        // text 병합 (빈 text 제외)\n        if (chunk.text && chunk.text.length > 0 && chunk.id !== merged.id) {\n            merged.text = (merged.text || \"\") + \"\\n\" + chunk.text;\n        }\n    }\n\n    // tables → Markdown 변환 후 text에 추가\n    return Array.from(sectionMap.values()).map((chunk) => {\n        let fullText = chunk.text || \"\";\n        if (chunk._allTables && chunk._allTables.length > 0) {\n            const tablesMarkdown = chunk._allTables.map((t: any) => {\n                if (!t.rows || t.rows.length === 0) return \"\";\n                const headers: string[] = t.headers || Object.keys(t.rows[0]);\n                let rows = t.rows;\n\n                // specFilter 적용: 첫 번째 header(spec 기준 컬럼)의 값으로 행 필터링\n                // Why: \"두께=4\" 선택 시 두께=4 행만 남기고 나머지(3,5,6...) 제거\n                if (specFilter && headers.length > 0) {\n                    const specKey = headers[0]; // 예: \"구분 자세 및 직종 두께(mm)\"\n                    const filtered = rows.filter((r: any) => {\n                        const val = String(r[specKey] ?? \"\");\n                        return val === specFilter;\n                    });\n                    if (filtered.length > 0) {\n                        rows = filtered;\n                        console.log(`[retrieveChunks] specFilter=\"${specFilter}\": ${t.rows.length}행 → ${rows.length}행`);\n                    }\n                    // 필터 결과가 0건이면 원본 유지 (fallback)\n                }\n\n                const headerRow = \"| \" + headers.join(\" | \") + \" |\";\n                const sepRow = \"| \" + headers.map(() => \"---\").join(\" | \") + \" |\";\n                const dataRows = rows.map((r: any) =>\n                    \"| \" + headers.map((h: string) => r[h] ?? \"\").join(\" | \") + \" |\"\n                );\n                return [headerRow, sepRow, ...dataRows].join(\"\\n\");\n            }).filter(Boolean).join(\"\\n\\n\");\n            fullText += \"\\n\" + tablesMarkdown;\n        }\n        delete chunk._allTables;\n        return {\n            ...chunk,\n            text: fullText.substring(0, 6000), // 확장: 2000→6000 (다수 표 포함)\n        } as ChunkResult;\n    });\n}\n\n// ─── 노임단가 조회 (labor_costs 테이블) ───\n// Why: cost_calculate intent 시 실제 노무비 산출을 위해 직종별 단가 필요\nimport type { LaborCostEntry } from \"./types.ts\";\n\nexport async function fetchLaborCosts(jobNames: string[]): Promise<LaborCostEntry[]> {\n    if (jobNames.length === 0) return [];\n    const patterns = jobNames.map(name => name.replace(/\\s+/g, '%'));\n    const { data, error } = await supabase\n        .from(\"labor_costs\")\n        .select(\"job_name, cost_2026\")\n        .or(patterns.map(p => `job_name.ilike.%${p}%`).join(','));\n\n    if (error || !data) {\n        console.error(\"[fetchLaborCosts] error:\", error);\n        return [];\n    }\n    console.log(`[fetchLaborCosts] 조회 ${jobNames.length}개 직종 → ${data.length}건 매칭`);\n    return data as LaborCostEntry[];\n}\n\n"}, {"name": "index.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// RAG 챗봇 Edge Function — rag-chat/index.ts\n// Phase 2: 모듈 Import 구조 (리팩토링 완료)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nimport \"jsr:@supabase/functions-js/edge-runtime.d.ts\";\n\n// ━━━ [A] 모듈 Import ━━━\nimport {\n    supabase,\n    RAG_API_KEY,\n    getCorsHeaders,\n    checkRateLimit,\n} from \"./config.ts\";\nimport { generateEmbedding } from \"./embedding.ts\";\nimport type {\n    ChatMessage,\n    ChatRequest,\n    SessionContext,\n    SourceInfo,\n    ClarifyOption,\n    ChatResponse,\n    IntentAnalysis,\n    EntityResult,\n    RelatedResource,\n    IlwiItem,\n    ChunkResult,\n    AnswerOptions,\n} from \"./types.ts\";\nimport { targetSearch } from \"./search.ts\";\nimport {\n    expandGraph,\n    searchIlwi,\n    retrieveChunks,\n    fetchLaborCosts,\n} from \"./graph.ts\";\nimport {\n    analyzeIntent,\n    detectCostIntent,\n    extractSpec,\n    graphClarify,\n    normalizeSpec,\n} from \"./clarify.ts\";\nimport { generateAnswer } from \"./llm.ts\";\nimport {\n    makeAnswerResponse,\n    makeClarifyResponse,\n} from \"./context.ts\";\nimport { buildSelectorPanel } from \"./resolve.ts\";\n\n// ━━━ [D] 컨텍스트 조합 ━━━\n\n// ─── 매트릭스(교차표) 렌더링 ───\n// Why: 동일 직종이 여러 기준(SCH, 규격, 작업조건 등)에 걸쳐 반복될 때\n//      플랫 4열 테이블 대신 행=직종, 열=기준의 교차표로 출력하면\n//      실무자가 한눈에 조건 간 수치를 비교할 수 있다.\nfunction renderMatrixTable(\n    items: RelatedResource[],\n    sectionId: string,\n    categoryLabel: string,  // \"투입 인력\" | \"투입 장비\" | \"사용 자재\"\n    nameLabel: string,      // \"직종\" | \"장비명\" | \"자재명\"\n): string {\n    if (items.length === 0) return \"\";\n\n    // 1) 각 항목에서 이름과 기준(spec) 추출\n    type Row = { name: string; spec: string; quantity: string; unit: string };\n    const rows: Row[] = items.map((item) => {\n        const props = (item.properties || {}) as any;\n        let specFallback = \"-\";\n        if (item.related_name.includes('_')) specFallback = item.related_name.split('_')[0];\n        const spec = props.source_spec || props.spec || props.per_unit || props.work_type_name || specFallback;\n        const itemName = item.related_name.includes('_') ? item.related_name.split('_')[1] : item.related_name;\n        return {\n            name: itemName,\n            spec: String(spec || \"-\"),\n            quantity: String(props.quantity ?? \"-\"),\n            unit: String(props.unit ?? (nameLabel === \"직종\" ? \"인\" : \"-\")),\n        };\n    });\n\n    // 2) 고유 기준(spec) 모으기 — 등장 순서 유지\n    const specSet = new Set<string>();\n    rows.forEach(r => specSet.add(r.spec));\n    const specs = Array.from(specSet);\n\n    // 3) 기준이 1개 이하면 심플(플랫) 테이블로 폴백\n    if (specs.length <= 1) {\n        const lines: string[] = [];\n        lines.push(`**[표 ${sectionId}] ${categoryLabel}**\\n`);\n        lines.push(`| ${nameLabel} | 수량 | 단위 | 기준 |`);\n        lines.push(\"| --- | ---: | --- | --- |\");\n        rows.forEach(r => {\n            lines.push(`| ${r.name} | ${r.quantity} | ${r.unit} | ${r.spec} |`);\n        });\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    }\n\n    // 4) 고유 이름(직종) 모으기 — 등장 순서 유지\n    const nameSet = new Set<string>();\n    rows.forEach(r => nameSet.add(r.name));\n    const names = Array.from(nameSet);\n\n    // 5) (이름, 기준) → 수량 매핑\n    const matrix = new Map<string, string>();\n    rows.forEach(r => {\n        matrix.set(`${r.name}||${r.spec}`, r.quantity);\n    });\n\n    // 6) 단위 정보 (첫 번째 항목에서)\n    const unitInfo = rows[0]?.unit || \"\";\n\n    // 7) 마크다운 테이블 생성\n    const lines: string[] = [];\n    lines.push(`**[표 ${sectionId}] ${categoryLabel}** (단위: ${unitInfo})\\n`);\n\n    // 헤더행\n    const header = `| ${nameLabel} | ` + specs.join(\" | \") + \" |\";\n    const sep = \"| --- | \" + specs.map(() => \"---:\").join(\" | \") + \" |\";\n    lines.push(header);\n    lines.push(sep);\n\n    // 데이터행\n    names.forEach(name => {\n        const cells = specs.map(spec => {\n            return matrix.get(`${name}||${spec}`) ?? \"—\";\n        });\n        lines.push(`| ${name} | ` + cells.join(\" | \") + \" |\");\n    });\n    lines.push(\"\");\n    return lines.join(\"\\n\");\n}\n\n// ─── tables JSON → Markdown 테이블 변환 ───\n// Why: graph_chunks.tables는 JSON이므로 LLM이 이해하려면 Markdown 변환 필요\nfunction tablesToMarkdown(tables: any[]): string {\n    return tables.map(t => {\n        if (!t.rows || t.rows.length === 0) return \"\";\n        const headers: string[] = t.headers || Object.keys(t.rows[0]);\n        const headerRow = \"| \" + headers.join(\" | \") + \" |\";\n        const sepRow = \"| \" + headers.map(() => \"---\").join(\" | \") + \" |\";\n        const dataRows = t.rows.map((r: any) =>\n            \"| \" + headers.map((h: string) => r[h] ?? \"\").join(\" | \") + \" |\"\n        );\n        // 표 하단 주석 (첫 번째 것만, 200자 제한)\n        const noteText = (t.notes_in_table && t.notes_in_table.length > 0)\n            ? `\\n> ${t.notes_in_table[0].substring(0, 300)}`\n            : \"\";\n        return [headerRow, sepRow, ...dataRows, noteText].filter(Boolean).join(\"\\n\");\n    }).filter(Boolean).join(\"\\n\\n\");\n}\n\nfunction buildContext(\n    entities: EntityResult[],\n    relationsAll: RelatedResource[][],\n    ilwiResults: IlwiItem[],\n    chunks: ChunkResult[],\n    specFilter?: string   // entity 직접 조회 시 두께/호칭경 등 spec 기준 필터\n): string {\n    const parts: string[] = [];\n\n    // 품셈 검색 결과\n    parts.push(\"## 품셈 검색 결과\\n\");\n\n    entities.forEach((entity, idx) => {\n        const relations = relationsAll[idx] || [];\n        const chunk = chunks.find((c) => c.section_id === entity.source_section);\n\n        // 출처 라벨 구성 (Codex F4)\n        const sectionLabel = chunk\n            ? `${chunk.department} > ${chunk.chapter} > ${chunk.title}`\n            : entity.source_section || \"출처 미확인\";\n\n        // 표번호 명시 (예: [표 13-5-1])\n        const sectionId = entity.source_section || \"\";\n\n        parts.push(\n            `### ${idx + 1}. [표 ${sectionId}] ${entity.name} (${entity.type}, 유사도: ${entity.similarity?.toFixed(3)})`\n        );\n        parts.push(`**표번호**: ${sectionId}`);\n        parts.push(`**출처**: ${sectionLabel}\\n`);\n\n        // Fix 4: 엔티티 속성 표시 (규격, 수량, 단위 등)\n        // Why: LLM이 엔티티의 세부 속성(spec, quantity 등)을 알아야 정확한 답변 가능\n        const entityProps = entity.properties || {};\n        const propEntries = Object.entries(entityProps)\n            .filter(([k]) => !['embedding', 'source_chunk_ids', 'chunk_id'].includes(k))\n            .filter(([, v]) => v !== null && v !== undefined && v !== '');\n        if (propEntries.length > 0) {\n            parts.push(`**속성**: ${propEntries.map(([k, v]) => `${k}=${v}`).join(', ')}\\n`);\n        }\n\n        // 관계별 그룹화\n        const grouped = new Map<string, RelatedResource[]>();\n        relations.forEach((r) => {\n            const key = r.relation;\n            if (!grouped.has(key)) grouped.set(key, []);\n            grouped.get(key)!.push(r);\n        });\n\n        // ─── 투입 인력 (매트릭스 렌더링) ───\n        const labor = grouped.get(\"REQUIRES_LABOR\") || [];\n        if (labor.length > 0) {\n            parts.push(renderMatrixTable(labor, sectionId, \"투입 인력\", \"직종\"));\n        }\n\n        // 투입 장비 (매트릭스 렌더링)\n        const equipment = grouped.get(\"REQUIRES_EQUIPMENT\") || [];\n        if (equipment.length > 0) {\n            parts.push(renderMatrixTable(equipment, sectionId, \"투입 장비\", \"장비명\"));\n        }\n\n        // 사용 자재 (매트릭스 렌더링)\n        const material = grouped.get(\"USES_MATERIAL\") || [];\n        if (material.length > 0) {\n            parts.push(renderMatrixTable(material, sectionId, \"사용 자재\", \"자재명\"));\n        }\n\n        // 주의사항 — Note 엔티티의 원문 우선 표시\n        // 데이터 구조: note_13-2-3_* → properties.content에 원문 저장 (expandGraph에서 note_content로 매핑)\n        //              Back Mirror 등 → properties.spec(조건)/quantity(계수) 저장\n        // Why: quantity는 계수(0.3)이지만 원문은 %(30%) 표기 → 변환 필요\n        const notes = grouped.get(\"HAS_NOTE\") || [];\n        if (notes.length > 0) {\n            // 중복 제거: note_content(원문)가 있는 항목과 개별 Note가 겹칠 수 있음\n            const seen = new Set<string>();\n            parts.push(`**[표 ${sectionId}] 주의사항**\\n`);\n            notes.forEach((n) => {\n                const props = (n.properties || {}) as any;\n                const content = props.note_content;  // expandGraph에서 주입된 원문\n                const spec = props.spec;\n                const quantity = props.quantity;\n\n                if (content) {\n                    // 원문 그대로 출력 (note_13-2-3_* 엔티티)\n                    const key = content.substring(0, 30);\n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        parts.push(`- ${content}`);\n                    }\n                } else {\n                    // 개별 Note (Back Mirror 등): quantity를 %로 변환\n                    const key = n.related_name;\n                    if (seen.has(key)) return;\n                    seen.add(key);\n\n                    let detail = n.related_name;\n                    if (quantity) {\n                        const pct = Math.round(Number(quantity) * 100);\n                        const action = n.related_name.includes('감') ? '감' : '가산';\n                        if (spec) {\n                            detail += `(${spec}): ${pct}%까지 ${action}`;\n                        } else {\n                            detail += `: ${pct}%까지 ${action}`;\n                        }\n                    } else if (spec) {\n                        detail += ` — ${spec}`;\n                    }\n                    parts.push(`- ${detail}`);\n                }\n            });\n            parts.push(\"\");\n        }\n\n        parts.push(\"---\\n\");\n    });\n\n    // 일위대가 비용 정보\n    if (ilwiResults.length > 0) {\n        parts.push(\"## 일위대가 비용 정보\\n\");\n        parts.push(\"| 항목 | 규격 | 노무비 | 재료비 | 경비 | 합계 |\");\n        parts.push(\"| --- | --- | --- | --- | --- | --- |\");\n        ilwiResults.slice(0, 5).forEach((item) => {\n            parts.push(\n                `| ${item.name} | ${item.spec || \"-\"} | ${item.labor_cost?.toLocaleString() ?? \"-\"} | ${item.material_cost?.toLocaleString() ?? \"-\"} | ${item.expense_cost?.toLocaleString() ?? \"-\"} | ${item.total_cost?.toLocaleString() ?? \"-\"} |`\n            );\n        });\n        parts.push(\"\");\n    }\n\n    // 원문 참고\n    // specFilter가 있으면 원문 참고 생략: 그래프 관계(REQUIRES_LABOR 등)에서 정확한 수치 제공\n    // Why: chunk.text에 전 범위 데이터(두께=3~50)가 포함 → LLM이 그래프 무시하고 원문 기준 전체 출력하는 문제\n    if (chunks.length > 0 && !specFilter) {\n        parts.push(\"## 원문 참고 (품셈 원문)\\n\");\n        chunks.forEach((chunk) => {\n            parts.push(`> **${chunk.section_id} ${chunk.title}**`);\n            parts.push(`> ${chunk.text}`);\n            parts.push(\"\");\n        });\n    } else if (chunks.length > 0 && specFilter) {\n        // spec 필터 적용 시: 출처 정보만 간결하게 제공\n        parts.push(\"## 원문 출처\\n\");\n        chunks.forEach((chunk) => {\n            parts.push(`> **[표 ${chunk.section_id}] ${chunk.title}** (${chunk.department} > ${chunk.chapter})`);\n            parts.push(\"\");\n        });\n    }\n\n    return parts.join(\"\\n\");\n}\n\n// ━━━ [G] 파이프라인 함수 ━━━\n\n// ─── answerPipeline: entity → graph 확장 → context → LLM → 응답 ───\n// Why: Phase -1(entity_id 직접조회)과 Phase 1b(search 결과 답변)의 중복 로직을 통합\nasync function answerPipeline(\n    entities: EntityResult[],\n    question: string,\n    history: ChatMessage[],\n    startTime: number,\n    opts?: {\n        skipSiblings?: boolean;   // entity_id 직접조회 시 형제 WT 스킵\n        specFilter?: string;      // 두께/규격 필터\n        answerOptions?: AnswerOptions;\n        analysis?: IntentAnalysis;\n    }\n): Promise<ChatResponse> {\n    const embeddingTokens = Math.ceil(question.length / 2);\n    const skipSiblings = opts?.skipSiblings ?? false;\n    const specFilter = opts?.specFilter;\n\n    // 💡 [핵심 패치] OOM 방지 및 하위 로직 인덱스 불일치 방지를 위해 상위 10건 확정\n    const targetEntities = entities.slice(0, 10);\n\n    // [1] 그래프 확장 (병렬)\n    // 💡 [핵심 패치] Caller 레벨에서 source_section 중복 방문 차단 (연쇄 팽창 방지)\n    const visitedSections = new Set<string>();\n    const relationsPromises = targetEntities.map(async (e) => {\n        // source_section 중복 방문 차단\n        if (e.source_section && visitedSections.has(e.source_section)) {\n            // 동일 section은 skipSectionExpansion=true로 1-hop만 조회\n            return expandGraph(e.id, e.type, true);\n        }\n        if (e.source_section) visitedSections.add(e.source_section);\n\n        return expandGraph(e.id, e.type, skipSiblings);\n    });\n    const relationsAll = await Promise.all(relationsPromises);\n\n    // [2] 비용 의도 → 일위대가 검색\n    let ilwiResults: IlwiItem[] = [];\n    if (detectCostIntent(question)) {\n        for (const e of targetEntities.filter(e => e.type === \"WorkType\")) {\n            const spec = extractSpec(question);\n            const items = await searchIlwi(e.name, spec);\n            if (items.length > 0) { ilwiResults.push(...items); break; }\n        }\n    }\n\n    // [3] 원문 청크 보강\n    const chunks = await retrieveChunks(targetEntities, specFilter);\n    if (specFilter) console.log(`[answerPipeline] specFilter=\"${specFilter}\" 적용`);\n\n    // [4] 컨텍스트 조합\n    let context = buildContext(targetEntities, relationsAll, ilwiResults, chunks, specFilter);\n\n    // [4-1] cost_calculate/report_request 시 노임단가 주입\n    const effectiveIntent = opts?.answerOptions?.intent || opts?.analysis?.intent;\n    if (effectiveIntent === \"cost_calculate\" || effectiveIntent === \"report_request\") {\n        const laborNames = relationsAll.flat()\n            .filter(r => r.relation === \"REQUIRES_LABOR\")\n            .map(r => r.related_name)\n            .filter(Boolean);\n        if (laborNames.length > 0) {\n            const laborCosts = await fetchLaborCosts(laborNames);\n            if (laborCosts.length > 0) {\n                context += \"\\n\\n## [2026년 노임단가]\\n\";\n                context += \"| 직종 | 노임단가(원/일) |\\n|---|---:|\\n\";\n                laborCosts.forEach(lc => {\n                    context += `| ${lc.job_name} | ${lc.cost_2026.toLocaleString()} |\\n`;\n                });\n            }\n        }\n    }\n\n    // [5] LLM 답변 생성\n    const llmResult = await generateAnswer(question, context, history, {\n        intent: effectiveIntent,\n        quantity: opts?.answerOptions?.quantity || opts?.analysis?.quantity || undefined,\n    });\n\n    // [6] 응답 조립\n    const sourcesWithSection: SourceInfo[] = targetEntities.map(e => {\n        const chunk = chunks.find(c => c.section_id === e.source_section);\n        return {\n            entity_id: e.id,\n            entity_name: e.name,\n            entity_type: e.type,\n            source_section: e.source_section,\n            section_label: chunk\n                ? `${chunk.department} > ${chunk.chapter} > ${chunk.title}`\n                : e.source_section || undefined,\n            similarity: e.similarity,\n        };\n    });\n\n    return makeAnswerResponse(llmResult.answer, startTime, {\n        sources: sourcesWithSection,\n        entities: targetEntities, relations: relationsAll,\n        ilwi: ilwiResults, chunks,\n        embeddingTokens, llmResult,\n    });\n}\n\n// ─── fullViewPipeline: section 전체 원문 → WorkType 탐색 → context → LLM ───\n// Why: full_view 4단계 폴백(직접→cross-ref→하위절→Section) 로직을 handleChat에서 분리\nasync function fullViewPipeline(\n    sectionId: string,\n    question: string,\n    history: ChatMessage[],\n    startTime: number\n): Promise<ChatResponse> {\n    const embeddingTokens = Math.ceil(question.length / 2);\n\n    // ── sub_section 파싱: \"13-2-4:sub=1. 전기아크용접(V형)\" → base + sub 키워드\n    const decodedSectionId = decodeURIComponent(sectionId);\n    const subMatch = decodedSectionId.match(/^(.+?):sub=(.+)$/);\n    const baseSectionId = subMatch ? subMatch[1] : decodedSectionId;\n    const subKeyword = subMatch ? subMatch[2].replace(/^\\d+\\.\\s*/, '') : null;\n\n    console.log(`[fullViewPipeline] base=${baseSectionId}, sub=${subKeyword || 'none'} 전체 원문 조회`);\n\n    // [1] 전체 chunk 로딩\n    const { data: chunkData } = await supabase\n        .from(\"graph_chunks\")\n        .select(\"id, section_id, title, department, chapter, section, text, tables\")\n        .eq(\"section_id\", baseSectionId)\n        .limit(20);\n\n    let allChunks = (chunkData || []) as any[];\n\n    // [1-1] sub_section 필터\n    if (subKeyword && allChunks.length > 1) {\n        const filtered = allChunks.filter(c =>\n            (c.text && c.text.includes(subKeyword)) ||\n            (c.tables && JSON.stringify(c.tables).includes(subKeyword))\n        );\n        if (filtered.length > 0) {\n            console.log(`[fullViewPipeline] sub \"${subKeyword}\" 필터: ${allChunks.length}건 → ${filtered.length}건`);\n            allChunks = filtered;\n        }\n    }\n\n    // [2] chunk 병합 (text + tables → 하나의 메타 chunk)\n    const chunk = allChunks[0] ? { ...allChunks[0] } : null;\n    if (chunk && allChunks.length >= 1) {\n        chunk.text = allChunks\n            .map(c => {\n                let t = c.text || \"\";\n                if (c.tables && Array.isArray(c.tables) && c.tables.length > 0) {\n                    t += (t ? \"\\n\" : \"\") + tablesToMarkdown(c.tables);\n                }\n                return t;\n            })\n            .filter(t => t.length > 0)\n            .join(\"\\n\\n\");\n        console.log(`[fullViewPipeline] ${allChunks.length}건 chunk 병합, text_len=${chunk.text.length}`);\n    }\n\n    if (!chunk) {\n        console.warn(`[fullViewPipeline] section_id=${baseSectionId} 원문 없음 → 안내`);\n        return makeAnswerResponse(\n            `해당 절(${baseSectionId})의 원문 데이터를 찾을 수 없습니다.\\n다른 작업을 선택하거나, 다시 검색해 주세요.`,\n            startTime\n        );\n    }\n\n    // [3] WorkType 4단계 폴백 탐색\n    let wtEntities: EntityResult[] = [];\n    let relationsAll: any[][] = [];\n\n    // 3-1: 직접 매칭\n    const { data: sectionWTData } = await supabase\n        .from(\"graph_entities\")\n        .select(\"id, name, type, properties, source_section\")\n        .eq(\"type\", \"WorkType\")\n        .eq(\"source_section\", baseSectionId)\n        .limit(20);\n\n    const sectionWTs = (sectionWTData || []) as any[];\n    console.log(`[fullViewPipeline] WorkType ${sectionWTs.length}건 (baseSectionId=${baseSectionId})`);\n\n    if (sectionWTs.length > 0) {\n        wtEntities = sectionWTs.map(wt => ({\n            id: wt.id, name: wt.name, type: wt.type,\n            properties: wt.properties || {},\n            source_section: wt.source_section,\n            similarity: 1.0,\n        }));\n        const rp = wtEntities.map(e => expandGraph(e.id, e.type));\n        relationsAll = await Promise.all(rp);\n    } else {\n        // 3-2: cross-reference (동일 title의 다른 section)\n        console.log(`[fullViewPipeline] baseSectionId=${baseSectionId} WorkType 0건 → cross-reference 탐색`);\n        const { data: siblings } = await supabase\n            .from(\"graph_chunks\")\n            .select(\"section_id\")\n            .eq(\"title\", chunk.title)\n            // 💡 [핵심 패치] 도메인 격리: 동일 부문(department)과 장(chapter)이 일치할 때만 병합\n            .eq(\"department\", chunk.department)\n            .eq(\"chapter\", chunk.chapter);\n        const siblingIds = [...new Set(\n            (siblings || []).map((s: any) => s.section_id).filter((sid: string) => sid !== baseSectionId)\n        )];\n\n        if (siblingIds.length > 0) {\n            const { data: siblingWTs } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, properties, source_section\")\n                .eq(\"type\", \"WorkType\")\n                .in(\"source_section\", siblingIds)\n                .limit(30);\n\n            if (siblingWTs && siblingWTs.length > 0) {\n                console.log(`[fullViewPipeline] cross-ref에서 ${siblingWTs.length}건 WorkType 발견`);\n                wtEntities = (siblingWTs as any[]).map(wt => ({\n                    id: wt.id, name: wt.name, type: wt.type,\n                    properties: wt.properties || {},\n                    source_section: wt.source_section,\n                    similarity: 0.95,\n                }));\n                const rp = wtEntities.map(e => expandGraph(e.id, e.type));\n                relationsAll = await Promise.all(rp);\n            }\n        }\n\n        if (wtEntities.length === 0) {\n            // 3-3: 하위 절(children) WorkType 탐색\n            const childBaseSectionId = baseSectionId.includes('#') ? baseSectionId.split('#')[0] : baseSectionId;\n            const childPrefix = childBaseSectionId + '-';\n            console.log(`[fullViewPipeline] cross-ref 실패 → 하위 절 탐색 (prefix=${childPrefix})`);\n\n            const { data: childWTs } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, properties, source_section\")\n                .eq(\"type\", \"WorkType\")\n                .ilike(\"source_section\", `${childPrefix}%`)\n                .limit(50);\n\n            if (childWTs && childWTs.length > 0) {\n                console.log(`[fullViewPipeline] 하위 절에서 ${childWTs.length}건 WorkType 발견`);\n                wtEntities = (childWTs as any[]).map(wt => ({\n                    id: wt.id, name: wt.name, type: wt.type,\n                    properties: wt.properties || {},\n                    source_section: wt.source_section,\n                    similarity: 0.98,\n                }));\n                const rp = wtEntities.map(e => expandGraph(e.id, e.type));\n                relationsAll = await Promise.all(rp);\n\n                // 하위 절 chunk 텍스트 보강\n                const childSectionIds = [...new Set(childWTs.map((w: any) => w.source_section))];\n                const { data: childChunks } = await supabase\n                    .from(\"graph_chunks\")\n                    .select(\"id, section_id, title, department, chapter, section, text\")\n                    .in(\"section_id\", childSectionIds)\n                    .limit(10);\n\n                if (childChunks && childChunks.length > 0) {\n                    const childTexts = (childChunks as any[])\n                        .filter(c => c.text && c.text.length > 10)\n                        .map(c => `### ${c.section_id} ${c.title}\\n${c.text}`)\n                        .join('\\n\\n');\n                    if (childTexts) chunk.text = (chunk.text || '') + '\\n\\n' + childTexts;\n                }\n            } else {\n                // 3-4: Section 자체 확장 (최후 수단)\n                const { data: sectionEntity } = await supabase\n                    .from(\"graph_entities\")\n                    .select(\"id, name, type, properties, source_section\")\n                    .eq(\"type\", \"Section\")\n                    .eq(\"source_section\", baseSectionId)\n                    .limit(1);\n\n                if (sectionEntity && sectionEntity.length > 0) {\n                    const se = sectionEntity[0] as any;\n                    wtEntities = [{\n                        id: se.id, name: se.name, type: se.type,\n                        properties: se.properties || {},\n                        source_section: se.source_section,\n                        similarity: 1.0,\n                    }];\n                    const sectionRels = await expandGraph(se.id, \"Section\");\n                    relationsAll = [sectionRels];\n                }\n            }\n        }\n    }\n\n    // [4] 원문 + 그래프 관계 컨텍스트 → LLM → 응답\n    const context = [\n        `## 품셈 원문: ${chunk.title}`,\n        `**출처**: ${chunk.department} > ${chunk.chapter} > ${chunk.title}`,\n        `**표번호**: ${chunk.section_id}`,\n        `\\n${chunk.text}`,\n        `\\n---\\n`,\n        buildContext(wtEntities, relationsAll, [], [chunk as ChunkResult]),\n    ].join(\"\\n\");\n\n    const llmResult = await generateAnswer(question, context, history);\n\n    return makeAnswerResponse(llmResult.answer, startTime, {\n        sources: [{\n            entity_name: chunk.title,\n            entity_type: \"Section\",\n            source_section: chunk.section_id,\n            section_label: `${chunk.department} > ${chunk.chapter} > ${chunk.title}`,\n            similarity: 1.0,\n        }],\n        entities: wtEntities, relations: relationsAll,\n        chunks: [chunk as any],\n        embeddingTokens, llmResult,\n    });\n}\n\n// ─── searchPipeline: embedding → targetSearch → Section-Only 분기 → answer ───\n// Why: 검색 + 결과 평가 + 답변/clarify 분기를 handleChat에서 분리\nasync function searchPipeline(\n    analysis: IntentAnalysis,\n    question: string,\n    history: ChatMessage[],\n    startTime: number,\n    answerOptions?: AnswerOptions\n): Promise<ChatResponse> {\n    const embeddingTokens = Math.ceil(question.length / 2);\n\n    // [1] 질문 임베딩\n    const embedding = await generateEmbedding(question);\n\n    // [1-1] 💡 [Track B-1 최적화] 동의어 재료 즉시 추출 (targetSearch 대기 불필요)\n    // Why: domainExp는 analysis(LLM 분석 결과)에서만 산출. targetSearch 결과 의존 없음.\n    //      따라서 targetSearch와 동의어 WorkType 쿼리를 Promise.all로 병렬 실행하여\n    //      순차 I/O 대기시간(+1.4s)을 targetSearch의 대기시간에 완전히 가려(Shadowing) 제거.\n    const { expandDomainSynonyms } = await import(\"./search.ts\");\n    const domainTerms = analysis.work_name\n        ? [analysis.work_name, ...(analysis.keywords || [])]\n        : analysis.keywords || [];\n    const domainExp = expandDomainSynonyms(domainTerms);\n    const synOrClauses = domainExp.length > 0\n        ? domainExp.map(s => `name.ilike.%${s}%`).join(\",\")\n        : null;\n\n    // [1-2] 💡 메인 검색 + 동의어 서브 검색을 Promise.all로 병렬 출발\n    const [entities, synWTsResponse] = await Promise.all([\n        targetSearch(analysis, embedding, question),\n        synOrClauses\n            ? supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, source_section, properties\")\n                .eq(\"type\", \"WorkType\")\n                .or(synOrClauses)\n                .limit(50)\n            : Promise.resolve({ data: [] as any[], error: null }),\n    ]);\n    const synonymWorkTypes = synWTsResponse.data || [];\n    if (synonymWorkTypes.length > 0) {\n        console.log(`[searchPipeline] 도메인 동의어 WorkType: ${synonymWorkTypes.length}건 (${domainExp.join(\",\")})`);\n    }\n\n    // [2] Section만 매칭 → clarify 분기\n    const sectionOnly = entities.length > 0 && entities.every(e => e.type === \"Section\");\n    if (sectionOnly) {\n        const sectionSourceIds = [...new Set(entities.map(e => e.source_section).filter(Boolean))] as string[];\n\n        // Section source_section + 동의어 WorkType source_section 병합\n        const synSectionIds = [...new Set(synonymWorkTypes.map(w => w.source_section).filter(Boolean))] as string[];\n        const allSectionIds = [...new Set([...sectionSourceIds, ...synSectionIds])];\n\n        if (allSectionIds.length > 1) {\n            // 복수 분야: 섹션 선택 칩 직접 생성\n            console.log(`[searchPipeline] Section ${sectionSourceIds.length}개 + 동의어 ${synSectionIds.length}개 = 총 ${allSectionIds.length}개 분야 → 섹션 선택`);\n            const { data: chunkMetas } = await supabase\n                .from(\"graph_chunks\")\n                .select(\"section_id, department, chapter, title\")\n                .in(\"section_id\", allSectionIds);\n\n            const metaMap = new Map<string, any>();\n            for (const cm of (chunkMetas || [])) {\n                if (!metaMap.has(cm.section_id)) metaMap.set(cm.section_id, cm);\n            }\n\n            // Section 엔티티 기반 옵션\n            const options: ClarifyOption[] = entities.slice(0, 10).map(s => {\n                const meta = metaMap.get(s.source_section || \"\");\n                const label = meta\n                    ? `${meta.department} > ${meta.chapter} > ${meta.title}`\n                    : `[${s.source_section || \"\"}] ${s.name}`;\n                return {\n                    label,\n                    query: `${s.name} 품셈`,\n                    source_section: s.source_section,\n                    section_id: s.source_section,\n                    option_type: 'section' as const,\n                };\n            });\n\n            // 동의어 WorkType의 source_section 중 Section에 없는 것 추가\n            const existingSrcSet = new Set(sectionSourceIds);\n            const addedSynSrcSet = new Set<string>();\n            for (const wt of synonymWorkTypes) {\n                if (wt.source_section && !existingSrcSet.has(wt.source_section) && !addedSynSrcSet.has(wt.source_section)) {\n                    addedSynSrcSet.add(wt.source_section);\n                    const meta = metaMap.get(wt.source_section);\n                    const label = meta\n                        ? `${meta.department} > ${meta.chapter} > ${meta.title}`\n                        : `[${wt.source_section}] ${wt.name}`;\n                    options.push({\n                        label,\n                        query: `${meta?.title || wt.name} 품셈`,\n                        source_section: wt.source_section,\n                        section_id: wt.source_section,\n                        option_type: 'section' as const,\n                    });\n                }\n            }\n\n            return makeClarifyResponse(\n                `\"${question}\" 관련 품셈이 **${allSectionIds.length}개 분야**에 있습니다.\\n어떤 분야의 품셈을 찾으시나요?`,\n                startTime,\n                {\n                    options,\n                    reason: `'${entities[0].name}' 관련 품셈이 여러 분야에 존재하여 선택이 필요합니다.`,\n                    original_query: question,\n                },\n                { entities }\n            );\n        }\n\n        // 단일 섹션: 하위 WorkType 확인\n        const singleSectionId = sectionSourceIds[0];\n        const { data: childWorkTypes } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id, name, type, properties, source_section\")\n            .eq(\"type\", \"WorkType\")\n            .eq(\"source_section\", singleSectionId)\n            .limit(200);\n\n        if (childWorkTypes && childWorkTypes.length > 3) {\n            console.log(`[searchPipeline] Section 1개 + WorkType ${childWorkTypes.length}개 → Step 2`);\n            const clarifyResult = await graphClarify(\n                { ...analysis, intent: \"clarify_needed\" as const, work_name: analysis.work_name || entities[0].name },\n                singleSectionId\n            );\n            return makeClarifyResponse(clarifyResult.message, startTime, {\n                options: clarifyResult.options,\n                reason: `'${entities[0].name}' 하위에 ${childWorkTypes.length}개 작업이 있어 선택이 필요합니다.`,\n                original_query: question,\n                selector: clarifyResult.selector,\n            }, { entities });\n        }\n        // WT ≤ 3 → answerPipeline으로 진행\n    }\n\n    // [3] 검색 결과 없음\n    if (entities.length === 0) {\n        const llmResult = await generateAnswer(\n            question,\n            \"제공된 품셈 데이터베이스에서 관련 정보를 찾지 못했습니다.\",\n            history\n        );\n        return makeAnswerResponse(llmResult.answer, startTime, {\n            embeddingTokens, llmResult,\n        });\n    }\n\n    // [4] WorkType 매칭 → answerPipeline\n    return answerPipeline(entities, question, history, startTime, {\n        answerOptions, analysis,\n    });\n}\n\n// ━━━ [H] 메인 핸들러 (라우터) ━━━\n\n// ─── 특수 테이블 전용 감지기 및 파이프라인 (Phase 1.5) ───\ninterface ComplexTableQuery {\n    section_code: string;       // '13-1-1'\n    material?: string;          // '배관용 탄소강관'\n    spec_mm?: number;           // 200\n    pipe_location?: string;     // '옥내' | '옥외'\n    joint_type?: string;        // '용접식' | '나사식'\n    quantity_value?: number;    // 10 (m)\n}\n\nconst COMPLEX_TABLE_TRIGGERS: Record<string, {\n    section_code: string;\n    materials: string[];\n}> = {\n    \"플랜트 배관\": {\n        section_code: \"13-1-1\",\n        materials: [\"탄소강관\", \"합금강\", \"스텐레스\", \"스테인리스\", \"알루미늄\",\n            \"동관\", \"황동\", \"KSD3507\", \"A335\", \"Type304\", \"Monel\", \"백관\", \"흑관\"]\n    }\n};\n\nfunction detectComplexTable(question: string): ComplexTableQuery | null {\n    for (const [trigger, config] of Object.entries(COMPLEX_TABLE_TRIGGERS)) {\n        const triggerWords = trigger.split(\" \");\n        const allTriggerMatch = triggerWords.every(w => question.includes(w));\n        if (!allTriggerMatch) continue;\n\n        const matchedMaterial = config.materials.find(m => question.includes(m));\n\n        const specMatch = question.match(/(\\d{2,4})\\s*(mm|A|a|㎜)/);\n        const spec_mm = specMatch ? parseInt(specMatch[1]) : undefined;\n\n        const pipe_location = question.includes(\"옥외\") ? \"옥외\" : (question.includes(\"옥내\") ? \"옥내\" : undefined);\n        const joint_type = question.includes(\"나사\") ? \"나사식\" : (question.includes(\"용접\") ? \"용접식\" : undefined);\n\n        const qtyMatch = question.match(/(\\d+(?:\\.\\d+)?)\\s*(m|미터|M|ton|톤)\\b/);\n        const quantity_value = qtyMatch ? parseFloat(qtyMatch[1]) : undefined;\n\n        return {\n            section_code: config.section_code,\n            material: matchedMaterial,\n            spec_mm,\n            pipe_location,\n            joint_type,\n            quantity_value,\n        };\n    }\n    return null;\n}\n\nfunction findBestCostMatch(\n    jobName: string,\n    costMap: Map<string, number>\n): { name: string; cost: number } | null {\n    if (costMap.has(jobName)) return { name: jobName, cost: costMap.get(jobName)! };\n    const normalized = jobName.replace(/\\s+/g, '');\n    for (const [key, cost] of costMap) {\n        if (key.replace(/\\s+/g, '') === normalized) return { name: key, cost };\n    }\n    let bestMatch: { name: string; cost: number } | null = null;\n    for (const [key, cost] of costMap) {\n        const keyNorm = key.replace(/\\s+/g, '');\n        if (keyNorm.includes(normalized) || normalized.includes(keyNorm)) {\n            if (!bestMatch || key.length < bestMatch.name.length) {\n                bestMatch = { name: key, cost };\n            }\n        }\n    }\n    return bestMatch;\n}\n\nasync function complexTablePipeline(\n    query: ComplexTableQuery,\n    question: string,\n    history: ChatMessage[],\n    startTime: number\n): Promise<ChatResponse> {\n    console.log(`[complexTablePipeline] section=${query.section_code}, ` +\n        `material=${query.material}, spec=${query.spec_mm}, ` +\n        `location=${query.pipe_location}, joint=${query.joint_type}`);\n\n    let dbQuery = supabase\n        .from(\"complex_table_specs\")\n        .select(\"*\")\n        .eq(\"section_code\", query.section_code);\n\n    if (query.material) dbQuery = dbQuery.ilike(\"material\", `%${query.material}%`);\n    if (query.pipe_location) dbQuery = dbQuery.eq(\"pipe_location\", query.pipe_location);\n    if (query.joint_type) dbQuery = dbQuery.eq(\"joint_type\", query.joint_type);\n\n    const { data: specs, error } = await dbQuery;\n\n    let filteredSpecs: any[] = specs || [];\n    if (query.spec_mm) {\n        filteredSpecs = filteredSpecs.filter((s: any) => s.spec_mm === query.spec_mm);\n    }\n\n    if (query.material && filteredSpecs.length > 0) {\n        const uniqueMaterials = [...new Set(filteredSpecs.map(s => s.material))];\n        let bestMaterial = uniqueMaterials[0];\n        for (const mat of uniqueMaterials) {\n            const matPrefix = mat.split('(')[0];\n            if (question.replace(/\\s+/g, '').includes(matPrefix.replace(/\\s+/g, ''))) {\n                bestMaterial = mat;\n                break;\n            }\n        }\n        filteredSpecs = filteredSpecs.filter((s: any) => s.material === bestMaterial);\n    }\n\n    if (filteredSpecs.length === 0) {\n        console.warn(\"[complexTablePipeline] 전용 DB에 데이터 없음 → 일반 search 폴백/안내\");\n        // Fallback to normal semantic search if missing\n        const analysis = await analyzeIntent(question, history);\n        return searchPipeline(analysis, question, history, startTime);\n    }\n\n    // Step 1.5: 다중 조합(재질, 배관장소, 접합방식)일 경우 사용자에게 Clarification 요청\n    const uniqueCombos = [...new Set(filteredSpecs.map(s => `${s.material}||${s.pipe_location}||${s.joint_type}`))];\n    if (uniqueCombos.length > 1) {\n        const options: ClarifyOption[] = uniqueCombos.slice(0, 15).map(combo => {\n            const [mat, loc, jnt] = combo.split('||');\n            return {\n                label: `${mat} (${loc} ${jnt})`, // 간결하게 표시\n                query: `플랜트 배관 설치 ${mat} ${loc} ${jnt}`,\n                option_type: 'section',\n                section_id: query.section_code\n            };\n        });\n\n        // forceSelector=true 로 체크박스 UI 강제 활성화\n        const selector = buildSelectorPanel(options, `[${query.section_code}] 배관 설치`, true);\n\n        return makeClarifyResponse(\n            `\"${question}\"에 해당하는 품셈 기준이 여러 개 발견되었습니다. 단일 기준을 선택해 주세요.`,\n            startTime,\n            {\n                options,\n                reason: \"재질, 배관구분, 접합방식이 명확하지 않아 선택이 필요합니다.\",\n                original_query: question,\n                ...(selector ? { selector } : {})\n            }\n        );\n    }\n\n    // 단일 조합 확정\n    const exactMat = filteredSpecs[0].material;\n    const exactLoc = filteredSpecs[0].pipe_location;\n    const exactJnt = filteredSpecs[0].joint_type;\n\n    // Step 2: 2026 노임단가 사전연산\n    const jobNames = [...new Set(filteredSpecs.map((s: any) => s.job_name as string))];\n    const laborCosts = await fetchLaborCosts(jobNames);\n    const costMap = new Map(laborCosts.map(lc => [lc.job_name, lc.cost_2026]));\n\n    const quantityMultiplier = query.quantity_value || 1;\n    const quantityUnit = filteredSpecs[0]?.quantity_unit || \"인/100m\";\n    const unitLabel = quantityUnit === \"인/100m\" ? \"100m\" : quantityUnit.replace(\"인/\", \"\");\n\n    let context = `## 📋 [${query.section_code}] ${filteredSpecs[0]?.section_name}\\n\\n`;\n    context += `**재질**: ${exactMat} | **배관구분**: ${exactLoc} | **접합방식**: ${exactJnt}\\n\\n`;\n\n    const uniqueSpecs = [...new Set(filteredSpecs.map((s: any) => s.spec_mm))].sort((a, b) => a - b);\n    const hasMultipleSpecs = uniqueSpecs.length > 1;\n\n    context += `## [2026년 노임단가 기반 산출 결과 (백엔드 계산 완료)]\\n\\n`;\n\n    let totalCost = 0;\n    if (hasMultipleSpecs) {\n        // [매트릭스 렌더링]: 구경(mm)이 컬럼이 되는 테이블\n        const specHeaders = uniqueSpecs.map(s => `${s}mm`).join(\" | \");\n        const specSep = uniqueSpecs.map(() => \"---:\").join(\" | \");\n\n        context += `| 직종 | 노임단가(원/일) | ${specHeaders} |\\n`;\n        context += `|---|---:|${specSep}|\\n`;\n\n        for (const job of jobNames) {\n            const matched = findBestCostMatch(job, costMap);\n            const unitCost = matched?.cost ?? 0;\n\n            const rowValues = uniqueSpecs.map(spec => {\n                const item = filteredSpecs.find((s: any) => s.job_name === job && s.spec_mm === spec);\n                return item ? item.quantity : \"-\";\n            });\n\n            context += `| ${job} | ${unitCost.toLocaleString()} | ` + rowValues.join(\" | \") + ` |\\n`;\n        }\n\n        if (quantityMultiplier !== 1) {\n            context += `\\n> 💡 **참고**: 수량(${quantityMultiplier}${unitLabel.replace(\"100m\", \"m\")})을 전체 노임비로 계산하시려면, 특정 구경(mm) 하나를 이어서 다시 질문해 주세요.\\n`;\n        }\n    } else {\n        // [플랫 테이블 렌더링]: 단일 구경의 세부 조건과 합산된 노무비 (기존 로직)\n        const specInfo = filteredSpecs[0];\n        context += `**구경**: ${specInfo.spec_mm}mm | **외경**: ${specInfo.outer_dia_mm}mm | **두께**: ${specInfo.thickness_mm}mm | **단위중량**: ${specInfo.unit_weight}kg/m\\n\\n`;\n\n        context += `| 직종 | 품(${unitLabel}당) | 노임단가(원/일) | `;\n        if (quantityMultiplier > 1) {\n            const displayUnit = unitLabel === \"100m\" ? \"m\" : unitLabel;\n            context += `${quantityMultiplier}${displayUnit} 환산 금액(원) | `;\n        }\n        context += `비고 |\\n|---|---:|---:|`;\n        if (quantityMultiplier > 1) context += `---:|`;\n        context += `---|\\n`;\n\n        for (const spec of filteredSpecs) {\n            const matched = findBestCostMatch(spec.job_name, costMap);\n            const unitCost = matched?.cost ?? 0;\n            const qtyPer100m = parseFloat(spec.quantity);\n\n            const actualQty = quantityUnit === \"인/100m\"\n                ? qtyPer100m * (quantityMultiplier / 100)\n                : qtyPer100m * quantityMultiplier;\n            const amount = Math.round(actualQty * unitCost);\n            totalCost += amount;\n\n            context += `| ${spec.job_name} | ${spec.quantity} | ${unitCost.toLocaleString()} | `;\n            if (quantityMultiplier > 1) {\n                context += `${amount.toLocaleString()} | `;\n            }\n            context += `${query.section_code} |\\n`;\n        }\n\n        if (quantityMultiplier > 1) {\n            const toolCost = Math.round(totalCost * 0.03);\n            context += `| 공구손료 (3%) | - | - | ${toolCost.toLocaleString()} | 인력품의 3% |\\n`;\n            totalCost += toolCost;\n            context += `| **합계** | | | **${totalCost.toLocaleString()}** | |\\n`;\n        }\n    }\n\n    context += `\\n> ⚠️ 위 금액은 **전용 정형화 DB에서 정확히 조회**되어 백엔드에서 계산한 확정값입니다.\\n`;\n    context += `> LLM은 이 숫자를 절대 수정하지 말고 그대로 출력하세요.\\n`;\n\n    // Step 3: LLM 포장\n    const llmResult = await generateAnswer(question, context, history, {\n        intent: \"cost_calculate\",\n        quantity: query.quantity_value,\n    });\n\n    const sources: SourceInfo[] = [{\n        entity_name: `${filteredSpecs[0]?.section_name} (${filteredSpecs[0]?.material})`,\n        entity_type: \"ComplexTable\" as any,\n        source_section: query.section_code,\n        section_label: `${filteredSpecs[0]?.section_name}`,\n        similarity: 1.0\n    }];\n\n    return makeAnswerResponse(llmResult.answer, startTime, {\n        sources,\n        embeddingTokens: 0,\n        llmResult,\n    });\n}\n\nasync function handleChat(\n    question: string,\n    history: ChatMessage[],\n    entityId?: string,\n    sectionId?: string,\n    sessionContext?: SessionContext,\n    answerOptions?: AnswerOptions\n): Promise<ChatResponse> {\n    const startTime = Date.now();\n\n    // ═══ Route 0.5: 특수 복합 테이블 전용 라우터 (Phase 1.5) ═══\n    const complexTableMatch = detectComplexTable(question);\n    if (complexTableMatch) {\n        console.log(`[handleChat] 🎯 Route 0.5: 특수 테이블 감지 → ${complexTableMatch.section_code}`);\n        return complexTablePipeline(complexTableMatch, question, history, startTime);\n    }\n\n    // ═══ Route 1: entity_id 직접 조회 (칩 선택 시) ═══\n    if (entityId) {\n        const entityIds = entityId.split(',').map(s => s.trim()).filter(Boolean);\n        console.log(`[handleChat] entity_ids=[${entityIds.join(',')}] → answerPipeline`);\n        const { data: directEntities } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id, name, type, properties, source_section\")\n            .in(\"id\", entityIds);\n\n        if (directEntities && directEntities.length > 0) {\n            const entities: EntityResult[] = directEntities.map((de: any) => ({\n                id: de.id, name: de.name, type: de.type,\n                properties: de.properties || {},\n                source_section: de.source_section,\n                similarity: 1.0,\n            }));\n            const firstSpec = entities[0]?.properties?.spec as string || \"\";\n            const specNum = firstSpec.match(/^(\\d+)/)?.[1];\n            return answerPipeline(entities, question, history, startTime, {\n                skipSiblings: true,\n                specFilter: specNum,\n                answerOptions,\n            });\n        }\n    }\n\n    // ═══ Route 2: section_id → full_view or Step 2 clarify ═══\n    if (sectionId) {\n        console.log(`[handleChat] section_id=${sectionId} → 섹션 내 탐색`);\n        const isSubSection = sectionId.includes(\":sub=\");\n        const isFullView = isSubSection || question.includes(\"전체\") || question.includes(\"목록\");\n\n        if (isFullView) return fullViewPipeline(sectionId, question, history, startTime);\n\n        // Step 2: 해당 섹션 내 하목 선택 옵션 제시\n        const clarifyAnalysis: IntentAnalysis = {\n            intent: \"clarify_needed\",\n            work_name: question.replace(/품셈|전체|\\s/g, \"\") || null,\n            spec: null,\n            keywords: [],\n            ambiguity_reason: \"섹션 내 하목 선택이 필요합니다.\",\n        };\n        const clarifyResult = await graphClarify(clarifyAnalysis, sectionId);\n        return makeClarifyResponse(clarifyResult.message, startTime, {\n            options: clarifyResult.options,\n            reason: \"섹션 내 하위 작업을 선택해 주세요.\",\n            original_query: question,\n            selector: clarifyResult.selector,\n        });\n    }\n\n    // ═══ Route 3: 의도 분석 (DeepSeek v3.2) ═══\n    const analysis = await analyzeIntent(question, history, sessionContext);\n    analysis.spec = normalizeSpec(analysis.spec);\n\n    // ─── 인사/도움말 ───\n    // Fix A: LLM이 공종 쿼리를 greeting으로 오분류한 경우 clarify_needed로 강제 교정\n    if (analysis.intent === \"greeting\") {\n        const workTerms = [\"설치\", \"용접\", \"배관\", \"시공\", \"제작\", \"타설\", \"철거\", \"해체\", \"보온\", \"도장\", \"미장\", \"조적\", \"플랜지\", \"강관\", \"덕트\", \"콘크리트\", \"거푸집\", \"철근\", \"굴착\", \"성토\", \"절토\", \"포장\"];\n        if (workTerms.some((t) => question.includes(t))) {\n            analysis.intent = \"clarify_needed\";\n            console.log(`[Fix A] greeting → clarify_needed (question=\"${question}\")`);\n        }\n    }\n    if (analysis.intent === \"greeting\") {\n        return makeAnswerResponse(\n            \"안녕하세요! 건설 공사 표준품셈 AI 어시스턴트입니다. 🏗️\\n\\n\" +\n            \"다음과 같은 질문이 가능합니다:\\n\" +\n            \"- **품셈 검색**: \\\"강관용접 200mm SCH 40 품셈\\\"\\n\" +\n            \"- **인력 투입량**: \\\"콘크리트 타설 인력\\\"\\n\" +\n            \"- **비용 산출**: \\\"거푸집 설치 일위대가\\\"\\n\\n\" +\n            \"공종명과 규격을 함께 입력하면 더 정확한 결과를 얻을 수 있습니다.\",\n            startTime\n        );\n    }\n\n    // ─── 비용 산출 (cost_calculate) ───\n    if (analysis.intent === \"cost_calculate\") {\n        const targetEntityId = sessionContext?.last_entity_id;\n        if (!targetEntityId) {\n            return makeAnswerResponse(\n                \"노무비를 계산하려면 먼저 품셈을 검색해 주세요.\\n\\n\" +\n                \"예시: \\\"강관용접 200mm SCH 40\\\" 또는 \\\"TIG용접 품셈\\\"\",\n                startTime\n            );\n        }\n        console.log(`[handleChat] cost_calculate: entity=${targetEntityId} → 재귀 호출`);\n        return handleChat(question, history, targetEntityId, undefined, sessionContext, {\n            intent: \"cost_calculate\",\n            quantity: analysis.quantity || sessionContext?.last_quantity || undefined,\n        });\n    }\n\n    // ─── 변경 요청 (modify_request) ───\n    if (analysis.intent === \"modify_request\") {\n        if (analysis.modify_type === \"quantity\" && sessionContext?.last_entity_id) {\n            console.log(`[handleChat] modify_request(quantity=${analysis.quantity}): entity=${sessionContext.last_entity_id}`);\n            return handleChat(question, history, sessionContext.last_entity_id, undefined, sessionContext, {\n                intent: \"cost_calculate\",\n                quantity: analysis.quantity || undefined,\n                modifyType: \"quantity\",\n            });\n        }\n        if (analysis.modify_type === \"work_change\" && analysis.work_name) {\n            console.log(`[handleChat] modify_request(work_change): ${analysis.work_name}, spec=${sessionContext?.last_spec}`);\n            const modifiedAnalysis: IntentAnalysis = {\n                ...analysis,\n                intent: analysis.spec || sessionContext?.last_spec ? \"search\" : \"clarify_needed\",\n                spec: analysis.spec || sessionContext?.last_spec || null,\n            };\n            Object.assign(analysis, modifiedAnalysis);\n        }\n        if (analysis.modify_type === \"exclude_labor\" || (!analysis.modify_type && sessionContext?.last_entity_id)) {\n            return makeAnswerResponse(\n                \"직종 제외/수정 기능은 아직 준비 중입니다. 현재는 수량 변경과 공종 변경만 지원합니다.\\n\\n\" +\n                \"예시: \\\"50m로 바꿔서 다시\\\" 또는 \\\"TIG로 바꿔줘\\\"\",\n                startTime\n            );\n        }\n        if (!sessionContext?.last_entity_id && !analysis.work_name) {\n            return makeAnswerResponse(\n                \"변경할 이전 검색 결과가 없습니다. 먼저 품셈을 검색해 주세요.\",\n                startTime\n            );\n        }\n    }\n\n    // ─── 산출서 요청 (report_request) ───\n    if (analysis.intent === \"report_request\") {\n        const targetEntityId = sessionContext?.last_entity_id;\n        if (!targetEntityId) {\n            return makeAnswerResponse(\n                \"산출서를 만들려면 먼저 품셈을 검색해 주세요.\\n\\n\" +\n                \"예시: \\\"강관용접 200mm SCH 40\\\"\",\n                startTime\n            );\n        }\n        console.log(`[handleChat] report_request: entity=${targetEntityId} → 재귀 호출`);\n        return handleChat(question, history, targetEntityId, undefined, sessionContext, {\n            intent: \"report_request\",\n            quantity: sessionContext?.last_quantity || undefined,\n        });\n    }\n\n    // ─── 명확화 필요 → graphClarify ───\n    if (analysis.intent === \"clarify_needed\") {\n        const clarifyResult = await graphClarify(analysis);\n        return makeClarifyResponse(clarifyResult.message, startTime, {\n            options: clarifyResult.options,\n            reason: analysis.ambiguity_reason || \"질문의 범위가 넓어 구체적인 확인이 필요합니다\",\n            original_query: question,\n            selector: clarifyResult.selector,\n        });\n    }\n\n    // ═══ Route 4: search → searchPipeline ═══\n    return searchPipeline(analysis, question, history, startTime, answerOptions);\n}\n\n// ━━━ 서버 진입점 ━━━\n\nDeno.serve(async (req: Request) => {\n    const corsHeaders = getCorsHeaders(req);\n\n    // OPTIONS preflight\n    if (req.method === \"OPTIONS\") {\n        return new Response(null, { status: 204, headers: corsHeaders });\n    }\n\n    // POST만 허용\n    if (req.method !== \"POST\") {\n        return new Response(\n            JSON.stringify({ error: \"method_not_allowed\" }),\n            { status: 405, headers: { ...corsHeaders, \"Content-Type\": \"application/json\" } }\n        );\n    }\n\n    // (Codex F1) API Key 검증\n    if (RAG_API_KEY) {\n        const clientKey = req.headers.get(\"x-api-key\") || \"\";\n        if (clientKey !== RAG_API_KEY) {\n            return new Response(\n                JSON.stringify({ error: \"unauthorized\" }),\n                { status: 401, headers: { ...corsHeaders, \"Content-Type\": \"application/json\" } }\n            );\n        }\n    }\n\n    // (Codex F1) Rate Limiting\n    const clientIp =\n        req.headers.get(\"x-forwarded-for\")?.split(\",\")[0]?.trim() ||\n        req.headers.get(\"cf-connecting-ip\") ||\n        \"unknown\";\n    if (!checkRateLimit(clientIp)) {\n        return new Response(\n            JSON.stringify({ error: \"rate_limited\" }),\n            { status: 429, headers: { ...corsHeaders, \"Content-Type\": \"application/json\" } }\n        );\n    }\n\n    // Body 크기 제한 (10KB)\n    const contentLength = parseInt(req.headers.get(\"content-length\") || \"0\", 10);\n    if (contentLength > 10_240) {\n        return new Response(\n            JSON.stringify({ error: \"payload_too_large\" }),\n            { status: 413, headers: { ...corsHeaders, \"Content-Type\": \"application/json\" } }\n        );\n    }\n\n    try {\n        const body = (await req.json()) as ChatRequest;\n\n        // 입력 검증\n        if (!body.question || body.question.trim().length === 0) {\n            return new Response(\n                JSON.stringify({ error: \"question_required\" }),\n                { status: 400, headers: { ...corsHeaders, \"Content-Type\": \"application/json\" } }\n            );\n        }\n\n        // (Codex F5) 500자 초과 시 truncate (에러가 아닌 자동 절삭)\n        const question = body.question.trim().substring(0, 500);\n        const history = (body.history || []).slice(-5);\n\n        // RAG 파이프라인 실행\n        const entityId = body.entity_id || undefined;\n        const sectionId = body.section_id || undefined;\n        const sessionContext = body.session_context || undefined;\n        const result = await handleChat(question, history, entityId, sectionId, sessionContext);\n\n        return new Response(JSON.stringify(result), {\n            status: 200,\n            headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n        });\n    } catch (err) {\n        // 에러 종류별 분기\n        const errorMsg = err instanceof Error ? err.message : String(err);\n        console.error(\"rag-chat error:\", errorMsg);\n\n        // Gemini API 에러 → 502\n        if (errorMsg.includes(\"Embedding API failed\")) {\n            return new Response(\n                JSON.stringify({ error: \"embedding_failed\" }),\n                { status: 502, headers: { ...corsHeaders, \"Content-Type\": \"application/json\" } }\n            );\n        }\n        if (errorMsg.includes(\"LLM API failed\")) {\n            // (Codex 권장) LLM 실패 시 구조 응답 폴백\n            return new Response(\n                JSON.stringify({\n                    error: \"llm_failed\",\n                    message: \"LLM 답변 생성에 실패했습니다. 검색 결과만 반환합니다.\",\n                }),\n                { status: 502, headers: { ...corsHeaders, \"Content-Type\": \"application/json\" } }\n            );\n        }\n\n        // 기타 서버 에러\n        return new Response(\n            JSON.stringify({ error: \"internal_error\" }),\n            { status: 500, headers: { ...corsHeaders, \"Content-Type\": \"application/json\" } }\n        );\n    }\n});\n"}, {"name": "llm.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// llm.ts — LLM 답변 생성 (DeepSeek 우선, Gemini 폴백)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nimport { GEMINI_API_KEY, DEEPSEEK_API_KEY, DEEPSEEK_URL } from \"./config.ts\";\nimport type { ChatMessage, LLMResult, AnswerOptions } from \"./types.ts\";\n\nexport const SYSTEM_PROMPT = `당신은 건설 공사 품셈(標準品셈) 전문 AI 어시스턴트입니다.\n\n[역할]\n- 사용자의 건설 공사 관련 질문에 대해 품셈 데이터를 기반으로 정확하게 답변합니다.\n- 답변 시 반드시 제공된 컨텍스트의 데이터만 사용하며, 컨텍스트에 없는 정보는 추측하지 않습니다.\n\n[품셈 도메인 지식]\n1. **품셈서 구조**: 부문 > 장 > 절 > 표번호 형태. 표번호(예: 13-2-3)는 품셈서 내 고유 식별자입니다.\n2. **표 구조**: 각 표는 공종명 + 규격별 소테이블로 구성됩니다.\n   - 규격 예: \"강관용접(200, SCH 40)\" = 호칭경 200mm, 스케줄 40\n   - 각 규격 아래에 직종/수량/단위 테이블이 나옵니다.\n3. **코드 체계**: \"7205-0540\" 같은 숫자는 건설기계 분류 코드입니다.\n   - 앞 4자리: 대분류, 뒤 4자리: 세부 분류\n   - 이 코드로부터 장비명을 유추할 수 있습니다.\n4. **계수/보정값**: \"계수 A~E\" 등은 조건별 보정 계수입니다.\n   원본 테이블에서 조건에 맞는 행을 찾아 해당 계수를 적용합니다.\n5. **단위 체계**:\n   - \"인\" = 1인 1일 노동량 (8시간 기준). 0.122인 = 약 58분(0.122 × 8시간 × 60분)의 노동\n   - \"대\" = 장비 1대 1일(8시간) 가동\n   - \"㎡\", \"㎥\", \"m\", \"개소\", \"본\" 등은 시공 단위\n6. **속성(properties)**: 컨텍스트의 \"속성\" 필드에 규격, 수량, 단위 등 세부 정보가 포함됩니다.\n   이 데이터를 활용하여 정확한 수치를 답변하세요.\n\n[답변 규칙]\n1. **표번호 필수 표기**: 답변 시 해당 품셈의 표번호(예: [표 13-5-1])를 반드시 표기합니다. 표번호는 컨텍스트의 \"표번호\" 필드에서 가져옵니다.\n2. **출처 명시**: 답변에 사용한 품셈 항목의 출처(부문 > 장 > 절 > 표번호)를 반드시 표기합니다.\n3. **표 형식 — 컨텍스트 구조 유지**: 컨텍스트에 제공된 테이블 구조를 **있는 그대로** 유지하여 출력합니다.\n   - **매트릭스(교차표)**: 행=직종/장비/자재, 열=규격·조건일 때 교차 구조를 그대로 출력합니다. 절대 4열 플랫 테이블로 분해하지 않습니다.\n   - **심플 테이블**: 기준이 1개인 단순 데이터는 기존 \\`| 직종 | 수량 | 단위 | 기준 |\\` 구조를 유지합니다.\n   - 단위는 반드시 데이터에 표기된 값을 그대로 사용합니다. 임의 변경 금지.\n4. **수량 정확성**: 인력, 장비, 자재의 수량과 단위를 정확하게 표기합니다.\n   예: \"보통인부 0.122인\", \"콘크리트공 0.045인\"\n5. **비용 답변 시**: 일위대가 정보가 제공되면, 노무비/재료비/경비/합계를 표 형태로 정리합니다.\n6. **주의사항 포함**: 할증, 적용 조건, 제한 사항이 있으면 반드시 언급합니다.\n7. **같은 절(표) 내 데이터 활용**: 질문한 작업의 자체 인력/장비 데이터가 직접 없더라도,\n   컨텍스트에 같은 절(section)의 형제 작업 데이터가 포함되어 있다면\n   반드시 해당 데이터를 테이블로 출력합니다. 같은 절 내의 데이터는 동일 품셈표의 일부이므로 관련성이 있습니다.\n   \"데이터를 찾을 수 없습니다\"라고만 답하지 않습니다.\n8. **정보 부족 시**: 컨텍스트에 관련 데이터가 전혀 없는 경우에만 \"제공된 품셈 데이터에서 해당 정보를 찾을 수 없습니다\"라고 답합니다.\n   단, 같은 절의 형제 데이터가 있으면 그것을 먼저 출력한 후 \"질문하신 특정 항목의 별도 데이터는 포함되지 않았습니다\"라고 보충합니다.\n9. **마크다운 형식**: 답변은 마크다운 형식으로 작성하여 가독성을 높입니다.\n\n[출력 포맷 예시 — 매트릭스(교차표)]\n\n📋 **[표 13-2-3] 강관용접 — 전기아크용접** (개소당)\n📍 출처: 기계설비부문 > 제13장 플랜트설비공사 > 강관용접\n\n| 직종 | 200, SCH 20 | 200, SCH 30 | 200, SCH 40 | 200, SCH 60 | 200, SCH 80 |\n| --- | ---: | ---: | ---: | ---: | ---: |\n| 용접공 | 0.287 | 0.287 | — | — | — |\n| 플랜트용접공 | — | — | 0.287 | 0.325 | 0.362 |\n| 특별인부 | 0.086 | 0.086 | 0.086 | 0.098 | 0.109 |\n\n※ 매트릭스 테이블은 행에 직종/장비, 열에 규격·조건을 배치하여 한눈에 비교할 수 있게 구성합니다.\n※ 단위(개소당/m당/ton당 등)는 데이터에 포함된 값을 그대로 사용하세요.\n\n[금지 사항]\n- 컨텍스트에 없는 수치나 기준을 임의로 생성하지 않습니다.\n- \"일반적으로\", \"보통\", \"대략\" 등 모호한 표현 대신 정확한 수치를 사용합니다.\n- 건설 관련이 아닌 질문에는 \"건설 품셈 관련 질문에만 답변할 수 있습니다\"라고 응답합니다.\n- 단위를 임의로 바꾸지 않습니다. 주어지는 데이터를 그대로 씁니다.\n- 매트릭스 교차표를 4열 플랫 테이블(직종/수량/단위/기준)로 분해하지 않습니다. 컨텍스트 그대로 출력합니다.`;\n\n// Why: 임베딩은 DB 벡터 호환성 때문에 Gemini 유지 (13,387개 엔티티 재임베딩 불가)\n//       답변 생성만 DeepSeek v3.2로 전환\n\nexport async function generateAnswer(\n    question: string,\n    context: string,\n    history: ChatMessage[],\n    options?: AnswerOptions\n): Promise<LLMResult> {\n    // ─── intent별 프롬프트 동적 부착 ───\n    let systemContent = SYSTEM_PROMPT;\n\n    if (options?.intent === \"cost_calculate\") {\n        systemContent += `\\n\\n[특별 지침: 노무비 산출]\n사용자가 노무비 / 인건비 계산을 요청했습니다.\n1. 품셈 인력 데이터(직종, 수량, 단위)를 기반으로 노무비를 산출하세요.\n2. 수량이 ${options.quantity || '미지정'}${options.quantity ? ` (${options.quantity})` : ''}으로 주어졌습니다.\n3. 노무비 산출 형식(반드시 이 테이블 형태로):\n   | 직종 | 투입인원(인 / 개소) | 수량 | 총 투입(M / D) | 노임단가(원 / 일) | 소계(원) |\n    4. 컨텍스트에[2026년 노임단가] 섹선이 있으면 해당 단가를 사용하세요.\n5. 합계 행을 추가하고, 총 노무비를 굵은 글씨로 표기하세요.\n6. 수량이 미지정이면 \"1개소당\" 기준으로 산출하세요.`;\n    }\n\n    if (options?.intent === \"report_request\") {\n        systemContent += `\\n\\n[특별 지침: 산출서 형태 출력]\n사용자가 산출서 / 내역서를 요청했습니다.\n1. 정형화된 산출 내역서 형태로 출력하세요.\n2. 포함 항목: 품셈 출처(표번호, 절), 규격, 인력 투입 테이블, 노무비 산출 테이블, 합계\n3. 수량이 ${options.quantity || '미지정'}으로 주어졌습니다.\n4. 표번호, 출처 정보를 상단에 명시하세요.\n5. 최종 합계 금액을 강조 표시하세요.`;\n    }\n\n    if (options?.quantity && options.intent !== \"cost_calculate\" && options.intent !== \"report_request\") {\n        systemContent += `\\n\\n[수량 정보]\n사용자가 수량 ${options.quantity}을 지정했습니다.\n품셈 인력 / 장비 수량에 이 값을 곱하여 총 투입량을 계산해 주세요.`;\n    }\n\n    // ─── DeepSeek 우선 시도 ───\n    if (DEEPSEEK_API_KEY) {\n        try {\n            const messages = [\n                { role: \"system\" as const, content: systemContent },\n                ...history.slice(-5).map((msg) => ({\n                    role: msg.role === \"user\" ? \"user\" as const : \"assistant\" as const,\n                    content: msg.content,\n                })),\n                {\n                    role: \"user\" as const,\n                    content: `[질문]\\n${question} \\n\\n[참고 데이터]\\n${context} `,\n                },\n            ];\n\n            const response = await fetch(DEEPSEEK_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Authorization\": `Bearer ${DEEPSEEK_API_KEY} `,\n                },\n                body: JSON.stringify({\n                    model: \"deepseek-chat\",\n                    messages,\n                    temperature: 0.3,\n                    max_tokens: 4096,\n                }),\n            });\n\n            if (response.ok) {\n                const data = await response.json();\n                const answer = data.choices?.[0]?.message?.content ?? \"답변 생성에 실패했습니다.\";\n                const usage = data.usage || {};\n                return {\n                    answer,\n                    inputTokens: usage.prompt_tokens || 0,\n                    outputTokens: usage.completion_tokens || 0,\n                };\n            }\n            console.error(`[generateAnswer] DeepSeek failed: ${response.status}, falling back to Gemini`);\n        } catch (err) {\n            console.error(\"[generateAnswer] DeepSeek error:\", err, \"falling back to Gemini\");\n        }\n    }\n\n    // ─── Gemini 폴백 ───\n    const GEMINI_LLM_URL = \"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent\";\n    const contents = [\n        ...history.slice(-5).map((msg) => ({\n            role: msg.role === \"user\" ? \"user\" : \"model\",\n            parts: [{ text: msg.content }],\n        })),\n        {\n            role: \"user\",\n            parts: [{ text: `[질문]\\n${question} \\n\\n[참고 데이터]\\n${context} ` }],\n        },\n    ];\n\n    const response = await fetch(`${GEMINI_LLM_URL}?key = ${GEMINI_API_KEY} `, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n            system_instruction: { parts: [{ text: systemContent }] },\n            contents,\n            generationConfig: { temperature: 0.3, maxOutputTokens: 4096 },\n        }),\n    });\n\n    if (!response.ok) {\n        throw new Error(`LLM API failed: ${response.status} `);\n    }\n\n    const data = await response.json();\n    const answer = data.candidates?.[0]?.content?.parts?.[0]?.text ?? \"답변 생성에 실패했습니다.\";\n    const usage = data.usageMetadata || {};\n    return {\n        answer,\n        inputTokens: usage.promptTokenCount || 0,\n        outputTokens: usage.candidatesTokenCount || 0,\n    };\n}\n"}, {"name": "resolve.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// resolve.ts — 계층 탐색 + 명확화 프레젠테이션\n// Why: graphClarify의 656줄 모놀리식 함수를 책임 분리\n//   resolveSection : DB 탐색 → ResolveResult 반환\n//   presentClarify : ResolveResult → ClarifyResult UI 변환\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nimport { supabase } from \"./config.ts\";\nimport { chunkTextFallbackSearch, expandMixedTerms, expandDomainSynonyms } from \"./search.ts\";\nimport type {\n    IntentAnalysis, ClarifyOption, ClarifyResult,\n    SelectorPanel, SelectorItem, FilterAxis,\n} from \"./types.ts\";\n\n// ─── ResolveContext: 상태 보존 + 의존성 주입 ───\n// Why: 파라미터 파편화 방지. 향후 필터 조건 추가 시 함수 서명 변경 불필요\nexport interface ResolveContext {\n    analysis: IntentAnalysis;\n    sectionId?: string;\n    subSectionName?: string;       // sub_section 드릴다운 상태 보존\n    preMatchedSections?: any[];    // searchPipeline 벡터 검색 결과 주입 (DB 이중 쿼리 방지)\n}\n\n// ─── ChunkMeta: graph_chunks 메타데이터 ───\nexport interface ChunkMeta {\n    department: string;\n    chapter: string;\n    title: string;\n}\n\n// ─── ResolveResult: resolveSection의 출력 ───\nexport interface ResolveResult {\n    level: 'multi_section' | 'single_section' | 'sub_section' | 'worktype_many' | 'worktype_few' | 'empty';\n    sections: any[];\n    workTypes: any[];\n    subSections?: Map<string, any[]>;   // sub_section 그룹 (drill-down용)\n    chunkMeta: Map<string, ChunkMeta>;  // source_section → 부문/장/절\n    sectionPath?: string;               // 단일 섹션의 경로 문자열\n    sectionName?: string;               // 단일 섹션의 이름\n    primarySectionId?: string;          // 주 섹션 ID\n    chunkTextResults: any[];            // 전략 4 chunk text 결과\n    sectionSourceSections: Set<string>; // 전략 1에서 찾은 source_section 집합\n    childSections: any[];               // 하위 절 목록\n    subFilter?: string | null;          // sub_section 필터\n}\n\n// ═══════════════════════════════════════════════════════\n// ─── 헬퍼: # 접미사 제거 ───\n// ═══════════════════════════════════════════════════════\nfunction displayCode(code: string | null | undefined): string {\n    return code ? code.replace(/#.*$/, '') : '';\n}\n\n// ─── 범용 동사 목록 (전략 3 독립검색에서 제외) ───\nconst ACTION_VERBS = new Set([\n    \"제작\", \"설치\", \"시공\", \"공사\", \"운반\", \"보수\", \"해체\", \"조립\",\n    \"철거\", \"가공\", \"타설\", \"양생\", \"포설\", \"다짐\", \"절단\", \"용접\",\n    \"도장\", \"배관\", \"배선\", \"측량\", \"검사\", \"인양\", \"적재\",\n]);\n\n// ═══════════════════════════════════════════════════════\n// resolveSection: DB 탐색 → 계층 판정 → ResolveResult\n// ═══════════════════════════════════════════════════════\nexport async function resolveSection(ctx: ResolveContext): Promise<ResolveResult> {\n    const { analysis, sectionId, subSectionName, preMatchedSections } = ctx;\n    const { work_name, keywords } = analysis;\n    let searchTerms = work_name ? [work_name, ...keywords] : keywords;\n\n    // ─── searchTerms[0] 정규화 ───\n    if (searchTerms.length > 0 && searchTerms[0].length > 0) {\n        const raw = searchTerms[0];\n        const koreanTokens = [...new Set(raw.match(/[가-힣]{2,}/g) || [])];\n        if (koreanTokens.length > 0) {\n            searchTerms[0] = koreanTokens.join('');\n        }\n        if (searchTerms[0].length > 15 || !/[가-힣]/.test(searchTerms[0])) {\n            const originalQuery = analysis.ambiguity_reason || work_name || '';\n            const fallbackTokens = [...new Set(originalQuery.match(/[가-힣]{2,}/g) || [])];\n            if (fallbackTokens.length > 0) searchTerms[0] = fallbackTokens.join('');\n        }\n        console.log(`[resolveSection] searchTerms 정규화: \"${raw}\" → \"${searchTerms[0]}\"`);\n    }\n\n    if (searchTerms.length === 0) {\n        return emptyResult();\n    }\n\n    // ═══ sectionId 경로: 해당 섹션 내 탐색 ═══\n    if (sectionId) {\n        return await resolveBySectionId(sectionId, subSectionName, searchTerms);\n    }\n\n    // ═══ 검색 경로: 4전략 실행 ═══\n    return await resolveBySearch(analysis, searchTerms, keywords, work_name, preMatchedSections);\n}\n\n// ─── sectionId 기반 탐색 (기존 Step 2) ───\nasync function resolveBySectionId(\n    sectionId: string,\n    subSectionName?: string,\n    searchTerms: string[] = []\n): Promise<ResolveResult> {\n    // sub_section 필터 추출: \"13-2-3:sub=2. TIG용접\" → sectionId=13-2-3, subFilter=\"2. TIG용접\"\n    let actualSectionId = sectionId;\n    let subFilter: string | null = subSectionName || null;\n    if (sectionId.includes(':sub=')) {\n        const parts = sectionId.split(':sub=');\n        actualSectionId = parts[0];\n        subFilter = decodeURIComponent(parts[1]);\n    }\n\n    console.log(`[resolveSection] sectionId=${actualSectionId}, subFilter=${subFilter}`);\n\n    // graph_chunks 메타데이터 조회\n    const { data: chunkData } = await supabase\n        .from(\"graph_chunks\")\n        .select(\"section_id, department, chapter, title, text\")\n        .eq(\"section_id\", actualSectionId)\n        .limit(1);\n\n    const chunk = (chunkData as any[])?.[0];\n    const sectionPath = chunk\n        ? `${chunk.department} > ${chunk.chapter} > ${chunk.title}`\n        : actualSectionId;\n    const chunkMeta = new Map<string, ChunkMeta>();\n    if (chunk) {\n        chunkMeta.set(actualSectionId, {\n            department: chunk.department || \"\",\n            chapter: chunk.chapter || \"\",\n            title: chunk.title || \"\",\n        });\n    }\n\n    // 하위 WorkType 조회\n    const { data: exactWTs } = await supabase\n        .from(\"graph_entities\")\n        .select(\"id, name, type, source_section, properties\")\n        .eq(\"type\", \"WorkType\")\n        .eq(\"source_section\", actualSectionId)\n        .limit(200);\n\n    let workTypes = (exactWTs || []) as any[];\n    console.log(`[resolveSection] exact=${workTypes.length}개 WorkType`);\n\n    // sub_section drill-down 판정\n    let subSections: Map<string, any[]> | undefined;\n    if (workTypes.length > 0 && !subFilter) {\n        const subMap = buildSubSectionMap(workTypes);\n        if (subMap.size >= 2) {\n            subSections = subMap;\n            return {\n                level: 'sub_section',\n                sections: [],\n                workTypes,\n                subSections,\n                chunkMeta,\n                sectionPath,\n                sectionName: chunk?.title || actualSectionId,\n                primarySectionId: actualSectionId,\n                chunkTextResults: [],\n                sectionSourceSections: new Set([actualSectionId]),\n                childSections: [],\n                subFilter: null,\n            };\n        }\n    }\n\n    // sub_section 필터 적용\n    if (subFilter && workTypes.length > 0) {\n        const beforeCount = workTypes.length;\n        workTypes = workTypes.filter((wt: any) => wt.properties?.sub_section === subFilter);\n        console.log(`[resolveSection] subFilter=\"${subFilter}\" → ${beforeCount} → ${workTypes.length}개`);\n    }\n\n    // WT 0건 → 하위 절(children) 탐색\n    let childSections: any[] = [];\n    if (workTypes.length === 0 && !subFilter) {\n        const baseSectionId = actualSectionId.includes('#') ? actualSectionId.split('#')[0] : actualSectionId;\n        const childPrefix = baseSectionId + '-';\n        const dept = chunk?.department || '';\n\n        console.log(`[resolveSection] WT 0건 → 하위 절 탐색 (prefix=${childPrefix})`);\n\n        const { data: childChunks } = await supabase\n            .from(\"graph_chunks\")\n            .select(\"section_id, title, department\")\n            .ilike(\"section_id\", `${childPrefix}%`)\n            .eq(\"department\", dept);\n\n        const uniqueChildren = new Map<string, any>();\n        (childChunks || []).forEach((c: any) => {\n            if (!uniqueChildren.has(c.section_id)) {\n                uniqueChildren.set(c.section_id, c);\n            }\n        });\n        childSections = Array.from(uniqueChildren.values());\n\n        if (childSections.length > 0) {\n            const childSectionIds = childSections.map(c => c.section_id);\n            const { data: childWTs } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, source_section, properties\")\n                .eq(\"type\", \"WorkType\")\n                .in(\"source_section\", childSectionIds)\n                .limit(50);\n            workTypes = (childWTs || []) as any[];\n        }\n    }\n\n    // 이름 정규화 기준 중복 제거 (클린 DB로 인해 삭제됨)\n\n    // WT 0건: Note 수 조회하여 level 판정\n    if (workTypes.length === 0 && childSections.length === 0) {\n        const { count: noteCount } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id\", { count: \"exact\", head: true })\n            .eq(\"type\", \"Note\")\n            .eq(\"source_section\", actualSectionId);\n\n        // empty이지만 note가 있을 수 있으므로 workTypes에 noteCount 정보를 meta로 전달\n        return {\n            level: 'empty',\n            sections: [],\n            workTypes: [],\n            chunkMeta,\n            sectionPath,\n            sectionName: chunk?.title || actualSectionId,\n            primarySectionId: actualSectionId,\n            chunkTextResults: [],\n            sectionSourceSections: new Set([actualSectionId]),\n            childSections: [],\n            subFilter,\n            // noteCount를 sections 필드로 전달 (임시)\n            ...(noteCount ? { sections: [{ _noteCount: noteCount }] } : {}),\n        };\n    }\n\n    const level = workTypes.length > 3 ? 'worktype_many' : 'worktype_few';\n\n    return {\n        level,\n        sections: [],\n        workTypes,\n        chunkMeta,\n        sectionPath,\n        sectionName: chunk?.title || actualSectionId,\n        primarySectionId: actualSectionId,\n        chunkTextResults: [],\n        sectionSourceSections: new Set([actualSectionId]),\n        childSections,\n        subFilter,\n    };\n}\n\n// ─── 검색 전략 기반 탐색 (기존 Step 1) ───\nasync function resolveBySearch(\n    analysis: IntentAnalysis,\n    searchTerms: string[],\n    keywords: string[],\n    work_name: string | null,\n    preMatchedSections?: any[]\n): Promise<ResolveResult> {\n    const sectionSourceSections = new Set<string>();\n\n    // ─── 전략 1: Section 레벨 탐색 ───\n    let effectiveSections: any[] = [];\n\n    if (preMatchedSections && preMatchedSections.length > 0) {\n        // ✅ preMatchedSections 주입됨 → DB 이중 쿼리 방지\n        effectiveSections = preMatchedSections;\n        console.log(`[resolveSection] 전략 1: preMatched ${effectiveSections.length}개 사용`);\n    } else {\n        // 전략 1-A: Section 이름 ILIKE (+ 도메인 동의어)\n        const sectionPattern = \"%\" + searchTerms[0] + \"%\";\n        // 💡 [Track B-1] 도메인 동의어로 Section 검색 확장 (raw work_name 사용)\n        const synonymSrc1A = work_name ? [work_name, searchTerms[0]] : [searchTerms[0]];\n        const sectionSynonyms = expandDomainSynonyms([...new Set(synonymSrc1A)]);\n        const sectionOrClauses = [\n            `name.ilike.${sectionPattern}`,\n            ...sectionSynonyms.map(s => `name.ilike.%${s}%`),\n        ].join(\",\");\n        const { data: sections } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id, name, type, source_section, properties\")\n            .eq(\"type\", \"Section\")\n            .or(sectionOrClauses)\n            .limit(10);\n\n        // 전략 1-B: 토큰 분리 ILIKE 폴백\n        let tokenFallbackSections: any[] = [];\n        if ((!sections || sections.length === 0) && searchTerms[0].length >= 4) {\n            let tokens = searchTerms[0].match(/[가-힣]{2,}|[a-zA-Z]+/g) || [];\n            if (tokens.length === 1 && tokens[0].length >= 4) {\n                const word = tokens[0];\n                const halfLen = Math.ceil(word.length / 2);\n                tokens = [word.substring(0, halfLen), word.substring(halfLen)];\n            }\n            if (tokens.length >= 2) {\n                let query = supabase.from(\"graph_entities\")\n                    .select(\"id, name, type, source_section, properties\")\n                    .eq(\"type\", \"Section\");\n                for (const token of tokens) {\n                    query = query.ilike(\"name\", `%${token}%`);\n                }\n                const { data: tokenSections } = await query.limit(10);\n                if (tokenSections) tokenFallbackSections = tokenSections;\n                console.log(`[resolveSection] 전략 1-B: \"${tokens.join('\",\"')}\" → ${tokenFallbackSections.length}건`);\n            }\n        }\n        effectiveSections = (sections && sections.length > 0) ? sections : tokenFallbackSections;\n    }\n\n    // Section의 source_section으로 하위 WorkType 조회\n    let sectionChildWorkTypes: any[] = [];\n    if (effectiveSections.length > 0) {\n        const sourceSections = effectiveSections.map((s: any) => s.source_section).filter(Boolean);\n        sourceSections.forEach((ss: string) => sectionSourceSections.add(ss));\n        if (sourceSections.length > 0) {\n            const { data: childWTs } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, source_section, properties\")\n                .eq(\"type\", \"WorkType\")\n                .in(\"source_section\", sourceSections)\n                .limit(200);\n            if (childWTs) sectionChildWorkTypes = childWTs;\n            console.log(`[resolveSection] Section ${sourceSections.join(\",\")} 하위 WorkType ${childWTs?.length || 0}개`);\n        }\n    }\n\n    // 전략 2: WorkType 직접 탐색\n    const safeWorkTerms = searchTerms.filter((t: string) => {\n        const isAllEng = /^[A-Za-z]+$/.test(t);\n        return t.length >= 2 && (!isAllEng || t.length >= 4);\n    });\n    const wTerms = safeWorkTerms.length > 0 ? safeWorkTerms : searchTerms.filter((t: string) => t.length >= 2);\n    // Why: \"PE관\" → \"%PE관%\" 매칭 실패 대비, 영한 혼합어 완화 패턴(\"%PE%관%\")도 추가\n    const mixedExp = expandMixedTerms(wTerms);\n    // 💡 [Track B-1] 도메인 동의어로 WorkType 검색 확장\n    // Why: searchTerms[0]이 한글 정규화(\"PE관\"→\"관\")되어 원본이 사라질 수 있으므로\n    //      raw work_name도 동의어 확장 소스에 포함\n    const synonymSource = work_name ? [...new Set([work_name, ...wTerms])] : wTerms;\n    const domainExp = expandDomainSynonyms(synonymSource);\n    console.log(`[resolveSection] 전략 2: wTerms=${JSON.stringify(wTerms)}, synonymSource=${JSON.stringify(synonymSource)}, domainExp=${JSON.stringify(domainExp)}`);\n    const workOrClauses = [\n        ...wTerms.map((t: string) => `name.ilike.%${t}%`),\n        ...mixedExp.map(p => `name.ilike.${p}`),\n        ...domainExp.map(s => `name.ilike.%${s}%`),\n    ].join(\",\");\n    const { data: workTypes } = await supabase\n        .from(\"graph_entities\")\n        .select(\"id, name, type, source_section, properties\")\n        .eq(\"type\", \"WorkType\")\n        .or(workOrClauses)\n        .limit(200);\n\n    // 전략 3: 키워드별 독립 검색 (범용 동사 제외)\n    let extraWorkTypes: any[] = [];\n    for (const kw of keywords) {\n        if (kw.length >= 2 && !ACTION_VERBS.has(kw)) {\n            const { data: kwResults } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, source_section, properties\")\n                .in(\"type\", [\"WorkType\", \"Section\"])\n                .or(`name.ilike.%${kw}%,properties->>korean_alias.ilike.%${kw}%`)\n                .limit(10);\n            if (kwResults) extraWorkTypes = extraWorkTypes.concat(kwResults);\n        }\n    }\n\n    // 전략 4: chunk 본문 텍스트 검색\n    let chunkTextResults: any[] = [];\n    const prelimResults = [...effectiveSections, ...sectionChildWorkTypes, ...(workTypes || []), ...extraWorkTypes];\n    const kwTokens = keywords.length > 0\n        ? keywords\n        : (work_name ? work_name.split(/\\s+/).filter((w: string) => w.length >= 2) : []);\n    const compoundTerms: string[] = [];\n    for (let i = 0; i < kwTokens.length - 1; i++) {\n        compoundTerms.push(kwTokens[i] + kwTokens[i + 1]);\n    }\n    if (kwTokens.length >= 2) {\n        compoundTerms.push(kwTokens.join(''));\n    }\n    const compoundMatchFound = compoundTerms.length > 0 && prelimResults.some(\n        (r: any) => compoundTerms.some(ct => r.name && r.name.includes(ct))\n    );\n\n    if (compoundTerms.length > 0 && !compoundMatchFound) {\n        console.log(`[resolveSection] 전략 4: chunk text fallback (복합어 \"${compoundTerms.join(',')}\" 미매칭)`);\n        const chunkQuestion = searchTerms.join(' ');\n        const chunkFallback = await chunkTextFallbackSearch(chunkQuestion);\n        if (chunkFallback.length > 0) {\n            chunkTextResults = chunkFallback.map(e => ({\n                id: e.id, name: e.name, type: e.type,\n                source_section: e.source_section,\n                properties: e.properties,\n            }));\n        }\n    }\n\n    // ─── 결과 병합 + 중복 제거 ───\n    const allResults = [...effectiveSections, ...sectionChildWorkTypes, ...(workTypes || []), ...extraWorkTypes, ...chunkTextResults];\n    const uniqueResults = Array.from(\n        new Map(allResults.map(r => [r.id, r])).values()\n    );\n\n    if (uniqueResults.length === 0) {\n        return emptyResult();\n    }\n\n    // ─── graph_chunks 메타데이터 조회 ───\n    const allSourceSections = [...new Set(uniqueResults.map(r => r.source_section).filter(Boolean))];\n    const chunkMeta = new Map<string, ChunkMeta>();\n    if (allSourceSections.length > 0) {\n        const { data: chunks } = await supabase\n            .from(\"graph_chunks\")\n            .select(\"section_id, department, chapter, title\")\n            .in(\"section_id\", allSourceSections);\n        if (chunks) {\n            for (const c of chunks as any[]) {\n                chunkMeta.set(c.section_id, {\n                    department: c.department || \"\",\n                    chapter: c.chapter || \"\",\n                    title: c.title || \"\",\n                });\n            }\n        }\n    }\n\n    // ─── 관련성 점수 산출 ───\n    const scoredResults = uniqueResults.map(r => {\n        let score = 0;\n        const name = r.name || \"\";\n        const nameLC = name.toLowerCase();\n\n        if (r.type === \"WorkType\" && sectionSourceSections.has(r.source_section)) score += 50;\n        if (work_name && nameLC.includes(work_name.toLowerCase())) score += 30;\n        for (const kw of keywords) {\n            if (nameLC.includes(kw.toLowerCase())) score += 10;\n        }\n        if (r.type === \"Section\") score -= 5;\n\n        return { ...r, _score: score };\n    });\n    scoredResults.sort((a, b) => b._score - a._score);\n\n    console.log(`[resolveSection] 관련성 상위:`,\n        scoredResults.slice(0, 5).map(r => `${r.name}(${r._score})`).join(\", \"));\n\n    // ─── 계층 판정 ───\n    const matchedSections = scoredResults.filter(r => r.type === \"Section\");\n    const matchedWorkTypes = scoredResults.filter(r => r.type === \"WorkType\");\n\n    // Phase 3-C: chunk text fallback WorkType 우선\n    const chunkWorkTypes = chunkTextResults.filter((r: any) => r.type === 'WorkType');\n    if (chunkWorkTypes.length > 0) {\n        // sub_section drill-down 시도\n        const allWTsForDrill = sectionChildWorkTypes.length > 0 ? sectionChildWorkTypes : chunkWorkTypes;\n        const drillSectionId = matchedSections[0]?.source_section || chunkWorkTypes[0]?.source_section || '';\n        const subMap = buildSubSectionMap(allWTsForDrill);\n\n        const drillSectionName = matchedSections[0]?.name || work_name || searchTerms[0];\n        const drillMeta = drillSectionId ? chunkMeta.get(drillSectionId) : null;\n        const drillSectionPath = drillMeta\n            ? `${drillMeta.department} > ${drillMeta.chapter} > ${drillMeta.title}`\n            : drillSectionName;\n\n        if (subMap.size >= 2) {\n            return {\n                level: 'sub_section',\n                sections: matchedSections,\n                workTypes: allWTsForDrill,\n                subSections: subMap,\n                chunkMeta,\n                sectionPath: drillSectionPath,\n                sectionName: drillSectionName,\n                primarySectionId: drillSectionId,\n                chunkTextResults,\n                sectionSourceSections,\n                childSections: [],\n            };\n        }\n\n        // sub_section 없으면 chunk WorkType을 그대로 반환\n        return {\n            level: 'worktype_few',\n            sections: matchedSections,\n            workTypes: chunkWorkTypes,\n            chunkMeta,\n            sectionPath: drillSectionPath,\n            sectionName: drillSectionName,\n            primarySectionId: drillSectionId,\n            chunkTextResults,\n            sectionSourceSections,\n            childSections: [],\n        };\n    }\n\n    // 복수 섹션 판정 (💡 [Track B-1] WorkType의 source_section도 고려)\n    const sectionOnlyIds = [...new Set(matchedSections.map(s => s.source_section).filter(Boolean))];\n    const workTypeOnlyIds = [...new Set(matchedWorkTypes.map(w => w.source_section).filter(Boolean))];\n    const allUniqueSectionIds = [...new Set([...sectionOnlyIds, ...workTypeOnlyIds])];\n    if (allUniqueSectionIds.length > 1) {\n        return {\n            level: 'multi_section',\n            sections: matchedSections,\n            workTypes: matchedWorkTypes,\n            chunkMeta,\n            chunkTextResults,\n            sectionSourceSections,\n            childSections: [],\n        };\n    }\n\n    // 단일 섹션 + WorkType 많음\n    if (matchedWorkTypes.length > 3) {\n        const sectionNameA = matchedSections[0]?.name || work_name || searchTerms[0];\n        const sectionMetaA = matchedSections[0] ? chunkMeta.get(matchedSections[0].source_section) : null;\n        const fullSectionPathA = sectionMetaA\n            ? `${sectionMetaA.department} > ${sectionMetaA.chapter} > ${sectionMetaA.title}`\n            : sectionNameA;\n        const primarySectionIdA = matchedSections[0]?.source_section || matchedWorkTypes[0]?.source_section || '';\n\n        // sub_section drill-down 시도\n        const subMap = buildSubSectionMap(matchedWorkTypes);\n        if (subMap.size >= 2) {\n            return {\n                level: 'sub_section',\n                sections: matchedSections,\n                workTypes: matchedWorkTypes,\n                subSections: subMap,\n                chunkMeta,\n                sectionPath: fullSectionPathA,\n                sectionName: sectionNameA,\n                primarySectionId: primarySectionIdA,\n                chunkTextResults,\n                sectionSourceSections,\n                childSections: [],\n            };\n        }\n\n        return {\n            level: 'worktype_many',\n            sections: matchedSections,\n            workTypes: matchedWorkTypes,\n            chunkMeta,\n            sectionPath: fullSectionPathA,\n            sectionName: sectionNameA,\n            primarySectionId: primarySectionIdA,\n            chunkTextResults,\n            sectionSourceSections,\n            childSections: [],\n        };\n    }\n\n    // Section 1개 + WorkType 소수\n    if (matchedSections.length === 1 && matchedWorkTypes.length > 0) {\n        const section = matchedSections[0];\n        const meta = chunkMeta.get(section.source_section);\n        const sectionPath = meta\n            ? `${meta.department} > ${meta.chapter} > ${meta.title}`\n            : section.name;\n\n        return {\n            level: 'worktype_few',\n            sections: matchedSections,\n            workTypes: matchedWorkTypes,\n            chunkMeta,\n            sectionPath,\n            sectionName: section.name,\n            primarySectionId: section.source_section || matchedWorkTypes[0]?.source_section || '',\n            chunkTextResults,\n            sectionSourceSections,\n            childSections: [],\n        };\n    }\n\n    // 소수 결과 (Section + WorkType 혼합)\n    return {\n        level: 'worktype_few',\n        sections: matchedSections,\n        workTypes: scoredResults, // 전체 scored 결과\n        chunkMeta,\n        chunkTextResults,\n        sectionSourceSections,\n        childSections: [],\n    };\n}\n\n// ═══════════════════════════════════════════════════════\n// presentClarify: ResolveResult → ClarifyResult (UI 변환)\n// ═══════════════════════════════════════════════════════\nexport function presentClarify(\n    resolved: ResolveResult,\n    searchTerms: string[],\n    workName: string | null\n): ClarifyResult {\n    const { level, sections, workTypes, subSections, chunkMeta,\n        sectionPath, sectionName, primarySectionId,\n        childSections, subFilter } = resolved;\n\n    // ─── label 생성 헬퍼 ───\n    const makeLabel = (r: any): string => {\n        const meta = chunkMeta.get(r.source_section);\n        if (meta && meta.department) {\n            const dept = meta.department.replace(/부문$/, \"\");\n            const secTag = r.source_section ? ` (${displayCode(r.source_section)})` : \"\";\n            return `[${dept}${secTag}] ${r.name}`;\n        }\n        const sectionTag = r.source_section ? `[${displayCode(r.source_section)}]` : \"\";\n        return `${sectionTag} ${r.name}`;\n    };\n\n    // ─── empty ───\n    if (level === 'empty') {\n        const noteCount = sections[0]?._noteCount || 0;\n        const options: ClarifyOption[] = [{\n            label: `📋 ${sectionName || primarySectionId} 전체 내용 보기`,\n            query: `${sectionName || primarySectionId} 전체 품셈`,\n            section_id: primarySectionId,\n            option_type: \"full_view\",\n        }];\n\n        const message = noteCount > 0\n            ? `**${sectionPath}** 품셈은 개별 작업이 분류되어 있지 않고, **기준 및 주의사항 ${noteCount}건**을 포함하고 있습니다.\\n아래 \"전체 내용 보기\"를 통해 확인해 주세요.`\n            : `**${sectionPath}** 품셈의 상세 작업이 개별 등록되어 있지 않습니다.\\n아래 \"전체 내용 보기\" 버튼으로 해당 절의 품셈 데이터를 확인해 주세요.`;\n\n        return { message, options };\n    }\n\n    // ─── sub_section drill-down ───\n    if (level === 'sub_section' && subSections) {\n        const options: ClarifyOption[] = [];\n        const prefix = sectionName || workName || searchTerms[0];\n\n        options.push({\n            label: `📋 ${sectionName || primarySectionId} 전체 내용 보기`,\n            query: `${prefix} 전체 품셈`,\n            section_id: primarySectionId,\n            option_type: \"full_view\",\n        });\n\n        // sub_section별 옵션 (sub_section_no 순 정렬)\n        const sorted = [...subSections.entries()].sort((a, b) => {\n            const noA = a[1][0]?.properties?.sub_section_no || 99;\n            const noB = b[1][0]?.properties?.sub_section_no || 99;\n            return Number(noA) - Number(noB);\n        });\n\n        for (const [subName, subWTs] of sorted) {\n            options.push({\n                label: `📂 ${subName} (${subWTs.length}건)`,\n                query: `${prefix} ${subName} 품셈`,\n                section_id: `${primarySectionId}:sub=${encodeURIComponent(subName)}`,\n                option_type: \"section\" as any,\n            });\n        }\n\n        return {\n            message: `**${sectionPath}** 품셈에는 ${subSections.size}개 분류(총 ${workTypes.length}개 작업)가 있습니다.\\n분류를 선택해 주세요.`,\n            options,\n        };\n    }\n\n    // ─── multi_section ───\n    if (level === 'multi_section') {\n        // 💡 [Track B-1] Section 엔티티 + WorkType의 source_section 병합\n        const sectionSrcSet = new Set(sections.map(s => s.source_section).filter(Boolean));\n        const options: ClarifyOption[] = sections.slice(0, 10).map(s => {\n            const meta = chunkMeta.get(s.source_section);\n            const secTag = s.source_section ? ` (${displayCode(s.source_section)})` : \"\";\n            const label = meta\n                ? `${meta.department} > ${meta.chapter} > ${meta.title}${secTag}`\n                : `[${displayCode(s.source_section)}] ${s.name}`;\n            return {\n                label,\n                query: `${s.name} 품셈`,\n                source_section: s.source_section,\n                section_id: s.source_section,\n                option_type: 'section' as const,\n            };\n        });\n\n        // WorkType의 source_section 중 Section에 없는 것들도 option으로 추가\n        const wtBySrc = new Map<string, any>();\n        for (const wt of workTypes) {\n            if (wt.source_section && !sectionSrcSet.has(wt.source_section) && !wtBySrc.has(wt.source_section)) {\n                wtBySrc.set(wt.source_section, wt);\n            }\n        }\n        for (const [srcSec, wt] of wtBySrc) {\n            const meta = chunkMeta.get(srcSec);\n            const secTag = ` (${displayCode(srcSec)})`;\n            const label = meta\n                ? `${meta.department} > ${meta.chapter} > ${meta.title}${secTag}`\n                : `[${displayCode(srcSec)}] ${wt.name}`;\n            options.push({\n                label,\n                query: `${meta?.title || wt.name} 품셈`,\n                source_section: srcSec,\n                section_id: srcSec,\n                option_type: 'section' as const,\n            });\n        }\n\n        const allUniqueIds = [...new Set([...sections.map(s => s.source_section), ...workTypes.map(w => w.source_section)].filter(Boolean))];\n        const selector = buildSelectorPanel(options, searchTerms[0]);\n        return {\n            message: `\"${searchTerms.join(\" \")}\" 관련 품셈이 **${allUniqueIds.length}개 분야**에 있습니다.\\n어떤 분야의 품셈을 찾으시나요?`,\n            options,\n            selector,\n        };\n    }\n\n    // ─── sectionId 경로: worktype_many / worktype_few ───\n    if (primarySectionId && childSections.length >= 0) {\n        const options: ClarifyOption[] = [];\n\n        // \"전체 내용 보기\" 옵션\n        if (primarySectionId) {\n            options.push({\n                label: `📋 ${sectionName || primarySectionId}${subFilter ? ` > ${subFilter}` : ''} 전체 내용 보기`,\n                query: `${sectionName || primarySectionId} 전체 품셈`,\n                section_id: primarySectionId,\n                option_type: \"full_view\",\n            });\n        }\n\n        if (childSections.length > 0 && workTypes.length > 10) {\n            // 하위 절 단위 옵션\n            for (const child of childSections) {\n                options.push({\n                    label: `📂 ${child.title}`,\n                    query: `${child.title} 품셈`,\n                    section_id: child.section_id,\n                    option_type: \"section\" as any,\n                });\n            }\n        } else {\n            // 개별 WorkType 옵션\n            for (const wt of workTypes) {\n                if (options.find(o => o.entity_id === wt.id)) continue;\n                options.push({\n                    label: (level === 'worktype_many' || !sections.length) ? makeLabel(wt) : wt.name,\n                    query: `${wt.name} 품셈`,\n                    entity_id: wt.id,\n                    source_section: wt.source_section,\n                    option_type: (wt.type === 'Section' ? 'section' : 'worktype') as 'section' | 'worktype',\n                    ...(wt.type === 'Section' ? { section_id: wt.source_section } : {}),\n                });\n            }\n        }\n\n        // 메시지 분기\n        let message: string;\n        if (subFilter) {\n            message = `**${sectionPath} > ${subFilter}** 품셈은 ${workTypes.length}개 작업으로 분류되어 있습니다.\\n어떤 작업의 품셈을 찾으시나요?`;\n        } else if (level === 'worktype_many') {\n            message = `**${sectionPath || sectionName}** 품셈은 ${workTypes.length}개 작업으로 분류되어 있습니다.\\n어떤 작업의 품셈을 찾으시나요?`;\n        } else if (sections.length === 1 && workTypes.length > 0) {\n            message = `**${sectionPath || sectionName}** 하위 ${workTypes.length}개 작업이 있습니다.\\n어떤 작업의 품셈을 찾으시나요?`;\n        } else if (workTypes.length > 0) {\n            message = `다음 중 찾으시는 항목이 있나요?`;\n        } else {\n            message = `\"${searchTerms.join(\" \")}\"와 관련된 품셈 항목을 찾지 못했습니다.\\n정확한 공종명을 입력해 주세요.`;\n        }\n\n        const selector = buildSelectorPanel(options, workName || searchTerms[0]);\n        return {\n            message,\n            options,\n            ...(selector ? { selector } : {}),\n        };\n    }\n\n    // ─── 최종 폴백 ───\n    return {\n        message: `\"${searchTerms.join(\" \")}\"와 관련된 품셈 항목을 찾지 못했습니다.\\n정확한 공종명을 입력해 주세요.`,\n        options: [],\n    };\n}\n\n// ═══════════════════════════════════════════════════════\n// 유틸리티 함수\n// ═══════════════════════════════════════════════════════\n\nfunction emptyResult(): ResolveResult {\n    return {\n        level: 'empty',\n        sections: [],\n        workTypes: [],\n        chunkMeta: new Map(),\n        chunkTextResults: [],\n        sectionSourceSections: new Set(),\n        childSections: [],\n    };\n}\n\n// sub_section별 그룹 생성\nfunction buildSubSectionMap(workTypes: any[]): Map<string, any[]> {\n    const subMap = new Map<string, any[]>();\n    for (const wt of workTypes) {\n        const sub = wt.properties?.sub_section || null;\n        if (sub) {\n            if (!subMap.has(sub)) subMap.set(sub, []);\n            subMap.get(sub)!.push(wt);\n        }\n    }\n    return subMap;\n}\n\n\n// ─── Selector Panel 관련 함수 (clarify.ts에서 이동) ───\n\nfunction parseWorkTypeName(name: string): Record<string, string> {\n    // 1. 강관 (옥외 용접식) 형식을 식별 (ComplexTablePipeline 용)\n    const mComplex = name.match(/^([^()]+)\\s*\\(([^)\\s]+)\\s+([^)\\s]+)\\)$/);\n    if (mComplex) {\n        return {\n            '재질': mComplex[1].trim(),\n            '배관장소': mComplex[2].trim(),\n            '접합방식': mComplex[3].trim()\n        };\n    }\n\n    // 2. (XX, SCH YY) 형식 식별\n    const m = name.match(/\\((\\d+),\\s*SCH\\s*([\\d~]+)\\)$/);\n    if (m) return { diameter: m[1], sch: m[2] };\n\n    // 3. (A, B) 형식\n    const m2 = name.match(/\\(([^,]+),\\s*(.+)\\)$/);\n    if (m2) return { spec1: m2[1].trim(), spec2: m2[2].trim() };\n\n    // 4. (A) 단일 형식\n    const m3 = name.match(/\\(([^)]+)\\)$/);\n    if (m3) {\n        const val = m3[1].trim();\n        // Ignore section IDs like 1-2-4 or 1-2\n        if (!/^(\\d+-)+\\d+(#\\d+)?$/.test(val)) {\n            return { spec1: val };\n        }\n    }\n\n    // 5. 언더스코어(_) 로 구분된 서브타입\n    const parts = name.split('_');\n    if (parts.length >= 2) return { subtype: parts.slice(1).join('_') };\n\n    return {};\n}\n\nfunction extractFilterAxes(items: SelectorItem[]): FilterAxis[] {\n    const axisMap = new Map<string, Set<string>>();\n    for (const item of items) {\n        for (const [key, val] of Object.entries(item.specs)) {\n            if (!axisMap.has(key)) axisMap.set(key, new Set());\n            axisMap.get(key)!.add(val);\n        }\n    }\n\n    function extractNumber(s: string): number {\n        const m = s.match(/[\\d.]+/);\n        return m ? parseFloat(m[0]) : NaN;\n    }\n\n    function normalizeValues(values: Set<string>): { normalized: string[]; unit: string } {\n        const arr = [...values];\n        const unitMatch = arr[0]?.match(/[a-zA-Z/²]+$/);\n        const detectedUnit = unitMatch ? unitMatch[0] : '';\n        const allSameUnit = detectedUnit && arr.every(v => {\n            const m = v.match(/[a-zA-Z/²]+$/);\n            return m && m[0] === detectedUnit;\n        });\n        const hasUnit = arr.some(v => /[a-zA-Z/²]+$/.test(v));\n        const noUnit = arr.some(v => /^\\d+\\.?\\d*$/.test(v));\n\n        if (hasUnit && noUnit && detectedUnit) {\n            const fixed = arr.map(v => /^\\d+\\.?\\d*$/.test(v) ? `${v}${detectedUnit}` : v);\n            const sorted = fixed.sort((a, b) => {\n                const na = extractNumber(a), nb = extractNumber(b);\n                return (!isNaN(na) && !isNaN(nb)) ? na - nb : a.localeCompare(b, 'ko');\n            });\n            return { normalized: sorted, unit: detectedUnit };\n        }\n        const sorted = arr.sort((a, b) => {\n            const na = extractNumber(a), nb = extractNumber(b);\n            return (!isNaN(na) && !isNaN(nb)) ? na - nb : a.localeCompare(b, 'ko');\n        });\n        return { normalized: sorted, unit: allSameUnit ? detectedUnit : '' };\n    }\n\n    function inferAxisLabel(key: string, values: Set<string>): string {\n        const fixed: Record<string, string> = { diameter: '호칭경(mm)', sch: 'SCH', subtype: '유형' };\n        if (fixed[key]) return fixed[key];\n        const sample = [...values].find(v => v.length > 0) || '';\n        if (/^\\d+\\s*mm$/i.test(sample)) return '구경(mm)';\n        if (/kg\\/cm[²2]?$/i.test(sample)) return '압력(kg/cm²)';\n        if (/^\\d+\\s*R?T$/i.test(sample)) return '용량(RT)';\n        if (/^\\d+\\s*HP$/i.test(sample)) return '마력(HP)';\n        if (/^\\d+\\s*kW$/i.test(sample)) return '출력(kW)';\n        if (/^SCH/i.test(sample)) return 'SCH';\n        if (/^\\d+$/.test(sample)) return '호칭경';\n        return key === 'spec1' ? '규격1' : key === 'spec2' ? '규격2' : key;\n    }\n\n    const axes: FilterAxis[] = [];\n    for (const [key, vals] of axisMap) {\n        if (vals.size > 1) {\n            const { normalized } = normalizeValues(vals);\n            axes.push({ key, label: inferAxisLabel(key, vals), values: normalized });\n        }\n    }\n    return axes;\n}\n\nexport function buildSelectorPanel(\n    options: ClarifyOption[],\n    workName: string,\n    forceSelector: boolean = false\n): SelectorPanel | undefined {\n    if (!forceSelector && options.length <= 6) return undefined;\n\n    const selectorItems: SelectorItem[] = options\n        .filter(o => (o.option_type === 'worktype' || o.option_type === 'section') && (o.entity_id || o.section_id))\n        .map(o => ({\n            label: o.label,\n            query: o.query,\n            entity_id: o.entity_id || o.section_id,\n            source_section: o.source_section,\n            option_type: o.option_type,\n            specs: parseWorkTypeName(o.label),\n        }));\n\n    if (!forceSelector && selectorItems.length < 6) return undefined;\n\n    // ─── 유효한 Base Name(공통 공종명) 추출 ───\n    const counts = new Map<string, number>();\n    let maxBaseName = workName;\n    let maxCount = 0;\n\n    for (const item of selectorItems) {\n        // \"플랜트 배관 설치(동, SCH 80)\" -> \"플랜트 배관 설치\" 추출\n        let rawName = item.label;\n        // 접두어 \"[기계부문 > ...]\" 제거\n        if (rawName.includes('] ')) {\n            rawName = rawName.substring(rawName.indexOf('] ') + 2).trim();\n        }\n        // 괄호 규격 부분 이전 텍스트 추출\n        const match = rawName.match(/^([^()]+)\\s*\\(/);\n        const baseName = match ? match[1].trim() : rawName;\n\n        const c = (counts.get(baseName) || 0) + 1;\n        counts.set(baseName, c);\n        if (c > maxCount) {\n            maxCount = c;\n            maxBaseName = baseName;\n        }\n    }\n\n    // 그룹핑 타당성 검사: 검색 결과가 완전히 제각각인 하위 항목들이 섞여 있다면 (예: 포괄적 키워드 검색)\n    // 공통 규격으로 묶는 Selector Panel을 띄우는 것이 부적절하므로 일반 칩스(options)로 폴백합니다.\n    if (!forceSelector && maxCount < 4 && maxCount < selectorItems.length * 0.4) {\n        console.log(`[buildSelectorPanel] 공통 BaseName 부족(${maxCount}/${selectorItems.length}). Selector Panel 취소.`);\n        return undefined;\n    }\n\n    selectorItems.sort((a, b) => {\n        const numA = parseInt((a.label.match(/\\d+/) || ['0'])[0], 10);\n        const numB = parseInt((b.label.match(/\\d+/) || ['0'])[0], 10);\n        if (numA !== numB) return numA - numB;\n        return a.label.localeCompare(b.label, 'ko');\n    });\n\n    const filters = extractFilterAxes(selectorItems);\n\n    // 필터 축이 하나도 추출되지 않았다면 일반 칩스(options)로 폴백\n    if (!forceSelector && filters.length === 0) return undefined;\n\n    return {\n        title: `${maxBaseName} — 규격 선택`,\n        filters,\n        items: selectorItems,\n        original_query: workName,\n    };\n}\n"}, {"name": "search.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// search.ts — 검색 파이프라인 (벡터 + 키워드 + 타겟 + 청크 폴백)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nimport { supabase } from \"./config.ts\";\nimport type { EntityResult, IntentAnalysis } from \"./types.ts\";\n\n// ─── 약칭(Abbreviation) → 정식 명칭 매핑 ───\n// Why: \"TIG용접\" 검색 시 엔티티명 \"TIG(Tungsten Inert Gas)용접\"에\n//      ILIKE %TIG%용접%이 매칭 안 됨 → 정식 명칭을 병렬 검색\nconst ABBREVIATION_MAP: Record<string, string[]> = {\n    \"TIG\": [\"TIG(Tungsten Inert Gas)\", \"Tungsten Inert Gas\"],\n    \"MIG\": [\"MIG(Metal Inert Gas)\", \"Metal Inert Gas\"],\n    \"MAG\": [\"MAG(Metal Active Gas)\", \"Metal Active Gas\"],\n    \"CO2\": [\"CO2 아크\", \"CO₂\"],\n    \"SMAW\": [\"SMAW(Shielded Metal Arc Welding)\", \"피복아크용접\"],\n    \"SAW\": [\"SAW(Submerged Arc Welding)\", \"서브머지드아크용접\"],\n};\n\n// ─── 건설 도메인 동의어 사전 (확장 v2) ───\n// Why: \"PE관\" 검색 시 \"바트융착\", \"소켓융착\" 등\n//      이름에 \"PE\"가 없지만 PE관 작업인 entity를 검색망에 포함\n// Note: expandDomainSynonyms()의 양방향 includes 매칭으로 인해\n//       단글자 동의어(\"칠\" 등)는 오탐(False Positive)을 유발하므로 금지\nconst DOMAIN_SYNONYM_MAP: Record<string, string[]> = {\n    // 1. 배관/용접/기계설비\n    \"PE관\": [\"바트융착\", \"소켓융착\", \"새들융착\", \"폴리에틸렌\", \"HDPE\", \"버트융착\", \"가교화\"],\n    \"폴리에틸렌관\": [\"바트융착\", \"소켓융착\", \"새들융착\", \"PE관\", \"HDPE\"],\n    \"융착\": [\"바트융착\", \"소켓융착\", \"새들융착\", \"PE관\", \"폴리에틸렌\", \"버트 융착식\"],\n    \"가스관\": [\"PE관\", \"폴리에틸렌\", \"바트융착\", \"소켓융착\"],\n    \"용접\": [\"TIG\", \"MIG\", \"MAG\", \"CO2\", \"아크용접\", \"가스용접\", \"피복아크\", \"전기아크용접\"],\n    \"배관\": [\"강관\", \"폴리에틸렌관\", \"PVC관\", \"PE관\", \"동관\", \"스테인리스관\", \"주철관\"],\n    // 2. 건축/마감/방수\n    \"도장\": [\"페인트\", \"도료\", \"방청\", \"하도\", \"상도\", \"중도\", \"붓칠\", \"뿜칠\", \"롤러칠\"],\n    \"방수\": [\"아스팔트방수\", \"시트방수\", \"도막방수\", \"실링\", \"코킹\", \"우레탄\", \"에폭시\"],\n    // 3. 토목/기초/골조\n    \"철근\": [\"배근\", \"이음\", \"정착\", \"가공조립\", \"철근가공\", \"스페이서\"],\n    \"콘크리트\": [\"타설\", \"거푸집\", \"양생\", \"레미콘\", \"무근콘크리트\", \"철근콘크리트\", \"펌프카\"],\n    \"포장\": [\"아스팔트\", \"콘크리트포장\", \"다짐\", \"표층\", \"기층\", \"보조기층\", \"아스콘\", \"택코트\", \"프라임코트\"],\n    \"굴착\": [\"터파기\", \"되메우기\", \"토공\", \"잔토처리\", \"발파\", \"브레이카\", \"백호\", \"크롤러드릴\", \"굴삭기\"],\n};\n\n// ─── 질문에서 약칭 감지 → 확장 패턴 목록 반환 ───\nexport function expandAbbreviations(question: string): string[] {\n    const expanded: string[] = [];\n    for (const [abbr, aliases] of Object.entries(ABBREVIATION_MAP)) {\n        // 대소문자 무관 검색 (\"tig\" → \"TIG\")\n        if (question.toUpperCase().includes(abbr)) {\n            expanded.push(...aliases);\n        }\n    }\n    return expanded;\n}\n\n// ─── 도메인 동의어 확장 ───\n// Why: 사용자가 \"PE관\"을 검색하면 ILIKE '%바트융착%' 등도 병렬 검색\nexport function expandDomainSynonyms(terms: string[]): string[] {\n    const expanded: string[] = [];\n    for (const term of terms) {\n        const termUpper = term.toUpperCase();\n        for (const [key, synonyms] of Object.entries(DOMAIN_SYNONYM_MAP)) {\n            const keyUpper = key.toUpperCase();\n            // 양방향 매칭 (대소문자 무시): \"pe관\" ⊃ \"PE관\" 또는 \"PE관\" ⊃ \"pe관\"\n            if (termUpper.includes(keyUpper) || keyUpper.includes(termUpper)) {\n                expanded.push(...synonyms);\n            }\n        }\n    }\n    return [...new Set(expanded)]; // 중복 제거\n}\n\n// ─── 영한 혼합어 분리 패턴 생성 ───\n// Why: \"PE관\" 검색 시 ILIKE '%PE관%'은 \"가스용 폴리에틸렌(PE)관\"에 매칭 안 됨\n//      PE와 관 사이에 ')' 괄호가 존재하기 때문.\n//      \"PE관\" → \"%PE%관%\" 로 분리하여 중간 문자를 허용하는 완화 패턴 생성\nexport function expandMixedTerms(terms: string[]): string[] {\n    const extra: string[] = [];\n    for (const t of terms) {\n        // 영문+한글 경계에서 분리: \"PE관\" → [\"PE\", \"관\"], \"HDPE관\" → [\"HDPE\", \"관\"]\n        const parts = t.match(/[A-Za-z0-9]+|[가-힣]+/g);\n        if (parts && parts.length >= 2) {\n            // 원본(\"PE관\")과 다른 완화 패턴(\"%PE%관%\") 추가\n            const relaxed = \"%\" + parts.join(\"%\") + \"%\";\n            const strict = `%${t}%`;\n            if (relaxed !== strict) {\n                extra.push(relaxed);\n            }\n        }\n    }\n    return extra;\n}\n\n// ─── 질문에서 규격 숫자 추출 ───\n// \"강관용접 200mm SCH 40\" → [\"200\", \"SCH 40\"]\n// \"강관용접 φ350 SCH 20\"  → [\"350\", \"SCH 20\"]\nexport function extractSpecNumbers(question: string): string[] {\n    const nums: string[] = [];\n\n    // 구경 숫자 추출 (200mm, φ200, 200A 등에서 숫자만)\n    const diameterMatch = question.match(/(?:[φΦø∅]?\\s*)(\\d{2,4})\\s*(?:mm|A|㎜)?/);\n    if (diameterMatch) nums.push(diameterMatch[1]);\n\n    // SCH 추출 (SCH 40, SCH40 등)\n    const schMatch = question.match(/SCH\\s*(\\d+)/i);\n    if (schMatch) nums.push(`SCH ${schMatch[1]}`);\n\n    return nums;\n}\n\n// ─── ILIKE 기반 키워드 폴백 검색 ───\nexport async function keywordFallbackSearch(question: string, specNumbers: string[]): Promise<EntityResult[]> {\n    // 질문에서 공종명 추출 (한글 2글자 이상 단어)\n    const koreanWords = question.match(/[가-힣]{2,}/g) || [];\n    // 품셈, mm 등 일반 키워드 제외\n    const stopWords = new Set([\"품셈\", \"인력\", \"인공\", \"수량\", \"단위\", \"장비\", \"자재\", \"알려줘\", \"얼마\", \"관련\"]);\n    const workKeywords = koreanWords.filter(w => !stopWords.has(w));\n\n    if (workKeywords.length === 0) return [];\n\n    // 단일 ILIKE 패턴 조합: \"%강관용접%200%SCH 40%\"\n    // Why: supabase-js v2의 .ilike() 체이닝 시 TypeScript 타입 소실 문제 회피\n    //      단일 호출로 모든 키워드를 포함하는 엔티티 검색\n    const allTokens = [...workKeywords, ...specNumbers];\n    const pattern = \"%\" + allTokens.join(\"%\") + \"%\";\n\n    // ─── 약칭 확장: TIG → TIG(Tungsten Inert Gas) 등 ───\n    const abbrExpansions = expandAbbreviations(question);\n    const orClauses = [`name.ilike.${pattern}`, `properties->>'korean_alias'.ilike.${pattern}`];\n    for (const alias of abbrExpansions) {\n        orClauses.push(`name.ilike.%${alias}%`);\n    }\n    const { data, error } = await supabase\n        .from(\"graph_entities\")\n        .select(\"id, name, type, properties, source_section\")\n        .in(\"type\", [\"WorkType\", \"Standard\"])\n        .or(`name.ilike.${pattern},properties->>\"korean_alias\".ilike.${pattern}`)\n        .limit(3);\n\n    if (error || !data) {\n        console.error(\"keywordFallbackSearch error:\", error?.message);\n        return [];\n    }\n\n    // EntityResult 형태로 변환 (similarity는 1.0으로 설정 — 정확 매칭)\n    console.log(`[keywordFallback] ${data.length}건 매칭 (약칭확장: ${abbrExpansions.length}개)`);\n    return (data as any[]).map((e: any) => ({\n        id: e.id,\n        name: e.name,\n        type: e.type,\n        properties: e.properties || {},\n        similarity: 1.0, // 키워드 정확 매칭\n        source_section: e.source_section,\n    }));\n}\n\n// ─── Layer 4: chunk 본문 텍스트 키워드 검색 ───\n// Why: \"장비편성\", \"인력편성\" 등 엔티티 이름에 없지만\n//      chunk 본문에만 존재하는 소제목/용어를 검색\n//      기존 Layer 1~3에 영향 없이, 조건부로만 실행\nexport async function chunkTextFallbackSearch(\n    question: string\n): Promise<EntityResult[]> {\n    // 1. 질문에서 한글 키워드 추출 (경량 stopWords — \"장비\",\"인력\" 등은 보존)\n    const koreanWords = question.match(/[가-힣]{2,}/g) || [];\n    const contextStopWords = new Set([\n        \"품셈\", \"알려줘\", \"얼마\", \"관련\", \"어떻게\", \"무엇\", \"확인\", \"검색\",\n    ]);\n    const filteredWords = koreanWords.filter(w => !contextStopWords.has(w));\n    if (filteredWords.length === 0) return [];\n\n    // 2. 복합어 생성: [\"장비\", \"편성\"] → \"장비편성\"\n    const compoundPatterns: string[] = [];\n    for (let i = 0; i < filteredWords.length - 1; i++) {\n        compoundPatterns.push(filteredWords[i] + filteredWords[i + 1]);\n    }\n    if (filteredWords.length >= 2) {\n        compoundPatterns.push(filteredWords.join(''));\n    }\n\n    // 가드: 단일 키워드만 남으면 chunk 검색 skip (\"장비\"만으로 검색 → 수백 건 노이즈)\n    if (filteredWords.length < 2 && compoundPatterns.length === 0) {\n        console.log(`[chunkTextFallback] 단일 키워드만 → skip`);\n        return [];\n    }\n\n    // 3. chunk text에서 ILIKE 검색 (복합어 우선 → 원본 키워드 조합 순)\n    const searchPatterns = [\n        ...compoundPatterns.map(p => `%${p}%`),\n        `%${filteredWords.join('%')}%`,\n    ];\n\n    for (const pattern of searchPatterns) {\n        const { data: matchedChunks } = await supabase\n            .from(\"graph_chunks\")\n            .select(\"section_id, title, department, chapter\")\n            .ilike(\"text\", pattern)\n            .limit(10);\n\n        if (matchedChunks && matchedChunks.length > 0) {\n            // 중복 section_id 제거\n            const uniqueSections = new Map<string, any>();\n            matchedChunks.forEach((c: any) => {\n                if (!uniqueSections.has(c.section_id)) {\n                    uniqueSections.set(c.section_id, c);\n                }\n            });\n\n            const sectionIds = Array.from(uniqueSections.keys());\n            console.log(`[chunkTextFallback] pattern=\"${pattern}\" → ${sectionIds.length}개 섹션: ${sectionIds.join(', ')}`);\n\n            // 4. 매칭된 섹션의 WorkType 조회\n            const { data: wtData } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, properties, source_section\")\n                .eq(\"type\", \"WorkType\")\n                .in(\"source_section\", sectionIds)\n                .limit(15);\n\n            if (wtData && wtData.length > 0) {\n                console.log(`[chunkTextFallback] WorkType ${wtData.length}건 반환`);\n                return (wtData as any[]).map(e => ({\n                    id: e.id, name: e.name, type: e.type,\n                    properties: e.properties || {},\n                    similarity: 0.85,\n                    source_section: e.source_section,\n                }));\n            }\n\n            // WorkType 없으면 → Section 엔티티 반환\n            const { data: sectionEntities } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, properties, source_section\")\n                .eq(\"type\", \"Section\")\n                .in(\"source_section\", sectionIds)\n                .limit(10);\n\n            if (sectionEntities && sectionEntities.length > 0) {\n                console.log(`[chunkTextFallback] Section ${sectionEntities.length}건 반환`);\n                return (sectionEntities as any[]).map(e => ({\n                    id: e.id, name: e.name, type: e.type,\n                    properties: e.properties || {},\n                    similarity: 0.80,\n                    source_section: e.source_section,\n                }));\n            }\n        }\n    }\n\n    return [];\n}\n\n// ─── WorkType 중복 제거 (클린 DB로 인해 삭제됨 됨) ───\n// C-1. 벡터 검색 + 키워드 폴백\nexport async function searchEntities(embedding: number[], question: string): Promise<EntityResult[]> {\n    const { data, error } = await supabase.rpc(\"search_entities_by_embedding\", {\n        query_embedding_text: JSON.stringify(embedding),\n        match_count: 5,\n        match_threshold: 0.4, // 건설 용어 특수성 고려 threshold 완화\n    });\n\n    if (error) {\n        console.error(\"searchEntities error:\", error.message);\n        return [];\n    }\n\n    let entities = (data || []) as EntityResult[];\n\n    // ─── 키워드 폴백: 벡터 검색 결과에 질문의 핵심 규격이 없으면 ILIKE 보완 ───\n    // Why: 임베딩 모델이 \"200mm\"와 \"(200,\"의 의미적 연결을 잘 못하여\n    //       \"강관용접(250, SCH 140)\"이 \"강관용접(200, SCH 40)\"보다 높은 유사도 반환\n    //       → 규격 숫자 기반 키워드 매칭으로 정확한 엔티티를 폴백 검색\n    const specNumbers = extractSpecNumbers(question);\n    if (specNumbers.length > 0) {\n        // 벡터 결과에 질문의 규격 숫자가 포함된 엔티티가 있는지 확인\n        const hasExactMatch = entities.some(e =>\n            specNumbers.every(num => e.name.includes(num))\n        );\n\n        if (!hasExactMatch) {\n            console.log(`[키워드 폴백] 벡터 결과에 ${specNumbers.join(',')} 미포함, ILIKE 폴백 실행`);\n            const fallbackEntities = await keywordFallbackSearch(question, specNumbers);\n            if (fallbackEntities.length > 0) {\n                // 폴백 결과를 최상위에 삽입, 기존 벡터 결과에서 중복 제거\n                const fallbackIds = new Set(fallbackEntities.map(e => e.id));\n                entities = [\n                    ...fallbackEntities,\n                    ...entities.filter(e => !fallbackIds.has(e.id)),\n                ].slice(0, 5);\n            }\n        }\n    }\n\n    // (Codex F4) 이제 search_entities_by_embedding 에서 source_section을 직접 반환하므로 추가 쿼리가 필요하지 않습니다.\n    return entities;\n}\n\n// ─── E-3. 타겟 검색 (3단계 캐스케이드) ───\n// Why: 의도 분석 결과를 활용하여 정확도가 높은 순서대로 검색.\n//      벡터 검색은 최후 수단으로만 사용.\nexport async function targetSearch(\n    analysis: IntentAnalysis,\n    embedding: number[],\n    question: string\n): Promise<EntityResult[]> {\n\n    const toEntityResults = (data: any[], similarity: number): EntityResult[] =>\n        (data as any[]).map((e: any) => ({\n            id: e.id, name: e.name, type: e.type,\n            properties: e.properties || {},\n            similarity,\n            source_section: e.source_section,\n        }));\n\n    // 1단계: ILIKE 정확 매칭 (work_name + spec, korean_alias 포함)\n    if (analysis.work_name && analysis.spec) {\n        const pattern = `%${analysis.work_name}%${analysis.spec}%`;\n        const { data } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id, name, type, properties, source_section\")\n            .in(\"type\", [\"WorkType\", \"Section\"])\n            .or(`name.ilike.${pattern},properties->>\"korean_alias\".ilike.${pattern}`)\n            .limit(5);\n\n        if (data && data.length > 0) {\n            console.log(`[targetSearch] 1단계 ILIKE 정확 매칭: ${data.length}건`);\n            return toEntityResults(data, 1.0);\n        }\n\n        // 1단계 실패 → work_name만으로 재시도 (spec이 엔티티명에 없는 경우)\n        // Why: \"PE관\" → \"%PE관%\" 매칭 실패 대비, 영한 혼합어 완화 패턴도 추가\n        const fallbackPattern = `%${analysis.work_name}%`;\n        const mixedPatterns = expandMixedTerms([analysis.work_name]);\n        // 💡 [Track B-1] 1단계에도 도메인 동의어 확장 적용\n        const stage1Synonyms = expandDomainSynonyms([analysis.work_name]);\n        const fallbackOrClauses = [\n            `name.ilike.${fallbackPattern}`,\n            `properties->>\"korean_alias\".ilike.${fallbackPattern}`,\n            ...mixedPatterns.map(p => `name.ilike.${p}`),\n            ...stage1Synonyms.map(s => `name.ilike.%${s}%`),\n        ].join(\",\");\n        const { data: fallback } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id, name, type, properties, source_section\")\n            .in(\"type\", [\"WorkType\", \"Section\"])\n            .or(fallbackOrClauses)\n            .limit(20);\n\n        if (fallback && fallback.length > 0) {\n            console.log(`[targetSearch] 1단계 work_name 폴백(+동의어): ${fallback.length}건`);\n            return toEntityResults(fallback, 0.98);\n        }\n\n        // 1단계 약칭 확장 폴백: TIG → TIG(Tungsten Inert Gas) 등\n        const abbrExpansions = expandAbbreviations(analysis.work_name);\n        if (abbrExpansions.length > 0) {\n            const abbrOrClauses = abbrExpansions.map(a => `name.ilike.%${a}%`).join(\",\");\n            const { data: abbrData } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, properties, source_section\")\n                .in(\"type\", [\"WorkType\", \"Section\", \"Standard\"])\n                .or(abbrOrClauses)\n                .limit(5);\n\n            if (abbrData && abbrData.length > 0) {\n                console.log(`[targetSearch] 1단계 약칭 확장: ${abbrData.length}건`);\n                return toEntityResults(abbrData, 0.96);\n            }\n        }\n    }\n\n    // 2단계: 키워드 기반 ILIKE (korean_alias 포함)\n    const searchTerms = analysis.keywords.length > 0\n        ? analysis.keywords\n        : (analysis.work_name ? [analysis.work_name] : []);\n\n    if (searchTerms.length > 0) {\n        // ⭐ ILIKE 검색에는 noise가 적은 키워드만 사용\n        //    - 한글 키워드: 항상 포함 (PE관, PE드럼, 폴리에틸렌 등)\n        //    - 영문 키워드 ≥ 4자: 포함 (HDPE 등)\n        //    - 영문 키워드 ≤ 3자: 제외 (PE → Type, Pipe, Speed 등 noise)\n        const dedupTerms = [...new Set(searchTerms.filter(t => t.length >= 2))];\n        const ilikeTerms = dedupTerms.filter(t => {\n            const isAllEnglish = /^[A-Za-z]+$/.test(t);\n            return !isAllEnglish || t.length >= 4;  // 영문만이면 4자 이상만\n        });\n\n        if (ilikeTerms.length === 0 && dedupTerms.length > 0) {\n            // 전부 짧은 영문 → work_name 폴백\n            ilikeTerms.push(...dedupTerms);\n        }\n\n        // ─── 영한 혼합어 완화 패턴 추가 ───\n        // Why: \"PE관\" → ILIKE '%PE관%' 은 \"가스용 폴리에틸렌(PE)관\"에 매칭 안 됨\n        //      PE와 관 사이에 ')' 괄호가 있기 때문 → '%PE%관%' 패턴 추가\n        const mixedExpansions = expandMixedTerms(ilikeTerms);\n        // 💡 [Track B-1] 도메인 동의어 확장: \"PE관\" → \"바트융착\", \"소켓융착\" 등 병렬 검색\n        const domainExpansions = expandDomainSynonyms(ilikeTerms);\n        const orClauses = [\n            ...ilikeTerms.map(t => `name.ilike.%${t}%`),\n            ...mixedExpansions.map(p => `name.ilike.${p}`),\n            ...domainExpansions.map(s => `name.ilike.%${s}%`),\n        ].join(\",\");\n        const { data } = await supabase\n            .from(\"graph_entities\")\n            .select(\"id, name, type, properties, source_section\")\n            .in(\"type\", [\"WorkType\", \"Section\"])\n            .or(orClauses)\n            .limit(50);\n\n        if (data && data.length > 0) {\n            // 관련도 정렬: 매칭 키워드 수 + 원문 질문어 매칭 보너스\n            const questionKorean = question.match(/[가-힣]+/g) || [];\n            const scored = data.map((e: any) => {\n                let score = 0;\n                const nameLower = e.name.toLowerCase();\n                // 모든 키워드(짧은 영문 포함) 매칭 카운트\n                for (const t of dedupTerms) {\n                    if (nameLower.includes(t.toLowerCase())) score += 2;\n                }\n                // 원문 한글어 매칭 보너스 (예: \"관\" → \"PE관\", \"폴리에틸렌관\" 가중)\n                for (const k of questionKorean) {\n                    if (nameLower.includes(k)) score += 1;\n                }\n                return { ...e, _score: score };\n            });\n            scored.sort((a: any, b: any) => b._score - a._score);\n            const top = scored.slice(0, 20);\n            console.log(`[targetSearch] 2단계 키워드 매칭: ${data.length}건 → 상위 ${top.length}건 (scores: ${top.slice(0, 5).map((s: any) => s._score).join(',')})`);\n            return toEntityResults(top, 0.95);\n        }\n\n        // 2단계 실패 → work_name 단독 재시도 (keywords에 규격이 포함되어 못 찾는 경우)\n        if (analysis.work_name && searchTerms.length > 1) {\n            const wnPattern = `%${analysis.work_name}%`;\n            const { data: wnData } = await supabase\n                .from(\"graph_entities\")\n                .select(\"id, name, type, properties, source_section\")\n                .in(\"type\", [\"WorkType\", \"Section\"])\n                .or(`name.ilike.${wnPattern},properties->>\"korean_alias\".ilike.${wnPattern}`)\n                .limit(20);\n\n            if (wnData && wnData.length > 0) {\n                console.log(`[targetSearch] 2단계 work_name 폴백: ${wnData.length}건`);\n                return toEntityResults(wnData, 0.90);\n            }\n        }\n    }\n\n    // 3단계: 벡터 검색 (타입 필터 적용 — Note/Equipment 제외)\n    const { data, error } = await supabase.rpc(\"search_entities_typed\", {\n        query_embedding_text: JSON.stringify(embedding),\n        match_count: 5,\n        match_threshold: 0.4,\n        type_filter: [\"Section\", \"WorkType\"],\n    });\n\n    if (error) {\n        console.error(\"[targetSearch] 벡터 검색 에러:\", error.message);\n        return searchEntities(embedding, question);\n    }\n\n    console.log(`[targetSearch] 3단계 벡터 검색: ${(data || []).length}건`);\n    const vectorResults = (data || []) as EntityResult[];\n\n    // 4단계: chunk text fallback (Layer 4)\n    // Why: 벡터 결과가 Section만이거나 WorkType 유사도가 낮을 때,\n    //      chunk 본문에만 존재하는 용어(\"장비편성\", \"인력편성\" 등)를 검색\n    const hasGoodMatch = vectorResults.some(\n        e => e.type === 'WorkType' && e.similarity >= 0.7\n    );\n    if (!hasGoodMatch) {\n        console.log(`[targetSearch] 4단계 chunk text fallback 시도 (WorkType+sim≥0.7 없음)`);\n        const chunkResults = await chunkTextFallbackSearch(question);\n        if (chunkResults.length > 0) {\n            console.log(`[targetSearch] 4단계 chunk text: ${chunkResults.length}건 → 벡터 결과와 병합`);\n            const chunkIds = new Set(chunkResults.map(e => e.id));\n            return [\n                ...chunkResults,\n                ...vectorResults.filter(e => !chunkIds.has(e.id)),\n            ];\n        }\n    }\n\n    return vectorResults;\n}\n\n// ─── 검색어 정제 유틸리티 ───\n// Why: LLM이 work_name과 중복되는 키워드를 생성할 수 있으므로,\n//      work_name에 포함된 키워드를 제거하여 ILIKE 패턴 오염 방지\nexport function buildSearchTerms(work_name: string | null, keywords: string[]): string[] {\n    if (!work_name) return keywords;\n    const nameLower = work_name.toLowerCase();\n    return keywords.filter(kw => {\n        const kwLower = kw.toLowerCase();\n        // work_name에 키워드가 포함되어 있으면 제거\n        if (nameLower.includes(kwLower)) return false;\n        // 키워드에 work_name이 포함되어 있으면 제거\n        if (kwLower.includes(nameLower)) return false;\n        return true;\n    });\n}\n"}, {"name": "seed_13_1_1.ts", "content": "import { supabase } from \"./config.ts\";\n\nconst data = JSON.parse(Deno.readTextFileSync(\"../pipeline/scripts/records_13_1_1.json\"));\n\nasync function seed() {\n    console.log(`Starting insertion of ${data.length} records...`);\n\n    // Batch upsert using Supabase\n    const batchSize = 100;\n    for (let i = 0; i < data.length; i += batchSize) {\n        const batch = data.slice(i, i + batchSize);\n        const { error } = await supabase.from(\"complex_table_specs\").upsert(batch, {\n            onConflict: \"section_code, material, spec_mm, thickness_mm, pipe_location, joint_type, job_name\"\n        });\n\n        if (error) {\n            console.error(`Error inserting batch ${i / batchSize + 1}:`, error);\n        } else {\n            console.log(`Successfully inserted batch ${i / batchSize + 1}`);\n        }\n    }\n    console.log(\"Seed complete.\");\n}\n\nseed();\n"}, {"name": "types.ts", "content": "// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// types.ts — 공통 타입/인터페이스 정의\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nexport interface ChatMessage {\n    role: \"user\" | \"assistant\";\n    content: string;\n}\n\nexport interface ChatRequest {\n    question: string;\n    history?: ChatMessage[];\n    entity_id?: string;   // 칩 선택 시 직접 entity 조회용\n    section_id?: string;  // Step 2 트리거용 section_id (I-6 수정)\n    session_context?: SessionContext;  // 세션 상태 (이전 턴 품셈/수량 정보)\n}\n\n// 세션 상태 (프론트엔드 → 서버 전달)\n// Why: \"아까 건\", \"그거 말고\" 같은 맥락 참조 질문 해석에 필요\nexport interface SessionContext {\n    last_entity_id: string | null;       // 마지막 확정 품셈 entity ID (예: \"W-0788\")\n    last_work_name: string | null;       // \"강관용접(200, SCH 40)\"\n    last_spec: string | null;            // \"200 SCH 40\"\n    last_quantity: number | null;        // 50\n    last_section_id: string | null;      // \"13-2-3\"\n}\n\nexport interface SourceInfo {\n    entity_id?: string;\n    entity_name: string;\n    entity_type: string;\n    source_section?: string;\n    section_label?: string;\n    similarity?: number;\n}\n\nexport interface TokenUsage {\n    embedding_tokens: number;\n    llm_input_tokens: number;\n    llm_output_tokens: number;\n    total_tokens: number;\n    estimated_cost_krw: number;\n}\n\nexport interface SearchInfo {\n    entities_found: number;\n    relations_expanded: number;\n    ilwi_matched: number;\n    chunks_retrieved: number;\n    latency_ms: number;\n    token_usage?: TokenUsage;\n}\n\n// 명확화 선택 옵션\nexport interface ClarifyOption {\n    label: string;           // 표시 텍스트: \"200mm SCH 40\"\n    query: string;           // 클릭 시 전송할 질문\n    entity_id?: string;      // 직접 검색용 ID (옵션)\n    source_section?: string; // 출처 절번호\n    section_id?: string;     // Step 2 트리거용 section_id (graph_chunks 키)\n    option_type?: 'section' | 'worktype' | 'full_view';  // 옵션 유형\n}\n\nexport interface ClarificationInfo {\n    options: ClarifyOption[];\n    reason: string;\n    original_query: string;\n    selector?: SelectorPanel;  // 6개 초과 시 드롭다운+체크박스 패널\n}\n\n// ─── Selector Panel 타입 (명확화 UI 개선) ───\n\nexport interface FilterAxis {\n    key: string;       // \"diameter\" | \"sch\"\n    label: string;     // \"호칭경(mm)\" | \"SCH\"\n    values: string[];  // [\"15\",\"20\",\"25\",...]\n}\n\nexport interface SelectorItem {\n    label: string;\n    query: string;\n    entity_id?: string;\n    source_section?: string;\n    option_type?: string;  // 'worktype' | 'section'\n    specs: Record<string, string>;  // { diameter: \"200\", sch: \"40\" }\n}\n\nexport interface SelectorPanel {\n    title: string;              // \"강관용접 — 규격 선택\"\n    filters: FilterAxis[];      // 필터 축 (호칭경, SCH 등)\n    items: SelectorItem[];      // 전체 항목 (필터링 전)\n    original_query: string;\n}\n\nexport interface ChatResponse {\n    type: \"answer\" | \"clarify\";     // 응답 유형\n    answer: string;\n    sources: SourceInfo[];\n    search_info: SearchInfo;\n    clarification?: ClarificationInfo; // 명확화 정보 (type=clarify 시)\n}\n\n// 의도 분석 결과\nexport interface IntentAnalysis {\n    intent: \"search\" | \"clarify_needed\" | \"followup\" | \"greeting\" | \"quantity_input\" | \"cost_calculate\" | \"modify_request\" | \"report_request\";\n    work_name: string | null;\n    spec: string | null;\n    keywords: string[];\n    ambiguity_reason: string | null;\n    modify_type?: \"quantity\" | \"work_change\" | \"exclude_labor\" | null;  // modify_request 세부 유형\n    quantity?: number | null;  // quantity_input/modify_request 시 수량 값\n}\n\n// 검색 결과 엔티티\nexport interface EntityResult {\n    id: string;\n    name: string;\n    type: string;\n    properties: Record<string, unknown>;\n    similarity: number;\n    source_section?: string; // 추가 조회로 채움\n}\n\n// 그래프 관계\nexport interface RelatedResource {\n    direction: string;\n    relation: string;\n    related_id: string;\n    related_name: string;\n    related_type: string;\n    properties: Record<string, unknown>;\n}\n\n// 일위대가 항목\nexport interface IlwiItem {\n    id: number;\n    name: string;\n    spec: string;\n    labor_cost: number;\n    material_cost: number;\n    expense_cost: number;\n    total_cost: number;\n}\n\n// 품셈 표 데이터 (graph_chunks.tables JSON 구조)\nexport interface TableData {\n    table_id: string;\n    type: string;\n    headers: string[];\n    rows: Record<string, any>[];\n    raw_row_count: number;\n    parsed_row_count: number;\n    notes_in_table?: string[];\n}\n\n// 원문 청크\nexport interface ChunkResult {\n    id: string;\n    section_id: string;\n    title: string;\n    department: string;\n    chapter: string;\n    section: string;\n    text: string; // DB 컬럼명: text (not content)\n    tables?: TableData[];   // 품셈 표 데이터\n    notes?: any[];          // 주의사항\n}\n\n// 명확화 결과\nexport interface ClarifyResult {\n    message: string;\n    options: ClarifyOption[];\n    selector?: SelectorPanel;  // 6개 초과 시 Selector Panel 데이터\n}\n\n// LLM 응답 결과\nexport interface LLMResult {\n    answer: string;\n    inputTokens: number;\n    outputTokens: number;\n}\n\n// ─── 답변 생성 옵션 (intent→답변 연결) ───\nexport interface AnswerOptions {\n    intent?: string;       // \"cost_calculate\" | \"report_request\" | \"modify_request\" 등\n    quantity?: number;     // 사용자 지정 수량 (50m, 10개소 등)\n    modifyType?: string;   // \"quantity\" | \"work_change\"\n}\n\n// ─── 노임단가 항목 ───\nexport interface LaborCostEntry {\n    job_name: string;\n    cost_2026: number;\n}\n"}]
# Step 2.6 이후 전면 재검토 설계보고서 (v3)

> **작성일**: 2026-02-11  
> **상태**: 최종 확정 + Codex 검토 반영  
> **이전 버전 대비 변경**: v2 Codex 검토(F1~F5) + 데이터 구조 검증(F6~F8) 반영

---

## 1. 확정된 아키텍처 요약

```
┌─────────────────────────────────────────────────────────┐
│                    최종 시스템 구성도                      │
│                                                         │
│  [사용자]                                                │
│     │                                                   │
│     ▼                                                   │
│  [정적 HTML 프론트엔드]  ← Cloudflare Pages 등            │
│     │                                                   │
│     ▼                                                   │
│  [Supabase Edge Function]  ← 서버리스 (n8n 대체)          │
│     │                                                   │
│     ├─→ 벡터 검색 (pgvector)   → 품셈 엔티티 시작점 탐색   │
│     ├─→ 그래프 탐색 (SQL JOIN)  → 관련 자원 확장           │
│     ├─→ 구조 검색 (SQL WHERE)  → 일위대가 비용 조회        │
│     │                                                   │
│     ▼                                                   │
│  [Gemini API]  → 컨텍스트 기반 답변 생성                   │
│     │                                                   │
│     ▼                                                   │
│  [사용자에게 응답]                                         │
└─────────────────────────────────────────────────────────┘
```

### 확정 의사결정 요약표

| 항목                 | 결정                             | 근거                                                    |
| -------------------- | -------------------------------- | ------------------------------------------------------- |
| **데이터 저장소**    | Supabase (PostgreSQL + pgvector) | 관계 깊이 1~2단계 → JOIN 충분, 별도 그래프 DB 불필요    |
| **임베딩 모델**      | gemini-embedding-001 (768d)      | API 편의성 우선, 한국어 품질 불만 시 KURE-v1으로 교체   |
| **일위대가 처리**    | 구조 검색 (임베딩 안 함)         | 밀집 문제 심각 (336건 동일 이름), SQL 필터가 정확       |
| **서빙 방식**        | Supabase Edge Function           | n8n 제거 → 서버리스, 유지보수 0, 집 PC 꺼도 됨          |
| **검색 전략**        | 벡터 + 그래프 (Phase 1)          | 키워드 검색은 나중에 필요 시 추가 (pg_trgm 이미 활성화) |
| **임베딩 실행 환경** | Oracle Cloud A1 (8코어, 24GB)    | 기존 인스턴스 활용, 추가 비용 0원                       |
| **모델 교체 비용**   | 코드 10분 + 재생성 2~3시간       | 차원 변경(768→1024) ALTER 1줄                           |

---

## 2. 의사결정 상세 근거

### 2.1 저장소: Supabase 단일 저장소 확정

**판단 기준**: 우리 품셈 데이터의 관계 깊이

```
[콘크리트 타설] → [보통인부]          ← 1단계 (대부분)
[콘크리트 타설] → [토목부문 > 6장]    ← 1단계
[토목부문 > 6장] → [같은 장의 다른 공종] ← 2단계 (가끔)
```

- **3단계 이상 탐색이 필요한 경우가 거의 없음**
- PostgreSQL `JOIN` 1~2회로 모든 관계 탐색 가능
- Neo4j 같은 전용 그래프 DB는 SNS 친구추천(6단계)이나 경로 탐색에 필요 → 과잉 투자
- Supabase는 벡터(pgvector) + SQL + 키워드(pg_trgm)를 **한 곳에서** 처리

**결론**: 별도 DB 추가 없이 Supabase만으로 충분.

### 2.2 임베딩 모델: gemini-embedding-001 우선, KURE-v1 대기

**후보 비교**:

|             | gemini-embedding-001                              | KURE-v1                           |
| ----------- | ------------------------------------------------- | --------------------------------- |
| 한국어 성능 | 좋음 (MTEB 전체 1위, 한국어 단독 벤치마크 미공개) | **검증됨** (KoIR, KorFinMTEB 1위) |
| 구현 난이도 | API 호출 3줄                                      | 라이브러리 설치 + CPU/GPU         |
| 비용        | Free tier (하루 1000건) / 유료 $0.31              | 완전 무료                         |
| 차원        | 768 (선택 가능 768~3072)                          | 1024 고정                         |

**결정 논리**:
1. gemini-embedding-001로 빠르게 시작
2. 한국어 건설 용어 검색 품질 평가
3. 불만족 시 KURE-v1으로 교체 (코드 10분 + 재생성 2~3시간)

**KURE-v1 교체 시 변경사항**:
- 임베딩 생성 함수 1개 수정
- Supabase 컬럼 타입: `vector(768)` → `vector(1024)` (ALTER TABLE 1줄)
- Oracle Cloud A1에서 CPU 모드로 실행 (2~3시간, 오픈클로 봇 잠시 중지 권장)

### 2.3 일위대가: 구조 검색 확정 (임베딩 제외)

**문제 발견: 임베딩 밀집**

일위대가 6,992건 분석 결과, 동일 이름에 규격만 다른 변형이 대량 존재:

| 이름                        |  변형 수  | 차이점                                       |
| --------------------------- | :-------: | -------------------------------------------- |
| 관보온/발포폴리에틸렌보온재 | **336건** | D15~D300 × 보온두께 × 접합방식 × 장소 × 마감 |
| 관보온/고무발포보온재       | **336건** | 동일 패턴                                    |
| 관보온/유리솜보온재         | **336건** | 동일 패턴                                    |
| 그루브조인트식 접합 및 배관 | **144건** | D25~D600 × 장소 × 고소작업대                 |
| 스텐관 용접 배관            | **144건** | 동일 패턴                                    |

**보온 3종(1,008건) + 배관 5종(~640건) = 1,648건이 거의 동일한 임베딩을 가지게 됨**

벡터 검색 시 TOP-5 결과가 **모두 같은 공종의 규격 변형**으로 채워져 다양한 결과를 반환하지 못함.

**해결**: 일위대가는 이미 `name + spec`으로 정확히 구조화되어 있으므로 SQL 조건 검색이 최적:

```sql
-- 사용자: "강관 용접 배관 D80 기계실 비용"
SELECT name, spec, labor_cost, material_cost, total_cost
FROM ilwi_items
WHERE name = '강관 용접 배관'
  AND spec LIKE '%D80%'
  AND spec LIKE '%기계실%';
-- → 정확히 1건 반환
```

### 2.4 n8n 제거 → Supabase Edge Function

**배경**: n8n을 집 PC에서 돌리고 있어 컴퓨터 상시 가동이 불편

**비교**:

|            | n8n (현재)                    | Edge Function (대체) |
| ---------- | ----------------------------- | -------------------- |
| 서버 관리  | Docker 컨테이너 모니터링 필요 | **없음 (서버리스)**  |
| 업데이트   | n8n 버전 업데이트 직접        | Supabase가 자동      |
| 장애 대응  | 죽으면 재시작                 | **자동 복구**        |
| SSL/도메인 | 직접 설정                     | **자동**             |
| 비용       | 무료 (집 PC 전기세)           | 무료 (Supabase Free) |
| 집 PC      | **켜 놓아야 함**              | **꺼도 됨**          |

**Edge Function이 하는 일**:
1. Webhook으로 사용자 질문 수신
2. 질문 임베딩 생성 (Gemini API 호출)
3. Supabase에서 벡터 검색 + 그래프 확장 + 일위대가 구조 검색
4. 컨텍스트 조합 → Gemini API로 답변 생성
5. 응답 반환

### 2.5 검색 전략: 벡터 + 그래프 (키워드는 Phase 2)

**기존 v13**: 키워드 70% + 벡터 30% 가중 합산 → 결과 TOP-5

**새 전략**: 우선순위 기반 2단계

```
━━━ 1단계: 시작점 찾기 (벡터 검색) ━━━
사용자 질문 → 임베딩 → pgvector 유사도 검색 → TOP-3 엔티티

━━━ 2단계: 그래프 확장 ━━━
찾은 엔티티 → graph_relationships 테이블 JOIN
→ 관련 인력(Labor), 장비(Equipment), 자재(Material) 전부 가져오기

━━━ 3단계: 일위대가 구조 검색 ━━━
엔티티 이름 → ilwi_items 테이블 WHERE 조건 매칭
→ 비용 정보 (재료비, 노무비, 합계) 가져오기

━━━ 4단계: LLM 답변 생성 ━━━
품셈 + 관련자원 + 일위대가 → Gemini에 컨텍스트로 전달 → 답변
```

**키워드 검색 보류 이유**:
- 벡터 검색이 90% 케이스에서 충분
- 키워드가 필요한 10% (동의어, 약어)는 벡터가 오히려 잘 처리
- pg_trgm은 이미 활성화 → 나중에 SQL 한 줄 추가로 활성화 가능
- 검색 로직 단순화 → 디버깅/유지보수 용이

**Phase 2 트리거 조건**: 검색 품질 로그에서 "벡터 유사도 < 0.5인데 정답이 있는" 케이스가 반복 발견될 때

---

## 3. 검색 흐름 상세 예시

### 예시 1: "콘크리트 타설 비용 알려줘"

```
1단계 벡터: "콘크리트 타설" → 엔티티 "콘크리트 타설" (유사도 0.95)

2단계 그래프:
  ├→ REQUIRES_LABOR: 보통인부 0.122인, 콘크리트공 0.045인
  ├→ REQUIRES_EQUIPMENT: 콘크리트 바이브레이터 1대
  └→ BELONGS_TO: 제6장 콘크리트공사

3단계 구조검색:
  SELECT * FROM ilwi_items WHERE name LIKE '%콘크리트%타설%'
  → 노무비: 41,605원, 재료비: 52,300원, 합계: 93,905원

4단계 LLM:
  "콘크리트 타설 시 보통인부 0.122인, 콘크리트공 0.045인이 필요하며,
   일위대가 기준 합계 93,905원입니다. 출처: 제6장 콘크리트공사"
```

### 예시 2: "p.e관 배관 인력"

```
1단계 벡터: "p.e관 배관" → 엔티티 "PE관 배관" (유사도 0.87)
   (키워드로는 "p.e관" 매칭 실패했을 텍스트, 벡터가 처리)

2단계 그래프:
  ├→ REQUIRES_LABOR: 배관공 0.15인, 보통인부 0.03인
  └→ BELONGS_TO: 제5장 배관공사

3단계 구조검색: (비용 질문 아니므로 스킵 or 참고용 조회)

4단계 LLM:
  "PE관 배관 시 배관공 0.15인, 보통인부 0.03인이 필요합니다.
   출처: 제5장 배관공사"
```

### 예시 3: "보통인부가 필요한 공종 알려줘"

```
1단계 벡터: "보통인부" → 엔티티 "보통인부" (유사도 0.98)

2단계 그래프 (역방향 탐색):
  SELECT source_entity FROM graph_relationships
  WHERE target_entity = '보통인부' AND relation = 'REQUIRES_LABOR'
  → 콘크리트 타설, PE관 배관, 거푸집 설치, 철근 가공조립 ...

3단계: (스킵)

4단계 LLM:
  "보통인부가 필요한 공종은 콘크리트 타설(0.122인),
   PE관 배관(0.03인), 거푸집 설치(0.08인) 등이 있습니다."
```

---

## 4. 재설계된 구현 파이프라인

### 기존 계획 vs 변경 후

```
[기존]
Step 2.6: DB 스키마 + 데이터 적재 (Python)
Step 2.7: 임베딩 생성 + 검색 함수 (Python + SQL)
Step 2.8: RAG 챗봇 통합 (n8n)

[변경 후]
Step 2.6: DB 스키마 + 데이터 적재 (Python)         ← 유지
Step 2.7: 임베딩 생성 + 검색 함수 (Python + SQL)    ← 키워드 검색 보류
Step 2.8: RAG 챗봇 서빙 (Edge Function + HTML)     ← n8n → 서버리스
```

### Step 2.6: DB 스키마 + 데이터 적재

**실행 환경**: 로컬 PC 또는 Oracle Cloud A1
**예상 소요**: 2~3시간

**테이블 설계**:

```sql
-- 필수 확장 (F3 보강)
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 1. 그래프 엔티티 (품셈)
CREATE TABLE graph_entities (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  type TEXT NOT NULL,        -- WorkType, Labor, Equipment, Material, Section 등
  properties JSONB,          -- 수량, 단위, 규격 등
  source_section TEXT,       -- 출처 절 코드
  embedding vector(768),     -- gemini-embedding-001 (교체 시 1024로 ALTER)
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 2. 그래프 관계
CREATE TABLE graph_relationships (
  id SERIAL PRIMARY KEY,
  source_id TEXT REFERENCES graph_entities(id),
  target_id TEXT REFERENCES graph_entities(id),
  relation TEXT NOT NULL,    -- REQUIRES_LABOR, BELONGS_TO, REQUIRES_EQUIPMENT, HAS_NOTE, USES_MATERIAL, APPLIES_STANDARD
  properties JSONB,          -- 수량, 비율 등
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 2-1. 전역 관계 (계층/참조)
CREATE TABLE graph_global_relationships (
  id SERIAL PRIMARY KEY,
  source_id TEXT REFERENCES graph_entities(id),
  target_id TEXT REFERENCES graph_entities(id),
  relation TEXT NOT NULL,    -- HAS_CHILD, REFERENCES
  properties JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 3. 원문 청크 (RAG 참고용)
CREATE TABLE graph_chunks (
  id TEXT PRIMARY KEY,
  section_code TEXT,
  content TEXT,
  tables JSONB,
  notes JSONB,
  entity_ids TEXT[],          -- 관련 엔티티 ID 배열
  embedding vector(768),
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 4. 일위대가 구조 테이블 (기존 unit_costs에서 분리 or 뷰)
CREATE TABLE ilwi_items (
  id SERIAL PRIMARY KEY,
  ilwi_code TEXT,
  name TEXT NOT NULL,
  spec TEXT,                  -- "D80, 기계실, 고소작업대 사용"
  labor_types TEXT[],
  labor_cost NUMERIC,
  material_cost NUMERIC,
  expense_cost NUMERIC,
  total_cost NUMERIC,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 인덱스
CREATE INDEX idx_entities_embedding ON graph_entities
  USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_chunks_embedding ON graph_chunks
  USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_entities_type ON graph_entities(type);
CREATE INDEX idx_relationships_source ON graph_relationships(source_id);
CREATE INDEX idx_relationships_target ON graph_relationships(target_id);
CREATE INDEX idx_relationships_relation ON graph_relationships(relation);
CREATE INDEX idx_global_relationships_source ON graph_global_relationships(source_id);
CREATE INDEX idx_global_relationships_target ON graph_global_relationships(target_id);
CREATE INDEX idx_global_relationships_relation ON graph_global_relationships(relation);
CREATE INDEX idx_ilwi_name ON ilwi_items(name);
CREATE INDEX idx_ilwi_name_trgm ON ilwi_items USING gin (name gin_trgm_ops);

-- RLS 정책 (F3: Supabase 필수 설정)
ALTER TABLE graph_entities ENABLE ROW LEVEL SECURITY;
ALTER TABLE graph_relationships ENABLE ROW LEVEL SECURITY;
ALTER TABLE graph_global_relationships ENABLE ROW LEVEL SECURITY;
ALTER TABLE graph_chunks ENABLE ROW LEVEL SECURITY;
ALTER TABLE ilwi_items ENABLE ROW LEVEL SECURITY;

-- anon 사용자 읽기 전용 정책
CREATE POLICY "anon_read_entities" ON graph_entities FOR SELECT TO anon USING (true);
CREATE POLICY "anon_read_relationships" ON graph_relationships FOR SELECT TO anon USING (true);
CREATE POLICY "anon_read_global_relationships" ON graph_global_relationships FOR SELECT TO anon USING (true);
CREATE POLICY "anon_read_chunks" ON graph_chunks FOR SELECT TO anon USING (true);
CREATE POLICY "anon_read_ilwi" ON ilwi_items FOR SELECT TO anon USING (true);
```

**데이터 소스**:
- `graph_entities`: `normalized_entities.json` → `entities` 배열에서 추출 (Python 변환)
- `graph_relationships`: `normalized_entities.json` → **`extractions[].relationships`에 중첩** (⚠️ F6: top-level이 아님, 2,105개 extraction을 순회하며 23,586건 flat 추출 필요)
- `graph_global_relationships` (신규): `normalized_entities.json` → `global_relationships`에서 `HAS_CHILD`, `REFERENCES` 별도 적재 (총 1,063건)
- `graph_chunks`: `chunks.json` (`phase1_output/`) → Python 변환
- `ilwi_items`: `unit_costs` 테이블 (namespace='standard_price_2025') → SQL 변환

**실제 데이터 현황** (2026-02-11 검증):

| 항목      |  건수  | 비고                                                                                                                              |
| --------- | :----: | --------------------------------------------------------------------------------------------------------------------------------- |
| 총 엔티티 | 16,364 | Note(6,249), WorkType(4,531), Equipment(1,795), Material(1,667), Section(1,218), Standard(569), Labor(335)                        |
| 총 관계   | 23,586 | REQUIRES_LABOR(7,958), HAS_NOTE(6,292), BELONGS_TO(4,237), REQUIRES_EQUIPMENT(2,315), USES_MATERIAL(1,877), APPLIES_STANDARD(907) |
| 전역 관계 | 1,063  | HAS_CHILD(1,061), REFERENCES(2) → `graph_global_relationships`로 별도 관리                                                        |
| 총 청크   | ~2,105 | phase1_output/chunks.json                                                                                                         |
| 일위대가  | 6,992  | 임베딩 안 함 (구조 검색)                                                                                                          |

### Step 2.7: 임베딩 생성 + SQL 검색 함수

**실행 환경**: 로컬 PC (Gemini API 호출) 또는 Oracle Cloud A1 (KURE-v1 사용 시)
**예상 소요**: Gemini Free tier 시 ~19일 / 유료 시 1시간 / KURE-v1 CPU 시 2~3시간

**임베딩 대상** (일위대가 제외):

| 대상           |     건수      | 임베딩 텍스트 구성                   |
| -------------- | :-----------: | ------------------------------------ |
| graph_entities |   ~16,000건   | `{type}: {name} ({규격}) - {출처절}` |
| graph_chunks   |   ~2,000건    | `{section_code}: {content 요약}`     |
| **합계**       | **~18,000건** |                                      |
| ilwi_items     |    6,992건    | **임베딩 안 함**                     |

**SQL 검색 함수**:

```sql
-- 1. 벡터 검색: 시작점 엔티티 찾기
-- (F2: Edge Function에서 벡터를 text로 전달 → SQL 내부에서 ::vector 캐스팅)
CREATE OR REPLACE FUNCTION search_entities_by_embedding(
  query_embedding_text TEXT,        -- JS 배열 문자열 '[0.1, 0.2, ...]' 형태로 전달
  match_count INT DEFAULT 5,
  match_threshold FLOAT DEFAULT 0.5
)
RETURNS TABLE(id TEXT, name TEXT, type TEXT, properties JSONB, similarity FLOAT)
AS $$
  SELECT id, name, type, properties,
         1 - (embedding <=> query_embedding_text::vector) AS similarity
  FROM graph_entities
  WHERE embedding IS NOT NULL
    AND 1 - (embedding <=> query_embedding_text::vector) > match_threshold
  ORDER BY embedding <=> query_embedding_text::vector
  LIMIT match_count;
$$ LANGUAGE sql;

-- 2. 그래프 확장: 관련 자원 가져오기
-- (F4: direction 컬럼 추가로 inbound/outbound 구분)
CREATE OR REPLACE FUNCTION get_related_resources(p_entity_id TEXT)
RETURNS TABLE(
  direction TEXT, relation TEXT, related_id TEXT, related_name TEXT,
  related_type TEXT, properties JSONB
)
AS $$
  SELECT 'outbound'::TEXT AS direction,
         r.relation, e.id, e.name, e.type, r.properties
  FROM graph_relationships r
  JOIN graph_entities e ON e.id = r.target_id
  WHERE r.source_id = p_entity_id
  UNION ALL
  SELECT 'inbound'::TEXT AS direction,
         r.relation, e.id, e.name, e.type, r.properties
  FROM graph_relationships r
  JOIN graph_entities e ON e.id = r.source_id
  WHERE r.target_id = p_entity_id;
$$ LANGUAGE sql;

-- 3. 일위대가 구조 검색
CREATE OR REPLACE FUNCTION search_ilwi(
  search_name TEXT,
  search_spec TEXT DEFAULT NULL
)
RETURNS TABLE(
  name TEXT, spec TEXT, labor_cost NUMERIC,
  material_cost NUMERIC, total_cost NUMERIC
)
AS $$
  SELECT name, spec, labor_cost, material_cost, total_cost
  FROM ilwi_items
  WHERE name ILIKE '%' || search_name || '%'
    AND (search_spec IS NULL OR spec ILIKE '%' || search_spec || '%')
  ORDER BY name, spec
  LIMIT 10;
$$ LANGUAGE sql;
```

### Step 2.8: RAG 챗봇 서빙 (Edge Function + 프론트엔드)

**실행 환경**: Supabase Edge Function (Deno Runtime)
**예상 소요**: 1일

**Edge Function 로직**:

```typescript
// 의사코드 (실제 구현은 Step 2.8에서)
async function handleQuery(userQuestion: string) {
  // 1. 질문 임베딩 생성
  const queryEmbedding = await geminiEmbed(userQuestion);

  // 2. 벡터 검색 → 시작점 엔티티
  // (F2: 벡터를 JSON 문자열로 직렬화하여 text 파라미터로 전달)
  // (F2 보강: 차원/형식 검증)
  if (!Array.isArray(queryEmbedding) || queryEmbedding.length !== 768) {
    throw new Error('Invalid embedding dimension: expected 768');
  }
  if (!queryEmbedding.every((v) => Number.isFinite(v))) {
    throw new Error('Invalid embedding values: non-finite number');
  }
  const embeddingText = JSON.stringify(queryEmbedding);
  const { data: entities, error } = await supabase.rpc('search_entities_by_embedding', {
    query_embedding_text: embeddingText,
    match_count: 3
  });
  if (error) {
    // 캐스팅/함수 오류 fallback
    return await geminiGenerate(userQuestion, '검색 시스템 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');
  }

  // (F5: 빈 결과 예외 처리)
  if (!entities || entities.length === 0) {
    return await geminiGenerate(userQuestion, '관련 품셈 데이터를 찾지 못했습니다.');
  }

  // 3. 그래프 확장 → 관련 자원
  // (F4: direction 컬럼으로 inbound/outbound 구분하여 컨텍스트 구성)
  const resources = [];
  for (const entity of entities) {
    const { data: related } = await supabase.rpc('get_related_resources', {
      p_entity_id: entity.id
    });
    resources.push({ entity, related: related || [] });
  }

  // 4. 일위대가 구조 검색
  // (F5: 비용 의도 감지 후 호출, 다중 후보 시 spec 매칭으로 재랭킹)
  let ilwiResults = [];
  if (detectCostIntent(userQuestion)) {
    for (const entity of entities) {
      const { data } = await supabase.rpc('search_ilwi', {
        search_name: entity.name
      });
      if (data && data.length > 0) {
        ilwiResults.push(...data);
        break;  // 첫 번째 매칭 공종의 비용 사용
      }
    }
  }

  // 5. 컨텍스트 조합 → Gemini 답변 생성
  const context = buildContext(resources, ilwiResults);
  const answer = await geminiGenerate(userQuestion, context);

  return answer;
}
```

**프론트엔드**: 기존 `construction-chatbot-v24-webhook.html` 수정
- Webhook URL을 n8n → Edge Function URL로 변경
- 기존 UI/UX 유지

---

## 5. Codex 검토 반영 사항

### 검토 출처: `20260211_codex_Step2.6이후_전면재검토_검토결과.md`

| #   | 지적 사항                                              | 심각도 | 반영 상태 | 반영 위치                                                                 |
| --- | ------------------------------------------------------ | :----: | :-------: | ------------------------------------------------------------------------- |
| F1  | 관계 타입 `USES_EQUIPMENT` → `REQUIRES_EQUIPMENT` 통일 |  High  |  ✅ 반영   | DDL 주석 (§4 테이블 설계)                                                 |
| F2  | pgvector RPC 파라미터 text 래퍼 필요                   |  High  |  ✅ 반영   | `search_entities_by_embedding` 함수 시그니처 변경 (§4 SQL 함수)           |
| F3  | Supabase 확장/RLS 정책 누락                            |  High  |  ✅ 반영   | DDL에 RLS ENABLE + anon 읽기 정책 추가 (§4 테이블 설계)                   |
| F4  | 그래프 확장 함수 방향 정보 손실                        | Medium |  ✅ 반영   | `get_related_resources`에 `direction` 컬럼 추가 (§4 SQL 함수)             |
| F5  | 일위대가 검색 호출 조건 단순화 + 빈 결과 예외          | Medium |  ✅ 반영   | Edge Function 의사코드에 `detectCostIntent` + fallback 추가 (§4 Step 2.8) |

### 추가 발견 (데이터 구조 검증)

| #   | 발견                       |  심각도  | 내용                                                                                                                                        |
| --- | -------------------------- | :------: | ------------------------------------------------------------------------------------------------------------------------------------------- |
| F6  | 관계 데이터 중첩 구조      | **High** | 관계가 top-level `relationships`가 아닌 **`extractions[].relationships`에 중첩**. 2,105개 extraction을 순회하며 23,586건을 flat 추출해야 함 |
| F7  | Note `properties` 비어있음 |   Low    | 주석 본문이 `name` 필드에만 존재. 임베딩 시 `name`을 그대로 사용                                                                            |
| F8  | `HAS_NOTE` 관계 정상       |   Info   | Note↔WorkType 연결이 6,292건으로 정상 작동. 초기 "고립" 판단은 데이터 구조 파악 오류                                                        |

---

## 6. 리스크 및 대응 전략

| 리스크                                  | 확률  | 영향  | 대응                                    |
| --------------------------------------- | :---: | :---: | --------------------------------------- |
| Gemini 임베딩 한국어 품질 부족          |  중   |  중   | KURE-v1 교체 (코드 10분 + 재생성 3시간) |
| 벡터 검색만으로 시작점 못 찾는 케이스   |  하   |  중   | pg_trgm 키워드 검색 추가 (SQL 1줄)      |
| Edge Function Free tier 제한            |  하   |  하   | 50만 호출/월 → 충분                     |
| Oracle Cloud A1 리소스 부족 (임베딩 시) |  하   |  하   | 오픈클로 봇 잠시 중지 후 실행           |
| 일위대가 name 매칭 실패                 |  중   |  중   | pg_trgm 유사도 + ILIKE 패턴 병행        |

---

## 7. 비용 분석

| 항목                                 |        비용        |
| ------------------------------------ | :----------------: |
| Supabase Free Plan                   |       **$0**       |
| Gemini API (임베딩 18K건, 유료 tier) |     **$0.31**      |
| Gemini API (Free tier, 하루 1000건)  | **$0** (19일 소요) |
| KURE-v1 (교체 시)                    |       **$0**       |
| Oracle Cloud A1 (기존 인스턴스)      |       **$0**       |
| Cloudflare Pages (프론트엔드)        |       **$0**       |
| **총합**                             |   **$0 ~ $0.31**   |

---

## 8. 실행 일정

|   단계   | 작업                             |       예상 소요       | 의존성                |
| :------: | -------------------------------- | :-------------------: | --------------------- |
| **2.6**  | DB 스키마 생성 + 데이터 적재     |        2~3시간        | 없음 (즉시 시작 가능) |
| **2.7**  | 임베딩 생성 + SQL 검색 함수 배포 | 1~3시간 (모델에 따라) | Step 2.6 완료         |
| **2.8**  | Edge Function + 프론트엔드       |          1일          | Step 2.7 완료         |
| **검증** | E2E 테스트 + 검색 품질 평가      |        반나절         | Step 2.8 완료         |
|          | **총합**                         |     **약 2~3일**      |                       |

---

## 9. Phase 2 확정 판단 (미래 확장)

Phase 1 완료 후 검색 품질 로그를 분석하여 다음 판단:

| 조건                            | 조치                         |
| ------------------------------- | ---------------------------- |
| 벡터 유사도 < 0.5인데 정답 존재 | 키워드 검색(pg_trgm) 추가    |
| 한국어 건설 용어 매칭 부정확    | KURE-v1으로 임베딩 모델 교체 |
| 일위대가 name 매칭 부정확       | 동의어 사전 테이블 추가      |
| 응답 속도 느림                  | HNSW 인덱스 파라미터 튜닝    |

---

## 변경 이력

| 날짜       |  버전  | 변경 내용                                                                                                                                                                      |
| ---------- | :----: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 2026-02-11 |   v1   | 초안 작성 (후보 비교 중심)                                                                                                                                                     |
| 2026-02-11 |   v2   | 최종 확정: Supabase 단일 저장소, gemini-embedding-001, n8n 제거 → Edge Function, 일위대가 구조 검색, 벡터+그래프 검색 확정                                                     |
| 2026-02-11 | **v3** | **Codex 검토 반영**: F1~F5 수정(관계 타입 통일, 벡터 RPC 래퍼, RLS 정책, 방향 컬럼, 예외 처리) + F6~F8 데이터 구조 검증(관계 중첩 구조, Note 연결 확인, 실제 데이터 현황 추가) |

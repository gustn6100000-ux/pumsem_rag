# Step 2.6 DB 스키마 + 데이터 적재 상세 구현계획서

> **작성일**: 2026-02-11
> **기반 문서**: `20260211_Step2.6이후_전면재검토_설계보고서.md` (v3)
> **예상 소요**: 2~3시간
> **실행 환경**: 로컬 PC (Python 3.12+)

---

## 1. 작업 목표

`normalized_entities.json`, `chunks.json`, `unit_costs` 테이블의 데이터를 Supabase PostgreSQL에 5개 테이블로 적재한다.

```
┌──────────────────────────────┐
│ 입력 데이터                    │
├──────────────────────────────┤
│ normalized_entities.json      │
│   ├─ entities[]       → 16,364건 → graph_entities
│   ├─ extractions[]    → 2,105개 → 23,586건 관계 flat 추출 → graph_relationships
│   └─ global_relationships{} → 1,063건 → graph_global_relationships
│                               │
│ chunks.json                   │
│   └─ chunks[]         → 2,105건 → graph_chunks
│                               │
│ unit_costs 테이블              │
│   └─ namespace='standard_price_2025' → 6,992건 → ilwi_items (SQL 변환)
└──────────────────────────────┘
```

---

## 2. 사전 조건 (Pre-requisites)

### 2.1 환경 확인

| 항목              | 확인 방법                                            | 상태        |
| ----------------- | ---------------------------------------------------- | ----------- |
| Python 3.12+      | `python --version`                                   | ✅           |
| supabase-py 설치  | `pip install supabase`                               | ⬜ 설치 필요 |
| Supabase 프로젝트 | project_id: `jmhfbhpfeffkjfigdikl`                   | ✅ 확인됨    |
| pgvector 확장     | `SELECT * FROM pg_extension WHERE extname='vector'`  | ✅ 활성화    |
| pg_trgm 확장      | `SELECT * FROM pg_extension WHERE extname='pg_trgm'` | ✅ 활성화    |

### 2.2 입력 파일 경로

```
G:\내 드라이브\Antigravity\python_code\
├── phase2_output\
│   └── normalized_entities.json    ← 엔티티 + 관계 + 전역관계
└── phase1_output\
    └── chunks.json                 ← 원문 청크
```

---

## 3. DDL (테이블 생성)

### 실행 방법: Supabase SQL Editor 또는 MCP `apply_migration` 사용

```sql
-- ═══════════════════════════════════════════════════════
-- Step 2.6 Migration: 그래프 RAG 테이블 생성
-- ═══════════════════════════════════════════════════════

-- 필수 확장
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- ───────────────────────────────────────────
-- 1. graph_entities (품셈 엔티티)
-- ───────────────────────────────────────────
CREATE TABLE graph_entities (
  id TEXT PRIMARY KEY,                    -- 예: "E-0001", "W-3526", "L-0249"
  name TEXT NOT NULL,                     -- 엔티티 이름
  type TEXT NOT NULL,                     -- WorkType, Labor, Equipment, Material, Section, Note, Standard
  properties JSONB DEFAULT '{}',          -- spec, unit, quantity, confidence 등
  source_section TEXT,                    -- 출처 절 코드 (예: "8-3-10")
  embedding vector(768),                 -- gemini-embedding-001 (Step 2.7에서 채움)
  created_at TIMESTAMPTZ DEFAULT now()
);

-- ───────────────────────────────────────────
-- 2. graph_relationships (추출 관계)
-- ───────────────────────────────────────────
CREATE TABLE graph_relationships (
  id SERIAL PRIMARY KEY,
  source_id TEXT NOT NULL REFERENCES graph_entities(id),
  target_id TEXT NOT NULL REFERENCES graph_entities(id),
  relation TEXT NOT NULL,                 -- REQUIRES_LABOR, BELONGS_TO, REQUIRES_EQUIPMENT,
                                          -- HAS_NOTE, USES_MATERIAL, APPLIES_STANDARD
  properties JSONB DEFAULT '{}',          -- quantity, unit, per_unit 등
  source_chunk_id TEXT,                   -- 출처 청크 ID
  created_at TIMESTAMPTZ DEFAULT now()
);

-- ───────────────────────────────────────────
-- 2-1. graph_global_relationships (계층/참조)
-- ───────────────────────────────────────────
CREATE TABLE graph_global_relationships (
  id SERIAL PRIMARY KEY,
  source_id TEXT NOT NULL REFERENCES graph_entities(id),
  target_id TEXT NOT NULL REFERENCES graph_entities(id),
  relation TEXT NOT NULL,                 -- HAS_CHILD, REFERENCES
  properties JSONB DEFAULT '{}',          -- parent_id, child_id, level 등
  created_at TIMESTAMPTZ DEFAULT now()
);

-- ───────────────────────────────────────────
-- 3. graph_chunks (원문 청크)
-- ───────────────────────────────────────────
CREATE TABLE graph_chunks (
  id TEXT PRIMARY KEY,                    -- 예: "C-0001"
  section_id TEXT,                        -- 절 코드 (예: "1-1-1")
  title TEXT,                             -- 청크 제목
  department TEXT,                        -- 부문명
  chapter TEXT,                           -- 장명
  section TEXT,                           -- 절명
  text TEXT,                              -- 본문 텍스트
  tables JSONB,                           -- 표 데이터
  notes JSONB,                            -- 주석 데이터
  conditions JSONB,                       -- 조건 데이터
  cross_references JSONB,                 -- 교차 참조
  revision_year TEXT,                     -- 개정 연도
  token_count INT,                        -- 토큰 수
  embedding vector(768),                  -- Step 2.7에서 채움
  created_at TIMESTAMPTZ DEFAULT now()
);

-- ───────────────────────────────────────────
-- 4. ilwi_items (일위대가)
-- ───────────────────────────────────────────
CREATE TABLE ilwi_items (
  id SERIAL PRIMARY KEY,
  ilwi_code TEXT,                         -- 원본 코드
  name TEXT NOT NULL,                     -- 공종명
  spec TEXT,                              -- 규격 ("D80, 기계실")
  labor_types TEXT[],                     -- 관련 노무 직종
  labor_cost NUMERIC,                     -- 노무비
  material_cost NUMERIC,                  -- 재료비
  expense_cost NUMERIC,                   -- 경비
  total_cost NUMERIC,                     -- 합계
  source_id TEXT,                         -- 원본 unit_costs.id
  created_at TIMESTAMPTZ DEFAULT now()
);

-- ═══════════════════════════════════════════════════════
-- 인덱스
-- ═══════════════════════════════════════════════════════
CREATE INDEX idx_entities_embedding ON graph_entities USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_entities_type ON graph_entities(type);
CREATE INDEX idx_entities_name_trgm ON graph_entities USING gin (name gin_trgm_ops);

CREATE INDEX idx_rel_source ON graph_relationships(source_id);
CREATE INDEX idx_rel_target ON graph_relationships(target_id);
CREATE INDEX idx_rel_relation ON graph_relationships(relation);

CREATE INDEX idx_global_rel_source ON graph_global_relationships(source_id);
CREATE INDEX idx_global_rel_target ON graph_global_relationships(target_id);
CREATE INDEX idx_global_rel_relation ON graph_global_relationships(relation);

CREATE INDEX idx_chunks_embedding ON graph_chunks USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_chunks_section ON graph_chunks(section_id);

CREATE INDEX idx_ilwi_name ON ilwi_items(name);
CREATE INDEX idx_ilwi_name_trgm ON ilwi_items USING gin (name gin_trgm_ops);

-- ═══════════════════════════════════════════════════════
-- RLS 정책
-- ═══════════════════════════════════════════════════════
ALTER TABLE graph_entities ENABLE ROW LEVEL SECURITY;
ALTER TABLE graph_relationships ENABLE ROW LEVEL SECURITY;
ALTER TABLE graph_global_relationships ENABLE ROW LEVEL SECURITY;
ALTER TABLE graph_chunks ENABLE ROW LEVEL SECURITY;
ALTER TABLE ilwi_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "anon_read" ON graph_entities FOR SELECT TO anon USING (true);
CREATE POLICY "anon_read" ON graph_relationships FOR SELECT TO anon USING (true);
CREATE POLICY "anon_read" ON graph_global_relationships FOR SELECT TO anon USING (true);
CREATE POLICY "anon_read" ON graph_chunks FOR SELECT TO anon USING (true);
CREATE POLICY "anon_read" ON ilwi_items FOR SELECT TO anon USING (true);
```

---

## 4. Python 로더 설계

### 4.1 파일: `step6_supabase_loader.py`

```
위치: G:\내 드라이브\Antigravity\python_code\phase2_extraction\step6_supabase_loader.py
```

### 4.2 필드 매핑

#### 4.2.1 Entity → `graph_entities`

| JSON 필드 (`entities[]`)                                            | DB 컬럼          | 변환                          |
| ------------------------------------------------------------------- | ---------------- | ----------------------------- |
| `entity_id`                                                         | `id`             | 그대로 (예: "E-0001")         |
| `name`                                                              | `name`           | 그대로                        |
| `type`                                                              | `type`           | 그대로 (WorkType, Labor, ...) |
| `spec`, `unit`, `quantity`, `confidence`, `code`, `normalized_name` | `properties`     | JSONB로 병합                  |
| `source_section_id`                                                 | `source_section` | 그대로 (예: "8-3-10")         |
| —                                                                   | `embedding`      | NULL (Step 2.7에서 채움)      |

**변환 코드 (의사코드)**:

```python
def entity_to_row(e: dict) -> dict:
    """normalized_entities.json의 entity를 graph_entities 행으로 변환"""
    properties = {}
    for key in ['spec', 'unit', 'quantity', 'confidence', 'code', 'normalized_name',
                 'source_method', 'source_chunk_ids']:
        val = e.get(key)
        if val is not None:
            properties[key] = val
    # properties 필드의 내용도 병합
    if e.get('properties'):
        properties.update(e['properties'])

    return {
        'id': e['entity_id'],
        'name': e['name'],
        'type': e['type'],
        'properties': properties,
        'source_section': e.get('source_section_id'),
    }
```

#### 4.2.2 Extraction.relationships → `graph_relationships`

| JSON 필드 (`extractions[].relationships[]`) | DB 컬럼           | 변환                       |
| ------------------------------------------- | ----------------- | -------------------------- |
| `source_entity_id`                          | `source_id`       | 그대로                     |
| `target_entity_id`                          | `target_id`       | 그대로                     |
| `type`                                      | `relation`        | 그대로 (REQUIRES_LABOR 등) |
| `quantity`, `unit`, `per_unit`              | `properties`      | JSONB로 병합               |
| `source_chunk_id`                           | `source_chunk_id` | 그대로                     |

**⚠️ 핵심: 관계는 top-level이 아닌 `extractions[].relationships[]`에 중첩**

```python
def extract_all_relationships(data: dict) -> list[dict]:
    """extractions[]를 순회하며 관계를 flat 추출"""
    rows = []
    # F1 반영: dedup 키를 6-tuple로 확장 (quantity/unit/per_unit이 다른 관계 보존)
    seen = set()

    for extraction in data['extractions']:        # 2,105개 순회
        for rel in extraction.get('relationships', []):
            qty = rel.get('quantity')
            unit = rel.get('unit')
            per_unit = rel.get('per_unit')
            key = (
                rel['source_entity_id'],
                rel['target_entity_id'],
                rel['type'],
                qty, unit, per_unit,       # ← 조건별 수량이 다른 관계 보존
            )
            if key in seen:
                continue
            seen.add(key)

            properties = {}
            for k in ['quantity', 'unit', 'per_unit']:
                v = rel.get(k)
                if v is not None:
                    properties[k] = v
            if rel.get('properties'):
                properties.update(rel['properties'])

            rows.append({
                'source_id': rel['source_entity_id'],
                'target_id': rel['target_entity_id'],
                'relation': rel['type'],
                'properties': properties,
                'source_chunk_id': rel.get('source_chunk_id'),
            })

    return rows  # 기대: ~23,586건 + 조건별 변형분 추가
```

#### 4.2.3 global_relationships → `graph_global_relationships`

| JSON 필드          | DB 컬럼      | 변환                           |
| ------------------ | ------------ | ------------------------------ |
| `source_entity_id` | `source_id`  | 그대로                         |
| `target_entity_id` | `target_id`  | 그대로                         |
| `type`             | `relation`   | 그대로 (HAS_CHILD, REFERENCES) |
| `properties`       | `properties` | 그대로                         |

**구조 주의: `global_relationships`는 dict(key=관계타입, value=리스트)**

```python
def extract_global_relationships(data: dict) -> list[dict]:
    """global_relationships{HAS_CHILD: [...], REFERENCES: [...]}를 flat 추출"""
    rows = []
    gr = data.get('global_relationships', {})

    for rel_type, rel_list in gr.items():       # HAS_CHILD, REFERENCES
        for rel in rel_list:
            rows.append({
                'source_id': rel['source_entity_id'],
                'target_id': rel['target_entity_id'],
                'relation': rel['type'],        # == rel_type
                'properties': rel.get('properties', {}),
            })

    return rows  # 기대: 1,063건
```

#### 4.2.4 chunks → `graph_chunks`

| JSON 필드 (`chunks[]`) | DB 컬럼            | 변환                  |
| ---------------------- | ------------------ | --------------------- |
| `chunk_id`             | `id`               | 그대로 (예: "C-0001") |
| `section_id`           | `section_id`       | 그대로 (예: "1-1-1")  |
| `title`                | `title`            | 그대로                |
| `department`           | `department`       | 그대로                |
| `chapter`              | `chapter`          | 그대로                |
| `section`              | `section`          | 그대로                |
| `text`                 | `text`             | 그대로                |
| `tables`               | `tables`           | JSONB                 |
| `notes`                | `notes`            | JSONB                 |
| `conditions`           | `conditions`       | JSONB                 |
| `cross_references`     | `cross_references` | JSONB                 |
| `revision_year`        | `revision_year`    | 그대로                |
| `token_count`          | `token_count`      | 그대로                |

```python
def chunk_to_row(c: dict) -> dict:
    return {
        'id': c['chunk_id'],
        'section_id': c.get('section_id'),
        'title': c.get('title'),
        'department': c.get('department'),
        'chapter': c.get('chapter'),
        'section': c.get('section'),
        'text': c.get('text'),
        'tables': c.get('tables'),
        'notes': c.get('notes'),
        'conditions': c.get('conditions'),
        'cross_references': c.get('cross_references'),
        'revision_year': c.get('revision_year'),
        'token_count': c.get('token_count'),
    }
```

#### 4.2.5 ilwi_items (SQL 변환)

```sql
-- unit_costs → ilwi_items 변환 (Supabase SQL Editor에서 실행)
INSERT INTO ilwi_items (ilwi_code, name, spec, labor_types, labor_cost, material_cost, expense_cost, total_cost, source_id)
SELECT
  metadata->>'ilwi_code' AS ilwi_code,
  name,
  metadata->>'spec' AS spec,
  CASE
    WHEN metadata->'labor_types' IS NOT NULL
    THEN ARRAY(SELECT jsonb_array_elements_text(metadata->'labor_types'))
    ELSE NULL
  END AS labor_types,
  -- F4 반영: NULLIF로 빈 문자열 안전 처리
  NULLIF(metadata->>'labor_cost', '')::NUMERIC AS labor_cost,
  NULLIF(metadata->>'material_cost', '')::NUMERIC AS material_cost,
  NULLIF(metadata->>'expense_cost', '')::NUMERIC AS expense_cost,
  NULLIF(metadata->>'total_cost', '')::NUMERIC AS total_cost,
  id::TEXT AS source_id
FROM unit_costs
WHERE namespace = 'standard_price_2025';
```

---

## 5. 로더 실행 흐름

```
Phase 1: DDL 실행
  └─ Supabase SQL Editor / MCP apply_migration
  └─ 5개 테이블 + 인덱스 + RLS 생성

Phase 2: 엔티티 적재 (Python)
  └─ normalized_entities.json → entities[] → graph_entities
  └─ 배치 크기: 500건씩 upsert (TEXT PK → 충돌 시 갱신)
  └─ 기대: 16,364건

Phase 3: 관계 적재 (Python)  ⚠️ F2 반영: insert 사용 (upsert 아님)
  └─ normalized_entities.json → extractions[].relationships[] → flat 추출
  └─ 중복 제거: 6-tuple (source_id + target_id + relation + quantity + unit + per_unit)
  └─ FK 검증: source_id, target_id가 graph_entities에 존재하는지 확인
  └─ 존재하지 않는 FK는 skip + 로그 기록
  └─ graph_relationships에 배치 **insert** (SERIAL PK → upsert 충돌 기준 없음)
  └─ 기대: ~23,586건 + 조건별 변형분

Phase 4: 전역 관계 적재 (Python)  ⚠️ F2 반영: insert 사용
  └─ normalized_entities.json → global_relationships{} → flat 추출
  └─ graph_global_relationships에 배치 **insert**
  └─ 기대: 1,063건

Phase 5: 청크 적재 (Python)
  └─ chunks.json → chunks[] → graph_chunks
  └─ 배치 크기: 200건씩 upsert (TEXT PK → 충돌 시 갱신)
  └─ 기대: 2,105건

Phase 6: 일위대가 적재 (SQL)
  └─ unit_costs 테이블에서 SQL INSERT ... SELECT (NULLIF 안전 캐스팅)
  └─ 기대: 6,992건
```

### 5.1 배치 업로드 유틸리티

```python
# F2 반영: upsert / insert 분리
def batch_upsert(supabase_client, table: str, rows: list[dict], batch_size: int = 500):
    """TEXT PK 테이블용 — graph_entities, graph_chunks"""
    total = len(rows)
    success = 0
    errors = []
    for i in range(0, total, batch_size):
        batch = rows[i:i + batch_size]
        try:
            supabase_client.table(table).upsert(batch).execute()
            success += len(batch)
            print(f"  [{table}] {success}/{total} upsert 완료")
        except Exception as e:
            errors.append({'batch_start': i, 'error': str(e)})
            print(f"  [{table}] 배치 {i}~{i+len(batch)} 실패: {e}")
    return {'total': total, 'success': success, 'errors': errors}

def batch_insert(supabase_client, table: str, rows: list[dict], batch_size: int = 500):
    """SERIAL PK 테이블용 — graph_relationships, graph_global_relationships
       사전에 Python dedup 완료된 데이터만 전달할 것"""
    total = len(rows)
    success = 0
    errors = []
    for i in range(0, total, batch_size):
        batch = rows[i:i + batch_size]
        try:
            supabase_client.table(table).insert(batch).execute()
            success += len(batch)
            print(f"  [{table}] {success}/{total} insert 완료")
        except Exception as e:
            errors.append({'batch_start': i, 'error': str(e)})
            print(f"  [{table}] 배치 {i}~{i+len(batch)} 실패: {e}")
    return {'total': total, 'success': success, 'errors': errors}
```

### 5.2 FK 검증 (관계 적재 전)

```python
def validate_fk(entity_ids: set, relationships: list[dict]) -> tuple[list, list]:
    """관계의 source_id, target_id가 엔티티에 존재하는지 검증"""
    valid = []
    orphaned = []

    for rel in relationships:
        src = rel['source_id']
        tgt = rel['target_id']
        if src in entity_ids and tgt in entity_ids:
            valid.append(rel)
        else:
            orphaned.append({
                'source_id': src,
                'target_id': tgt,
                'relation': rel['relation'],
                'missing': 'source' if src not in entity_ids else 'target',
            })

    return valid, orphaned
```

---

## 6. 검증 쿼리

적재 완료 후 실행할 검증 쿼리:

```sql
-- 6.1 건수 검증
SELECT 'graph_entities' AS tbl, COUNT(*) FROM graph_entities
UNION ALL
SELECT 'graph_relationships', COUNT(*) FROM graph_relationships
UNION ALL
SELECT 'graph_global_relationships', COUNT(*) FROM graph_global_relationships
UNION ALL
SELECT 'graph_chunks', COUNT(*) FROM graph_chunks
UNION ALL
SELECT 'ilwi_items', COUNT(*) FROM ilwi_items;

-- 기대 결과:
-- graph_entities:             16,364
-- graph_relationships:        ~23,586 (중복 제거 + FK 오류 제외 시 소폭 감소 가능)
-- graph_global_relationships: 1,063
-- graph_chunks:               2,105
-- ilwi_items:                 6,992

-- 6.2 엔티티 타입별 건수
SELECT type, COUNT(*) FROM graph_entities GROUP BY type ORDER BY COUNT(*) DESC;

-- 기대:
-- Note: 6,249 | WorkType: 4,531 | Equipment: 1,795 | Material: 1,667
-- Section: 1,218 | Standard: 569 | Labor: 335

-- 6.3 관계 타입별 건수
SELECT relation, COUNT(*) FROM graph_relationships GROUP BY relation ORDER BY COUNT(*) DESC;

-- 기대:
-- REQUIRES_LABOR: 7,958 | HAS_NOTE: 6,292 | BELONGS_TO: 4,237
-- REQUIRES_EQUIPMENT: 2,315 | USES_MATERIAL: 1,877 | APPLIES_STANDARD: 907

-- 6.4 전역 관계 타입별 건수
SELECT relation, COUNT(*) FROM graph_global_relationships GROUP BY relation;

-- 기대:
-- HAS_CHILD: 1,061 | REFERENCES: 2

-- 6.5 Orphaned FK 없는지 확인
SELECT COUNT(*) AS orphaned_source
FROM graph_relationships r
LEFT JOIN graph_entities e ON e.id = r.source_id
WHERE e.id IS NULL;

SELECT COUNT(*) AS orphaned_target
FROM graph_relationships r
LEFT JOIN graph_entities e ON e.id = r.target_id
WHERE e.id IS NULL;

-- 기대: 둘 다 0

-- 6.6 일위대가 Name 분포 (Top 10)
SELECT name, COUNT(*) FROM ilwi_items GROUP BY name ORDER BY COUNT(*) DESC LIMIT 10;

-- 6.7 임베딩 NULL 확인 (Step 2.7 전이므로 전부 NULL이어야 함)
SELECT COUNT(*) AS null_embeddings FROM graph_entities WHERE embedding IS NULL;
-- 기대: 16,364 (전부)
```

---

## 7. 에러 시나리오 & 대응

| 시나리오                        | 감지 방법          | 대응                       |
| ------------------------------- | ------------------ | -------------------------- |
| FK 위반 (관계의 entity_id 없음) | Python FK 검증     | 해당 관계 skip + 로그 저장 |
| 중복 entity_id                  | upsert로 자동 처리 | 마지막 데이터 우선         |
| JSONB 필드 크기 초과            | Supabase 에러 로그 | text로 변환하거나 분할     |
| 배치 크기 초과 (HTTP 413)       | HTTP 에러          | batch_size 줄임 (500→200)  |
| 일위대가 metadata 필드 누락     | NULL 값            | COALESCE로 기본값 처리     |

---

## 8. 실행 순서 체크리스트

```
□ 1. Python 환경 준비
    □ pip install supabase python-dotenv
    □ .env 파일에 SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY 설정
      ⚠️ F3 반영: RLS 활성화 환경에서 INSERT는 service_role 권한 필요
      ⚠️ anon key 사용 시 INSERT 실패함

□ 2. DDL 실행
    □ 5개 테이블 생성
    □ 인덱스 생성
    □ RLS 정책 생성

□ 3. 엔티티 적재
    □ 16,364건 upsert
    □ 타입별 건수 검증

□ 4. 관계 적재
    □ extractions[] flat 추출
    □ FK 검증 → orphaned 로그
    □ ~23,586건 insert
    □ 관계 타입별 건수 검증

□ 5. 전역 관계 적재
    □ global_relationships{} flat 추출
    □ 1,063건 insert

□ 6. 청크 적재
    □ 2,105건 upsert
    □ section_id 분포 확인

□ 7. 일위대가 적재
    □ SQL INSERT ... SELECT 실행
    □ 6,992건 확인

□ 8. 전체 검증
    □ 건수 검증 쿼리 실행
    □ Orphaned FK 0건 확인
    □ 임베딩 전부 NULL 확인
```

---

## 9. 예상 시간

| 단계              |    소요 시간     |
| ----------------- | :--------------: |
| DDL 실행          |       5분        |
| 엔티티 적재       |     10~15분      |
| 관계 적재         |     15~20분      |
| 전역 관계 적재    |       2분        |
| 청크 적재         |     10~15분      |
| 일위대가 SQL 변환 |       5분        |
| 검증              |       10분       |
| **합계**          | **약 1~1.5시간** |

나머지 1시간은 예상치 못한 에러 대응 + 디버깅 버퍼.

# Step 2.7 임베딩 생성 + SQL 검색 함수 — 상세 구현계획서

> **작성일**: 2026-02-11
> **선행 단계**: Step 2.6 (DB 적재 완료, 50,110건, 에러 0건)
> **산출물**: `step7_embedding_generator.py`, `step2.7_create_search_functions.sql`
> **예상 소요**: 로컬 PC 기준 약 1~2시간 (유료 Gemini API)

---

## 1. 목표

| #   | 목표               | 상세                                                                                                        |
| --- | ------------------ | ----------------------------------------------------------------------------------------------------------- |
| 1   | 임베딩 생성        | `graph_entities` 16,364건 + `graph_chunks` 2,105건 → 총 **18,469건**에 768차원 벡터 생성                    |
| 2   | SQL 검색 함수 배포 | `search_entities_by_embedding`, `get_related_resources`, `get_entity_hierarchy`, `search_ilwi` 4개 RPC 함수 |
| 3   | 데이터 무결성 보장 | 임베딩 전/후 건수 일치 검증, NULL 잔존 0건 확인                                                             |

---

## 2. 전제 조건

| 항목        | 값                                   | 비고                                         |
| ----------- | ------------------------------------ | -------------------------------------------- |
| 임베딩 모델 | `gemini-embedding-001`               | 768~3,072차원 선택 가능 (Matryoshka)         |
| 출력 차원   | **768**                              | DDL의 `vector(768)` 컬럼과 일치 필수         |
| API 키      | `.env`의 `GEMINI_API_KEY`            | 유료 플랜: 1,500 RPM, 4M TPM                 |
| Python SDK  | `google-genai`                       | `google-generativeai` 아닌 **신규 SDK** 사용 |
| 대상 DB     | `bfomacoarwtqzjfxszdr` (pumsem)      | Step 2.6에서 적재 완료                       |
| Supabase 키 | `.env`의 `SUPABASE_SERVICE_ROLE_KEY` | RLS 우회용 service_role 키                   |

### 2.1 Rate Limit 산출

```
API 유형:      Gemini Billing ON (RPM 1,500 한도)

[RPM 산출]
  embed_content API는 1회 호출 = 1 RPM 소비 (배치든 단건이든 동일)
  배치 크기 100건 → 18,469건 ÷ 100 = 185 배치
  1,500 RPM → 1초당 최대 25 배치 (1,500 ÷ 60)
  185 배치 ÷ 25 배치/초 = 7.4초 (이론 최소)

  실제 소요 = API 레이턴시(~0.3초/배치) + 네트워크 오버헤드 + Supabase UPDATE
  185 배치 × (0.3초 API + 0.1초 UPDATE + 0.1초 여유) = ~93초 ≈ 1.5분 (이론)

  안전 마진 적용:
    - 재시도/backoff 가능성: ×2
    - Supabase UPDATE 대기: 100건 당 ~0.2초
    → 보수적 예상: 15~25분
    → 최악(빈번한 429): ~50분

[TPM 산출]
  엔티티 평균 토큰: ~20 (이름 12자 + type 프리픽스 + spec)
  청크 평균 토큰:   ~150 (메타 60자 + text 110자, 한글 1자 ≈ 1.5토큰)
  총 토큰: 16,364×20 + 2,105×150 = 327,280 + 315,750 = 643,030 토큰
  643,030 < 4,000,000 TPM → TPM 병목 없음

[결론]
  병목: RPM (API 레이턴시 + UPDATE 대기)
  예상 소요: 15~25분 (보수적), 최대 50분 (빈번한 429 시)
```

### 2.2 비용 산출

```
모델:                 gemini-embedding-001

[중요] "유료 플랜"과 "임베딩 비용"은 별개 개념:
  - "유료 플랜" = Google Cloud 프로젝트의 Billing 활성화 상태
    → Billing 활성화 시 RPM 한도가 15→1,500으로 상향됨
  - "임베딩 비용" = gemini-embedding-001 모델의 API 호출 과금
    → 현재 Google은 임베딩 API를 무료로 제공 (per-token 과금 없음)
    → 참조: https://ai.google.dev/gemini-api/docs/pricing

결론:
  - Billing 활성화 필요 (RPM 한도 확보 목적)
  - 임베딩 API 자체 비용은 $0.00
  - 다만, Google 가격 정책은 변동 가능하므로 실행 직전 재확인 필요
총 비용 예상:         $0.00 (2026-02-11 기준)
```

### 2.3 Free Tier vs 유료 플랜 Rate Limit 비교

```
                 Free tier         유료(Billing ON)
  RPM:           15                1,500
  TPM:           1,000,000         4,000,000
  RPD:           1,500             무제한

Free tier 소요:
  18,469건 ÷ 1,500 RPD = 12.3일 (비현실적)

유료 플랜 소요:
  185 배치(100건) → 185 ÷ (1,500 RPM ÷ 60초) = 185 ÷ 25 = 총 7.4초 (이론 최소)
  실제: API 레이턴시 + Supabase UPDATE 포함 → 보수적 15~25분, 최대 50분
```

---

## 3. 데이터 사전 조사 결과

### 3.1 엔티티 텍스트 길이 분포

Supabase에서 직접 조회한 실측 데이터:

| 타입      | 건수  | 평균 name 길이 | 최대 name 길이 | 평균 properties 길이 |
| --------- | :---: | :------------: | :------------: | :------------------: |
| Note      | 6,249 |     12.3자     |      68자      |       162.8자        |
| WorkType  | 4,531 |     13.9자     |     128자      |       153.8자        |
| Equipment | 1,795 |     9.4자      |      53자      |       149.6자        |
| Material  | 1,667 |     8.0자      |     122자      |       152.2자        |
| Section   | 1,218 |     9.8자      |      36자      |       188.5자        |
| Standard  |  569  |     12.9자     |      49자      |       144.3자        |
| Labor     |  335  |     7.5자      |      60자      |       261.4자        |

### 3.2 청크 텍스트 길이 분포

| 항목             |      값      |
| ---------------- | :----------: |
| 총 건수          |    2,105     |
| text 있음        | 2,105 (100%) |
| 평균 text 길이   |   110.7자    |
| 최대 text 길이   |   2,816자    |
| 평균 token_count |     762      |
| 최대 token_count |    3,536     |
| tables 있음      | 2,105 (100%) |

### 3.3 임베딩 입력 텍스트 구성 전략

| 대상               | 임베딩 텍스트 템플릿                                  | 예시                                                    |
| ------------------ | ----------------------------------------------------- | ------------------------------------------------------- |
| **graph_entities** | `{type}: {name}` + properties에서 `spec`, `unit` 추가 | `WorkType: Control Air 배관(Screw형) [규격: 20A]`       |
| **graph_chunks**   | `{department} {chapter} {section}: {title}\n{text}`   | `공통부문 제1장 적용기준 1-1-3: 적용방법\n본 품셈은...` |

**설계 근거:**

1. **엔티티**: `type`을 프리픽스로 추가하여 동명이인(異名) 구분. 예: `Equipment: 크레인` vs `WorkType: 크레인 설치`. `spec`이 있을 경우 `[규격: ...]`으로 부가하여 검색 정밀도 향상.
2. **청크**: 계층 정보(`department` → `chapter` → `section` → `title`)를 프리픽스로 붙여 검색 시 분류 맥락 제공. `text`가 2,816자까지 존재하지만, Gemini embedding의 최대 입력 토큰은 8,192이므로 truncation 불필요.
3. **`ilwi_items`는 임베딩 안 함**: 키워드 기반 ILIKE 검색으로 충분하며(name, spec 필드 탐색), 임베딩 비용을 절감.

### 3.4 임베딩 텍스트 길이 예상

```
엔티티:
  평균: ~30자 (type 7자 + ": " + name 13자 + spec 10자)
  최대: ~200자
  평균 토큰: ~15~25 토큰

청크:
  평균: ~170자 (메타 60자 + text 110자)
  최대: ~2,900자
  평균 토큰: ~100~200 토큰

총 토큰 예상:
  엔티티: 16,364 × 20 = 327,280 토큰
  청크:    2,105 × 150 = 315,750 토큰
  합계:    ~643,000 토큰
```

---

## 4. 구현 상세

### 4.1 파일 구조

```
python_code/
├── phase2_extraction/
│   └── step7_embedding_generator.py   ← 메인 스크립트
├── sql/
│   └── step2.7_create_search_functions.sql  ← SQL 함수 3개
└── .env
    ├── GEMINI_API_KEY=...
    ├── SUPABASE_URL=...
    └── SUPABASE_SERVICE_ROLE_KEY=...
```

### 4.2 Python 스크립트 설계 (`step7_embedding_generator.py`)

#### 4.2.1 CLI 인터페이스

```
사용법:
  python step7_embedding_generator.py [--target entities|chunks|all] [--batch-size N] [--dry-run]

인자:
  --target      entities | chunks | all (기본: all)
  --batch-size  Gemini API 배치 크기 (기본: 100, 최대: 100)
  --dry-run     임베딩 텍스트 생성만 하고 API 호출 안 함
```

#### 4.2.2 임베딩 텍스트 빌더 함수

```python
def build_entity_embedding_text(entity: dict) -> str:
    """
    엔티티 → 임베딩 입력 텍스트
    
    Why: type 프리픽스로 동명이인 구분, spec으로 검색 정밀도 향상
    """
    text = f"{entity['type']}: {entity['name']}"
    props = entity.get('properties', {})
    
    # 규격 정보 추가 (있을 때만)
    spec = props.get('spec', '')
    if spec:
        text += f" [규격: {spec}]"
    
    # 단위 추가 (있을 때만)
    unit = props.get('unit', '')
    if unit:
        text += f" [{unit}]"
    
    return text.strip()


def build_chunk_embedding_text(chunk: dict) -> str:
    """
    청크 → 임베딩 입력 텍스트
    
    Why: 계층 메타데이터 프리픽스로 분류 맥락 제공
    """
    parts = []
    
    # 계층 프리픽스: 부문 > 장 > 절 > 제목
    for key in ['department', 'chapter', 'section', 'title']:
        val = chunk.get(key)
        if val:
            parts.append(str(val))
    
    header = " > ".join(parts) if parts else ""
    body = chunk.get('text', '')
    
    if header and body:
        return f"{header}\n{body}"
    elif header:
        return header
    else:
        return body
```

#### 4.2.3 Gemini 임베딩 호출 함수

```python
from google import genai
from google.genai import types

client = genai.Client(api_key=GEMINI_API_KEY)

def embed_batch(texts: list[str]) -> list[list[float]]:
    """
    최대 100건 배치 임베딩
    
    Why: embed_content는 단건/배치 모두 지원.
         배치로 호출 시 RPM 소비를 줄여 throughput 극대화.
    
    반환: list[list[float]] — 각 텍스트의 768차원 벡터
    
    에러 처리:
      - 429 Too Many Requests → exponential backoff (2^n초, 최대 60초)
      - 500/503 → 3회 재시도 후 해당 배치 skip + 로그
      - 빈 텍스트 → '[EMPTY]' 대체 (Gemini API는 빈 문자열 거부)
    """
    # 빈 텍스트 방어
    sanitized = [t if t.strip() else '[EMPTY]' for t in texts]
    
    result = client.models.embed_content(
        model="gemini-embedding-001",
        contents=sanitized,
        config=types.EmbedContentConfig(output_dimensionality=768)
    )
    
    vectors = [emb.values for emb in result.embeddings]
    
    # 차원 검증: 모든 벡터가 768차원인지 확인
    for i, vec in enumerate(vectors):
        if len(vec) != 768:
            raise ValueError(
                f"벡터 차원 불일치: index={i}, expected=768, got={len(vec)}"
            )
    
    return vectors
```

#### 4.2.4 재시도 로직 (Exponential Backoff)

```python
import time
from google.api_core import exceptions as google_exceptions

MAX_RETRIES = 5
INITIAL_BACKOFF = 1.0   # 초
MAX_BACKOFF = 60.0       # 초

def embed_batch_with_retry(texts: list[str]) -> list[list[float]] | None:
    """
    재시도 포함 배치 임베딩
    
    Why: Gemini API 429/500 에러는 일시적. 
         Exponential backoff로 안정적 처리.
    """
    for attempt in range(MAX_RETRIES):
        try:
            return embed_batch(texts)
        except Exception as e:
            error_str = str(e)
            
            is_retryable = any(code in error_str for code in ['429', '500', '503', 'RESOURCE_EXHAUSTED'])
            
            if not is_retryable or attempt == MAX_RETRIES - 1:
                log(f"  ❌ 비복구 에러 (attempt {attempt+1}/{MAX_RETRIES}): {error_str[:200]}")
                return None
            
            wait = min(INITIAL_BACKOFF * (2 ** attempt), MAX_BACKOFF)
            log(f"  ⏳ 재시도 {attempt+1}/{MAX_RETRIES} ({wait:.1f}초 대기): {error_str[:100]}")
            time.sleep(wait)
    
    return None
```

#### 4.2.5 Supabase UPDATE 함수 (Codex F4 반영: fallback 포함)

```python
def update_embeddings(table: str, updates: list[dict], batch_size: int = 200):
    """
    임베딩 벡터 → Supabase UPDATE
    
    updates: [{'id': 'E-0001', 'embedding': [0.1, 0.2, ...]}]
    
    Why: Supabase Python SDK의 upsert는 PK 기준 동작.
         여기서는 기존 행의 embedding 컬럼만 업데이트하므로 upsert 사용.
         TEXT PK 테이블(graph_entities, graph_chunks) 모두 해당.
    
    벡터 캐스팅 전략 (Codex F4 반영):
      1차 시도: list[float] 직접 전달 → Supabase SDK가 JSON → pgvector 자동 캐스팅
      2차 시도(fallback): 실패 시 벡터를 '[0.1,0.2,...]' 문자열로 직렬화하여 전달
         → PostgreSQL이 TEXT → vector(768) 캐스팅 수행
    """
    total = len(updates)
    success = 0
    errors = []
    
    for i in range(0, total, batch_size):
        batch = updates[i:i + batch_size]
        try:
            supabase.table(table).upsert(batch).execute()
            success += len(batch)
            if success % 2000 == 0 or success == total:
                log(f"  [{table}] {success}/{total} 임베딩 업데이트 완료")
        except Exception as e:
            # Fallback: 벡터를 문자열로 직렬화하여 재시도
            try:
                import json
                str_batch = [
                    {**row, 'embedding': json.dumps(row['embedding'])}
                    for row in batch
                ]
                supabase.table(table).upsert(str_batch).execute()
                success += len(batch)
                log(f"  ⚠️ [{table}] 배치 {i}: fallback(문자열 직렬화)으로 성공")
            except Exception as e2:
                errors.append({'batch_start': i, 'error': str(e2)[:200]})
                log(f"  ❌ [{table}] 배치 {i}~{i+len(batch)} 실패: {str(e2)[:200]}")
        time.sleep(0.1)
    
    return {'total': total, 'success': success, 'errors': errors}
```

#### 4.2.6 메인 실행 흐름

```
Phase 1: 엔티티 임베딩 (graph_entities)
  1-1. SELECT id, name, type, properties FROM graph_entities WHERE embedding IS NULL
  1-2. build_entity_embedding_text() 적용 → texts[]
  1-3. 100건 배치 → embed_batch_with_retry() → vectors[]
  1-4. update_embeddings('graph_entities', id, embedding) 
  1-5. 진행률 로그: [graph_entities] 2000/16364 임베딩 완료 (12.2%)

Phase 2: 청크 임베딩 (graph_chunks)
  2-1. SELECT id, department, chapter, section, title, text FROM graph_chunks WHERE embedding IS NULL
  2-2. build_chunk_embedding_text() 적용 → texts[]
  2-3. 100건 배치 → embed_batch_with_retry() → vectors[]
  2-4. update_embeddings('graph_chunks', id, embedding)
  2-5. 진행률 로그: [graph_chunks] 1000/2105 임베딩 완료 (47.5%)

Phase 3: 검증
  3-1. SELECT COUNT(*) FROM graph_entities WHERE embedding IS NULL → 0건 기대
  3-2. SELECT COUNT(*) FROM graph_chunks WHERE embedding IS NULL → 0건 기대
  3-3. 차원 검증: SELECT array_length(embedding::real[], 1) 샘플 체크
```

#### 4.2.7 재개(Resume) 메커니즘

```
Why: 18,469건 처리 중 네트워크 오류나 API 제한으로 중단될 수 있음.
     WHERE embedding IS NULL 조건으로 미처리 건만 SELECT하므로,
     스크립트를 재실행하면 자동으로 이어서 처리됨.

구현:
  - 매 배치 성공 시 즉시 Supabase에 UPDATE (지연 쓰기 없음)
  - 실패 배치는 skip → 재실행 시 자동 재처리
  - 진행 로그에 "남은 건수" 출력하여 재개 시점 파악 용이
```

#### 4.2.8 데이터 SELECT 방식 — Keyset 페이징 (Codex F3 반영)

```python
def fetch_entities_needing_embedding(batch_size: int = 1000) -> list[dict]:
    """
    embedding IS NULL인 엔티티를 keyset 페이징으로 가져옴
    
    Why: offset 페이징은 처리 중 행이 NULL 집합에서 빠지면
         offset 기반으로 다음 페이지 조회 시 일부 행을 건너뛸 위험이 있음.
         → keyset 페이징(id > last_id)으로 이 문제 해결.
    
    구현:
      - 최초 조회: id > '' (빈 문자열보다 큰 모든 id)
      - 이후: 마지막 행의 id를 기준으로 id > last_id
      - id는 TEXT PK이며 ORDER BY id ASC이므로 정렬 안정성 보장
    
    주의: Supabase Python SDK의 .is_('embedding', 'null') 필터 사용.
          .eq('embedding', None)은 동작하지 않음.
    """
    all_rows = []
    last_id = ''  # TEXT PK이므로 빈 문자열이 최소값
    
    while True:
        response = (
            supabase.table('graph_entities')
            .select('id, name, type, properties')
            .is_('embedding', 'null')
            .gt('id', last_id)          # keyset: id > last_id
            .order('id', desc=False)     # ASC 정렬
            .limit(batch_size)
            .execute()
        )
        rows = response.data
        if not rows:
            break
        all_rows.extend(rows)
        last_id = rows[-1]['id']  # 다음 페이지 시작점
        
        if len(rows) < batch_size:
            break
    
    return all_rows


def fetch_chunks_needing_embedding(batch_size: int = 1000) -> list[dict]:
    """fetch_entities_needing_embedding과 동일 패턴, 테이블만 다름"""
    all_rows = []
    last_id = ''
    
    while True:
        response = (
            supabase.table('graph_chunks')
            .select('id, department, chapter, section, title, text')
            .is_('embedding', 'null')
            .gt('id', last_id)
            .order('id', desc=False)
            .limit(batch_size)
            .execute()
        )
        rows = response.data
        if not rows:
            break
        all_rows.extend(rows)
        last_id = rows[-1]['id']
        
        if len(rows) < batch_size:
            break
    
    return all_rows
```

> **Codex F3 반영**: offset 기반 `.range(offset, end)` → keyset 기반 `.gt('id', last_id)` 로 변경.
> 처리 중 행이 NULL 집합에서 빠져도 다음 페이지에서 건너뛰는 문제가 발생하지 않음.

#### 4.2.9 벡터 값 유효성 검증

```python
def validate_embedding(vector: list[float], index: int) -> bool:
    """
    임베딩 벡터 유효성 검증
    
    Why: 간혹 API가 NaN이나 Inf를 반환하는 경우 방어.
         pgvector는 NaN/Inf 삽입 시 에러 발생.
    """
    import math
    
    if len(vector) != 768:
        log(f"  ⚠️ 차원 불일치: index={index}, got={len(vector)}")
        return False
    
    for j, v in enumerate(vector):
        if math.isnan(v) or math.isinf(v):
            log(f"  ⚠️ NaN/Inf 감지: index={index}, position={j}")
            return False
    
    return True
```

---

## 5. SQL 검색 함수 상세 (`step2.7_create_search_functions.sql`)

### 5.1 함수 1: `search_entities_by_embedding` (Codex F5 반영: 입력 검증 추가)

```sql
-- 벡터 유사도 검색: 쿼리 임베딩 → 유사 엔티티 반환
-- F2 반영: Edge Function에서 벡터를 TEXT로 전달 → SQL 내부에서 ::vector 캐스팅
-- F5 반영: PL/pgSQL wrapper로 입력 검증 (차원/형식 오류 시 빈 결과 반환)
CREATE OR REPLACE FUNCTION search_entities_by_embedding(
  query_embedding_text TEXT,         -- '[0.1, 0.2, ...]' 형태 문자열
  match_count INT DEFAULT 5,
  match_threshold FLOAT DEFAULT 0.5
)
RETURNS TABLE(
  id TEXT,
  name TEXT,
  type TEXT,
  properties JSONB,
  similarity FLOAT
)
AS $$
DECLARE
  parsed_vector vector(768);
BEGIN
  -- 입력 검증: NULL 또는 빈 문자열
  IF query_embedding_text IS NULL OR trim(query_embedding_text) = '' THEN
    RAISE NOTICE 'search_entities_by_embedding: 빈 입력 벡터';
    RETURN;  -- 빈 결과 반환
  END IF;

  -- 차원/형식 검증: TEXT → vector 캐스팅 시도
  BEGIN
    parsed_vector := query_embedding_text::vector(768);
  EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'search_entities_by_embedding: 벡터 파싱 실패 - %', SQLERRM;
    RETURN;  -- 빈 결과 반환 (에러 전파 안 함)
  END;

  RETURN QUERY
  SELECT ge.id, ge.name, ge.type, ge.properties,
         (1 - (ge.embedding <=> parsed_vector))::FLOAT AS similarity
  FROM graph_entities ge
  WHERE ge.embedding IS NOT NULL
    AND 1 - (ge.embedding <=> parsed_vector) > match_threshold
  ORDER BY ge.embedding <=> parsed_vector
  LIMIT match_count;
END;
$$ LANGUAGE plpgsql STABLE;
```

**설계 근거:**
- `PL/pgSQL` 전환: 입력 검증 로직을 위해 순수 SQL에서 PL/pgSQL로 전환. `EXCEPTION WHEN OTHERS` 블록으로 잘못된 벡터 형식 시 쿼리 에러 대신 빈 결과 반환 (Codex F5 반영)
- `vector(768)` 명시적 캐스팅: 차원이 768이 아닌 벡터 입력 시 캐스팅 에러 → `EXCEPTION` 핸들러가 포착
- `RAISE NOTICE`: 디버깅용 로그. Edge Function 로그에서 확인 가능
- `query_embedding_text TEXT` → `::vector` 캐스팅: Supabase Edge Function에서 `vector` 타입을 직접 전달할 수 없으므로 JSON 문자열로 전달 후 SQL 내부에서 캐스팅 (설계보고서 F2 반영)
- `embedding IS NOT NULL` 조건: 임베딩 미생성 행 제외
- `1 - cosine_distance` = cosine similarity: 1에 가까울수록 유사
- `STABLE` 표기: 동일 입력에 대해 같은 트랜잭션 내 동일 결과 보장 → 쿼리 최적화 가능

### 5.2 함수 2: `get_related_resources`

```sql
-- 그래프 확장: 엔티티 ID → 1-hop 연결된 모든 리소스
-- F4 반영: direction 컬럼으로 inbound/outbound 구분
CREATE OR REPLACE FUNCTION get_related_resources(p_entity_id TEXT)
RETURNS TABLE(
  direction TEXT,
  relation TEXT,
  related_id TEXT,
  related_name TEXT,
  related_type TEXT,
  properties JSONB
)
AS $$
  -- outbound: 이 엔티티 → 연결된 대상
  SELECT 'outbound'::TEXT AS direction,
         r.relation,
         e.id AS related_id,
         e.name AS related_name,
         e.type AS related_type,
         r.properties
  FROM graph_relationships r
  JOIN graph_entities e ON e.id = r.target_id
  WHERE r.source_id = p_entity_id
  
  UNION ALL
  
  -- inbound: 연결된 주체 → 이 엔티티
  SELECT 'inbound'::TEXT AS direction,
         r.relation,
         e.id AS related_id,
         e.name AS related_name,
         e.type AS related_type,
         r.properties
  FROM graph_relationships r
  JOIN graph_entities e ON e.id = r.source_id
  WHERE r.target_id = p_entity_id;
$$ LANGUAGE sql STABLE;
```

**설계 근거:**
- `direction` 컬럼: `outbound` = 이 엔티티가 source, `inbound` = 이 엔티티가 target. Edge Function에서 방향별로 컨텍스트를 다르게 구성 가능 (설계보고서 F4 반영)
- `graph_global_relationships`는 이 함수에서 제외: 계층 정보(HAS_CHILD/REFERENCES)는 아래 §5.4 `get_entity_hierarchy`에서 별도 제공 (Codex F6 반영)
- `UNION ALL`: inbound/outbound가 중복될 수 없으므로 `UNION ALL`이 `UNION`보다 효율적

### 5.4 함수 4: `get_entity_hierarchy` (Codex F6 반영: 전역 관계 탐색)

```sql
-- 전역 관계(HAS_CHILD, REFERENCES) 탐색: 계층 컨텍스트 제공
-- Codex F6 반영: get_related_resources가 graph_global_relationships를 제외하므로
-- Section 계층/참조 기반 질의를 위한 별도 함수
CREATE OR REPLACE FUNCTION get_entity_hierarchy(p_entity_id TEXT)
RETURNS TABLE(
  direction TEXT,
  relation TEXT,
  related_id TEXT,
  related_name TEXT,
  related_type TEXT,
  properties JSONB
)
AS $$
  -- outbound: 이 엔티티의 하위 항목
  SELECT 'child'::TEXT AS direction,
         r.relation,
         e.id AS related_id,
         e.name AS related_name,
         e.type AS related_type,
         r.properties
  FROM graph_global_relationships r
  JOIN graph_entities e ON e.id = r.target_id
  WHERE r.source_id = p_entity_id
  
  UNION ALL
  
  -- inbound: 이 엔티티의 상위 항목
  SELECT 'parent'::TEXT AS direction,
         r.relation,
         e.id AS related_id,
         e.name AS related_name,
         e.type AS related_type,
         r.properties
  FROM graph_global_relationships r
  JOIN graph_entities e ON e.id = r.source_id
  WHERE r.target_id = p_entity_id;
$$ LANGUAGE sql STABLE;
```

**설계 근거:**
- `get_related_resources`와 분리: 추출 관계(REQUIRES_LABOR 등)와 계층 관계(HAS_CHILD 등)는 성격이 다르므로 별도 함수로 제공
- `child`/`parent` direction: 계층 탐색에 적합한 의미. Edge Function에서 빵구조(breadcrumb) 컨텍스트 구성에 활용
- Step 2.8 Edge Function에서 선택적 호출: 엔티티 type이 'Section'인 경우에만 호출하여 성능 최적화 가능

### 5.3 함수 3: `search_ilwi`

```sql
-- 일위대가 키워드 검색
CREATE OR REPLACE FUNCTION search_ilwi(
  search_name TEXT,
  search_spec TEXT DEFAULT NULL
)
RETURNS TABLE(
  id INT,
  name TEXT,
  spec TEXT,
  labor_cost NUMERIC,
  material_cost NUMERIC,
  expense_cost NUMERIC,
  total_cost NUMERIC
)
AS $$
  SELECT id, name, spec, labor_cost, material_cost, expense_cost, total_cost
  FROM ilwi_items
  WHERE name ILIKE '%' || search_name || '%'
    AND (search_spec IS NULL OR spec ILIKE '%' || search_spec || '%')
  ORDER BY name, spec
  LIMIT 20;
$$ LANGUAGE sql STABLE;
```

**설계 근거:**
- `ILIKE`: 대소문자 무관 한글 검색. `pg_trgm` 인덱스(`idx_ilwi_name_trgm`)가 `ILIKE` 패턴 검색 가속
- `search_spec` 생략 가능: NULL이면 name만으로 검색
- 반환 `id` 컬럼 포함: 설계보고서 원본에는 `id` 생략되어 있었으나, 프론트엔드에서 상세 조회 시 필요하므로 추가
- `expense_cost` 컬럼 추가: 원본에 누락되어 있었으나 `ilwi_items` 테이블에 존재하는 컬럼이므로 포함
- `LIMIT 20`: 10건은 실사용 시 부족할 수 있어 20건으로 상향

---

## 6. 실행 체크리스트

### 6.1 사전 준비

```
[  ] .env 파일 확인
     GEMINI_API_KEY=...        → 유료 플랜 키 확인 (RPM 1,500 이상)
     SUPABASE_URL=https://bfomacoarwtqzjfxszdr.supabase.co
     SUPABASE_SERVICE_ROLE_KEY=eyJ...
     
[  ] Python 의존성 설치
     py -3 -m pip install google-genai
     (supabase, python-dotenv는 Step 2.6에서 설치 완료)

[  ] DB 상태 확인
     SELECT COUNT(*) FROM graph_entities WHERE embedding IS NULL;
     → 기대: 16,364
     SELECT COUNT(*) FROM graph_chunks WHERE embedding IS NULL;
     → 기대: 2,105
```

### 6.2 실행 순서

```
Phase 1: 임베딩 생성 (Python)
──────────────────────────

  Step 1: Dry-run (임베딩 텍스트 미리보기)
  [  ] py -3 step7_embedding_generator.py --dry-run
       → 임베딩 텍스트 샘플 10건 출력
       → 총 건수 확인: entities=16,364, chunks=2,105

  Step 2: 엔티티 임베딩
  [  ] py -3 step7_embedding_generator.py --target entities
       → 예상 시간: 15~25분
       → 기대: 16,364건 성공

  Step 3: 청크 임베딩
  [  ] py -3 step7_embedding_generator.py --target chunks
       → 예상 시간: 3~5분
       → 기대: 2,105건 성공

  Step 4: NULL 잔존 확인
  [  ] SELECT COUNT(*) FROM graph_entities WHERE embedding IS NULL;
       → 기대: 0
  [  ] SELECT COUNT(*) FROM graph_chunks WHERE embedding IS NULL;
       → 기대: 0

Phase 2: SQL 함수 배포 (Supabase SQL Editor)
────────────────────────────────────────────

  Step 5: 함수 생성
  [  ] sql/step2.7_create_search_functions.sql 실행
       → 3개 함수 생성 확인

  Step 6: 함수 동작 테스트
  [  ] SELECT * FROM search_ilwi('배관');
       → 결과 반환 확인
  [  ] SELECT * FROM get_related_resources('W-0115');
       → outbound/inbound 관계 반환 확인
```

### 6.3 검증 쿼리

```sql
-- 1. 임베딩 NULL 잔존 검사 (0건이어야 함)
SELECT 
  'graph_entities' AS tbl,
  COUNT(*) AS total,
  COUNT(embedding) AS has_embedding,
  COUNT(*) - COUNT(embedding) AS null_count
FROM graph_entities
UNION ALL
SELECT 
  'graph_chunks',
  COUNT(*),
  COUNT(embedding),
  COUNT(*) - COUNT(embedding)
FROM graph_chunks;

-- 기대 결과:
-- graph_entities: total=16,364, has_embedding=16,364, null_count=0
-- graph_chunks:   total=2,105,  has_embedding=2,105,  null_count=0

-- 2. 벡터 차원 샘플 검증 (768이어야 함)
SELECT id, array_length(embedding::real[], 1) AS dim
FROM graph_entities
LIMIT 5;

-- 3. 벡터 유사도 검색 Smoke Test
-- (임베딩 생성 후 실행 가능)
-- SELECT * FROM search_entities_by_embedding(
--   (SELECT embedding::text FROM graph_entities WHERE name LIKE '%배관%' LIMIT 1),
--   5, 0.3
-- );

-- 4. SQL 함수 존재 확인
SELECT routine_name, routine_type
FROM information_schema.routines
WHERE routine_schema = 'public'
  AND routine_name IN ('search_entities_by_embedding', 'get_related_resources', 'get_entity_hierarchy', 'search_ilwi');
-- 기대: 4개 행
```

---

## 7. 에러 시나리오 + 대응

| #   | 에러                               | 원인                   | 대응                                                                           |
| --- | ---------------------------------- | ---------------------- | ------------------------------------------------------------------------------ |
| E1  | `429 RESOURCE_EXHAUSTED`           | RPM/RPD 초과           | Exponential backoff (§4.2.4). 5회 실패 시 skip → 재실행으로 자동 재개 (§4.2.7) |
| E2  | `500 INTERNAL` / `503 UNAVAILABLE` | Gemini 서버 일시 장애  | 동일 backoff. 장기 장애 시 수동 확인 후 재실행                                 |
| E3  | `ValueError: 벡터 차원 불일치`     | API 응답 이상          | 해당 배치 skip + 로그. 재실행 시 자동 재처리                                   |
| E4  | `NaN/Inf in vector`                | 드문 API 버그          | validate_embedding() 필터링 (§4.2.9). 해당 건 skip                             |
| E5  | Supabase `upsert` 실패             | 네트워크/RLS           | 배치 에러 로그 + 재시도. service_role 키 확인                                  |
| E6  | 빈 텍스트 (`''`)                   | name이 비어있는 엔티티 | `'[EMPTY]'`로 대체 (§4.2.3). API 빈 문자열 거부 방어                           |
| E7  | 메모리 부족                        | 16K건 동시 로드        | 1,000건씩 페이징 SELECT (§4.2.8)                                               |

---

## 8. 설계보고서 반영 사항 추적

| 설계보고서 항목                      | 구현계획서 반영 위치                              | 상태  |
| ------------------------------------ | ------------------------------------------------- | :---: |
| F2: 벡터 text 전달 + ::vector 캐스팅 | §5.1 `search_entities_by_embedding`               |   ✅   |
| F4: direction 컬럼 추가              | §5.2 `get_related_resources`                      |   ✅   |
| F5: 빈 결과 예외 처리                | Step 2.8 Edge Function에서 처리 (본 단계 범위 외) |   ⏳   |
| 768차원 명시                         | §2 전제 조건, §4.2.3 output_dimensionality=768    |   ✅   |
| 일위대가 임베딩 제외                 | §3.3 설계 근거                                    |   ✅   |
| Gemini embedding 모델                | §2 gemini-embedding-001                           |   ✅   |

### 8.1 Codex 검토 반영 추적

| #   | Codex 지적                              | 심각도 | 반영 위치                                           | 상태  |
| --- | --------------------------------------- | :----: | --------------------------------------------------- | :---: |
| F1  | 비용/플랜 가정 상충                     |  High  | §2.2 비용 산출 — 유료 플랜 vs 임베딩 비용 분리 설명 |   ✅   |
| F2  | RPM 산출 수식 검증                      |  High  | §2.1 — 단계별 산출 공식 + 레이턴시/오버헤드 분리    |   ✅   |
| F3  | offset 페이징 → keyset 페이징           |  High  | §4.2.8 — `.gt('id', last_id)` 방식으로 전면 교체    |   ✅   |
| F4  | 벡터 자동 캐스팅 낙관적 → fallback 필요 | Medium | §4.2.5 — 문자열 직렬화 fallback 추가                |   ✅   |
| F5  | 검색 함수 입력 검증 없음                | Medium | §5.1 — PL/pgSQL wrapper + EXCEPTION 핸들러          |   ✅   |
| F6  | 전역 관계 제외 → 계층 컨텍스트 누락     | Medium | §5.4 — `get_entity_hierarchy` 함수 신설             |   ✅   |

---

## 9. 산출물 목록

| 파일                                                      | 용도                 | 생성 시점 |
| --------------------------------------------------------- | -------------------- | --------- |
| `phase2_extraction/step7_embedding_generator.py`          | 임베딩 생성 스크립트 | 실행 전   |
| `sql/step2.7_create_search_functions.sql`                 | SQL 함수 4개 DDL     | 실행 전   |
| `phase2_output/logs/step7_embedding_*.log`                | 실행 로그            | 실행 중   |
| `phase2_output/logs/step7_summary_*.json`                 | 결과 요약            | 실행 후   |
| `docs/20260211_Step2.7_임베딩생성_검색함수_최종보고서.md` | 최종 보고서          | 실행 후   |

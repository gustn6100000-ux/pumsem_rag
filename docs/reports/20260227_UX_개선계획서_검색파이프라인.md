# [UX 분석 및 개선 계획서 V3] 검색 파이프라인 편의성 강화
> **작성일**: 2026-02-27  
> **최종 수정**: 2026-02-27 (Codex 코드 리뷰 + 분석결과 통합 V3)  
> **상태**: Draft → Codex Review + Cross-Analysis Merged

---

## 1. 개요 및 문제점 분석

사용자가 제공한 스크린샷 4장과 현재 백엔드(Edge Function) 로직을 대조 분석한 결과,
사용자가 지적한 **"규격 선택의 어려움"**과 **"결과 데이터의 가독성 저하"**는 타당한 지적이며,
다음과 같은 기술적 원인이 있습니다.

### 문제점 A: "규격 선택" (Clarify UI) 단계의 인지 과부하
| 항목 | 내용 |
|------|------|
| **현상** | "플랜지 배관설치" 검색 시 15개+ 규격 옵션이 1차원 체크박스 리스트로 나열 |
| **원인** | `resolve.ts`의 `buildSelectorPanel`이 `filters + items` 평면 구조만 제공. **재질→접합→관경** 등 논리적 계층(Tree)이나 Step-by-step 드릴다운 미지원 |
| **영향** | 사용자가 수많은 텍스트를 일일이 읽어야 원하는 항목을 찾을 수 있음 |

### 문제점 B: 매트릭스 교차표의 가독성 및 효율성 부재
| 항목 | 내용 |
|------|------|
| **현상** | 최종 산출 결과에서 직종별/규격별 인력 투입량이 텍스트(마크다운) 기반으로 빽빽하게 출력 |
| **원인** | `index.ts`의 `renderMatrixTable`이 `(name, spec) → quantity` 단순 맵으로 마크다운 문자열 생성. 정보량 많은 복합 표에서 열이 수십 개로 팽창 |
| **영향** | 가로 스크롤 불가, 수치 비교 불가, 색상 강조 불가 → "뱉어내는 듯한" 느낌 |

---

## 2. Codex 코드 리뷰 반영 (5건)

> [!IMPORTANT]
> 아래는 Codex(Claude Code)가 V1 계획서를 소스 코드와 대조 분석한 결과 식별한 5개 핵심 리스크입니다.
> 각 이슈에 대한 대응 전략을 명시합니다.

### 이슈 ①: API 계약(Contract) 변경 리스크 — 점진 이행 전략 부재

**Codex 지적**: `ChatResponse`가 `answer` 중심인데, `matrix_data`/계층형 `clarify`를 넣으면 프론트가 즉시 깨질 수 있음. 레거시 클라이언트 호환 파괴 위험.

**대응 전략: 스키마 버저닝 + Additive 확장**
- `ChatResponse`에 `schema_version: "2.0"` 필드 추가 (기본값 `"1.0"`)
- 기존 `answer`(마크다운 텍스트)는 **그대로 유지** (하위호환 보장)
- 새 필드들은 **옵셔널(Optional)**로만 추가:
  ```typescript
  interface ChatResponse {
      // ── 기존 (v1 호환) ──
      type: "answer" | "clarify";
      answer: string;                    // 마크다운 텍스트 (유지)
      sources: SourceInfo[];
      search_info: SearchInfo;
      clarification?: ClarificationInfo; // 기존 options[] (유지)
      
      // ── v2 추가 (옵셔널) ──
      schema_version?: string;           // "1.0" | "2.0"
      structured_data?: StructuredData;  // matrix JSON, 계층형 clarify 등
  }
  ```
- 프론트엔드는 `structured_data` 존재 시 우선 렌더링, 없으면 기존 `answer` 폴백
- **결론**: 기존 API 소비자(프론트엔드)가 V1으로 동작하는 상태에서 V2 필드를 점진적으로 활용 가능

---

### 이슈 ②: Clarify 계층형 설계의 구현 단위 명세 부재

**Codex 지적**: 현재 `buildSelectorPanel`은 `filters + items` 구조. 트리(재질→접합→관경) 탐색의 노드 ID/부모자식/선택 상태 규약이 없음.

**대응 전략: ClarifyTree 타입 정의**
```typescript
// ─── 계층형 Clarify 노드 타입 ───
interface ClarifyTreeNode {
    node_id: string;             // "material:탄소강관"
    label: string;               // "탄소강관 (배관용)"
    level: number;               // 0=재질, 1=접합방식, 2=관경
    level_name: string;          // "재질" | "접합방식" | "관경"
    parent_id: string | null;    // null=루트
    children_count: number;      // 하위 노드 수
    is_leaf: boolean;            // true면 최종 선택 가능
    entity_id?: string;          // leaf일 때 WorkType entity_id
    source_section?: string;
}

interface ClarifyTreePanel {
    title: string;               // "배관 설치 — 규격 선택"
    levels: string[];            // ["재질", "접합방식", "관경"]
    current_level: number;       // 현재 표시할 레벨 (0부터)
    nodes: ClarifyTreeNode[];    // 현재 레벨의 노드 목록
    breadcrumb: string[];        // 선택 경로 ["탄소강관", "용접식"]
    total_leaves: number;        // 최종 선택 가능 항목 수
}
```

**구현 방식**:
- `resolve.ts`의 `parseWorkTypeName`이 이미 `{재질, 배관장소, 접합방식}` 딕셔너리를 반환
- 이 딕셔너리의 **키 순서**를 레벨 순서로 고정 (재질→접합→관경)
- `buildSelectorPanel` 내부에서 items를 트리로 재구성하여 `ClarifyTreePanel` 생성
- 프론트가 레벨 0 노드만 먼저 보여주고, 선택 시 `section_id` + 선택값을 백엔드에 재전송 → 다음 레벨 반환

---

### 이슈 ③: Matrix JSON화 시 데이터 정합성 규칙 누락

**Codex 지적**: 현재 `renderMatrixTable`은 `(name, spec) → quantity` 1값 맵으로 단순화. 실제 데이터에 동일 키의 복수 항목, 단위 혼재, 수량 미기입 존재.

**대응 전략: 셀 병합/충돌 규칙 명문화**
```
규칙 1 (중복 키):  동일 (name, spec) 키에 복수 값 → 배열로 저장
                   quantity: [0.122, 0.088] → 프론트에서 "0.122 / 0.088" 표시
규칙 2 (단위 정규화): "인" / "人" / "명" → 통일값 "인"
                      "대" / "臺" → 통일값 "대"
규칙 3 (미기입):   quantity == null → 셀 값 "-" (JSON에서 null)
규칙 4 (소수점):   소수점 이하 3자리까지 표시, 0.000은 "-"
```

```typescript
interface MatrixCell {
    values: number[];         // 복수값 허용 [0.122, 0.088]
    unit: string;             // 정규화된 단위 "인"
    is_empty: boolean;        // true면 데이터 없음
}

interface MatrixData {
    title: string;            // "[표 13-1-1] 투입 인력"
    source_section: string;   // "13-1-1"
    row_header: string;       // "직종"
    col_header: string;       // "관경"
    rows: string[];           // ["특별인부", "플랜트용접공", ...]
    cols: string[];           // ["6mm", "8mm", "10mm", ...]
    cells: MatrixCell[][];    // rows.length × cols.length
    unit_label: string;       // "인/개소"
    source_label: string;     // "기계설비부문 > 제13장 > 배관 설치"
}
```

---

### 이슈 ④: LLM 프롬프트에 구조 생성 책임 → 백엔드 결정 로직으로 이동

**Codex 지적**: "LLM 시스템 프롬프트 수정으로 Step 메타데이터 생성"은 재현성 낮음.

**대응 전략: 책임 분리 원칙 적용**
| 역할 | 담당 | 산출물 |
|------|------|--------|
| **구조 데이터** | 백엔드 결정 로직 (`resolve.ts`, `index.ts`) | `ClarifyTreePanel`, `MatrixData` JSON |
| **설명 텍스트** | LLM (`llm.ts`) | `answer` 문자열 (사용자 친화적 안내문, 주의사항 해석 등) |

- V1 계획서의 "LLM 프롬프트를 수정하여 Step 메타데이터 생성" 방안은 **폐기**
- 모든 구조 데이터는 `resolve.ts`/`index.ts`에서 **결정적(deterministic)**으로 생성
- LLM은 `answer` 필드의 자연어 텍스트만 담당 (현행 유지)

---

### 이슈 ⑤: 검증 계획의 회귀 방지 취약성

**Codex 지적**: 수동 확인만 포함. 핵심 회귀(응답 크기, 옵션 개수, 정렬/중복, 성능) 자동 검증 없음.

**대응 전략: 스냅샷 + 정적 어서션 검증 시나리오**

| # | 검증 항목 | 방법 | 기대 결과 |
|---|----------|------|----------|
| 1 | **응답 스키마 호환** | `test_api.js`로 기존 쿼리 10건 실행 → JSON schema validate | `answer`, `sources`, `search_info` 필드 존재 확인 (V1 호환) |
| 2 | **Clarify 옵션 중복** | Clarify 응답의 `options` 배열에서 `entity_id` 유니크 검증 | 중복 = 0 |
| 3 | **Matrix 셀 정합성** | `structured_data.matrix_data.cells` 배열 크기 = `rows.length × cols.length` | 불일치 = 0 |
| 4 | **응답 크기 상한** | JSON 응답 바이트 수 측정 | ≤ 100KB (현재 평균 ~30KB) |
| 5 | **응답 시간 회귀** | `search_info.latency_ms` 비교 | V2 ≤ V1 × 1.2 (20% 이내 증가) |
| 6 | **스냅샷 비교** | 주요 쿼리 5건의 응답 JSON을 파일로 저장 → diff | 의도치 않은 변경 없음 |

**구현**: `test_api.js`를 확장하여 위 6개 어서션을 자동 실행하는 `test_regression.js` 스크립트 작성

---

## 3. Proposed Changes (수정된 Phase 계획)

### Phase 0: 스키마 계약 고정 (선행 필수)
| 파일 | 작업 |
|------|------|
| `types.ts` | `ChatResponse`에 `schema_version`, `structured_data` (Optional) 추가 |
| `types.ts` | `ClarifyTreeNode`, `ClarifyTreePanel`, `MatrixData`, `MatrixCell` 타입 정의 |
| `context.ts` | `makeAnswerResponse`/`makeClarifyResponse`에 `structured_data` 패스스루 추가 |

### Phase 1-A: Clarify 계층형 선택 모델 구현
| 파일 | 작업 |
|------|------|
| `resolve.ts` | `buildSelectorPanel` → `buildClarifyTree` 리팩토링. `parseWorkTypeName` 결과를 트리로 재구성 |
| `resolve.ts` | `presentClarify`에서 `ClarifyTreePanel` 생성 → `structured_data.clarify_tree`에 주입 |
| `clarify.ts` | `graphClarify` 호출 시 breadcrumb(선택 경로) 파라미터 추가 |

### Phase 1-B: Matrix Table JSON 구조화
| 파일 | 작업 |
|------|------|
| `index.ts` | `renderMatrixTable` → `buildMatrixData` 리팩토링. JSON 객체 생성 (마크다운은 폴백용으로 유지) |
| `index.ts` | `answerPipeline` 내에서 `MatrixData` 객체를 `structured_data.matrix_data`에 주입 |
| `index.ts` | `fullViewPipeline` 내에서도 `MatrixData` 주입 (동일 패턴) |
| `index.ts` | **`complexTablePipeline`과 통합 검토** — 861~1020라인의 복합 테이블 전용 파이프라인이 이미 존재하므로, `MatrixData` 구조와 중복되지 않도록 설계 통일 |
| `index.ts` | **`buildContext()` 교차표 로직 수정** — 현재 교차표를 context 문자열에 합쳐서 LLM에 넘기는 방식(161~300라인)을 JSON 구조와 병행하도록 수정. 토큰 낭비 방지 |
| `index.ts` | 셀 병합/단위 정규화 규칙 적용 |
| `llm.ts` | **`generateAnswer` 프롬프트 호환성 확인** — 마크다운 표를 전제로 작성된 시스템 프롬프트가 JSON 구조화 후에도 정상 동작하는지 검증. 필요 시 프롬프트 분기 추가 |

### Phase 1-C: 회귀 검증 스크립트
| 파일 | 작업 |
|------|------|
| `test_regression.js` **(NEW)** | 주요 쿼리 5건에 대한 스키마 검증 + 중복 검증 + 크기/성능 어서션 |

### Phase 2: 프론트엔드 UI 개편 (별도 레포)
- 백엔드 Phase 0~1 완료 후, `structured_data` JSON을 활용한 UI 컴포넌트 구현
- 계층형 Clarify → 트리 드릴다운 UI
- MatrixData → 동적 데이터 그리드 (Sticky Header, 가로 스크롤, 셀 강조)

---

## 3-1. 수정 영향 범위 요약 (Codex 분석결과 통합)

```
Phase 1-A (Clarify 계층화)
├── types.ts        → FilterAxis 타입 확장 or ClarifyTreeNode/Panel 신설
├── resolve.ts      → buildSelectorPanel, extractFilterAxes, presentClarify 수정
├── clarify.ts      → graphClarify에 breadcrumb 파라미터 추가 (프롬프트 변경 없음)
└── [프론트엔드]     → 체크박스 리스트 → 계층형 드릴다운 UI 전면 교체 (Phase 2)

Phase 1-B (Matrix JSON 구조화)
├── types.ts        → ChatResponse에 structured_data 필드 추가, MatrixData 타입 신설
├── index.ts        → renderMatrixTable 보조화 + buildMatrixData 신설
│   ├── buildContext()         → 교차표 context 로직 수정 (토큰 낭비 방지)
│   ├── answerPipeline()       → structured_data.matrix_data 포함 응답 생성
│   ├── fullViewPipeline()     → structured_data.matrix_data 포함 응답 생성
│   └── complexTablePipeline() → MatrixData 구조와 통합 (중복 제거)
├── context.ts      → makeAnswerResponse에 structured_data 패스스루
├── llm.ts          → generateAnswer 프롬프트 호환성 확인/수정
└── [프론트엔드]     → 마크다운 표 → 동적 데이터 그리드 렌더링 (Phase 2)
```

---

## 4. 총평 및 성공 기준

> **성공 포인트 3가지** (Codex 총평 반영):
> 1. **구조 스키마 먼저 고정** → Phase 0를 선행하여 `types.ts`에 타입 확정 후 코딩 착수
> 2. **하위호환 유지** → `answer`/`options` 기존 필드 절대 삭제 불가, `structured_data`는 Additive Only
> 3. **데이터 정합성 규칙 명문화** → 셀 병합/단위/미기입 처리 규칙을 코드 주석 + 문서로 이중 기록

이 3가지가 확정되면 프론트 개편(Phase 2)도 병렬 진행이 가능합니다.

---

## 5. Verification Plan (보강)

### 자동 검증 (test_regression.js)
```
node test_regression.js
```
- 테스트 쿼리: "플랜지 배관설치", "강관용접 200mm SCH 40", "콘크리트 타설", "거푸집 설치", "안녕"
- 6개 어서션 항목 자동 실행 (§2 이슈⑤ 참조)

### 수동 검증
1. `test_api.js`로 `플랜지 배관설치` 호출 → `structured_data` 필드 존재 확인
2. Clarify 응답에서 `clarify_tree.levels` 배열이 `["재질", "접합방식", "관경"]` 순서인지 확인
3. Matrix 응답에서 `matrix_data.cells` 배열 크기와 `rows × cols` 일치 여부 확인

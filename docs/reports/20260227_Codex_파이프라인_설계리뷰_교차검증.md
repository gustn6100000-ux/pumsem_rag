# Codex 파이프라인 설계 리뷰 — 심층 교차 검증 및 아키텍처 개선 보고서 (M37 고도화)

> **작성일**: 2026-02-27  
> **분석 대상**: Codex 정적 분석 6개 이슈 → 파이프라인 소스코드 1:1 대조 및 아키텍처 무결성 심층 검토  
> **대상 파일**: `step2_llm_extractor.py`, `step3_relation_builder.py`, `schemas.py`

---

## 🎯 총평 (M37 심층 분석 결과)

단순히 코드에 누락된 부분이 있다는 1차원적 검증을 넘어, **제안된 핫픽스들의 부작용(Side-effects)과 근본적인 아키텍처 결함**을 재분석했습니다. 

이전 분석에서는 "프롬프트에 `table_id` 기반 숫자만 넣어주면 된다", "엔티티 키에 `sub_section`만 추가하면 된다"와 같은 단순 패치를 제안했으나, 이는 **LLM의 인지 한계와 병합(Merge) 단계의 복잡성을 간과한 얕은 해결책**입니다. 파이프라인의 데이터 정합성을 완벽히 보장하기 위한 깊이 있는 아키텍처 개선안을 도출했습니다.

---

## 🔍 이슈별 심층 분석 및 아키텍처 한계 돌파

### 이슈 1: Step2 프롬프트 소제목 컨텍스트 미주입 (단순 패치의 한계)

*   **기존 분석의 한계**: `table_id`에서 파싱한 소제목 번호(예: `01`)만 LLM 프롬프트에 `⚠️ 소제목 #01 소속입니다`라고 주입하는 것을 방안으로 제시했습니다.
*   **왜 실패하는가?**: LLM은 '01'이 '전기아크용접(V형)'을 의미하는지 **절대 알 수 없습니다**. LLM에게는 원본 텍스트에 적힌 실제 분류명(텍스트) 자체가 필요합니다.
*   **💡 진정한 아키텍처 해결책**: 
    1. **Step 1(파서) 개선**: 표를 추출할 때, 해당 표 바로 직전의 텍스트(Heading/소제목 텍스트)를 찾아 `table.context_heading` 속성으로 저장해야 합니다.
    2. **Step 2(LLM) 개선**: `build_user_prompt`는 무의미한 숫자가 아닌, **실제 텍스트 헤딩**을 주입해야 합니다.
    ```python
    heading = table.get('context_heading', '기본')
    parts.append(f"⚠️ 이 표는 '{heading}' 분류에 속합니다. 추출하는 엔티티 이름이나 속성에 이 문맥을 반드시 반영하세요.")
    ```

### 이슈 2: 스키마에 `sub_section` 계약 미존재 (1급 객체화 설계)

*   **기존 분석의 한계**: `Entity` 모델에 `sub_section` 필드를 단순히 추가하는 것을 제안했습니다.
*   **왜 부족한가?**: 프론트엔드의 트리를 그리려면(`재질 → 접합 → 관경` 등), `sub_section`은 단순 문자열 속성을 넘어 트리를 구성하는 **검색 하위 노드(Facet)**가 되어야 합니다.
*   **� 진정한 아키텍처 해결책**:
    *   `schemas.py`의 `Entity` 구조 (명시적 Contract 추가)
    *   장기적인 Graph DB 모델링: WorkType 엔티티의 속성(property)으로 둘 것인지, 아니면 `SubSection`이라는 별도 엔티티 노드로 만들어 `BELONGS_TO` 관계로 묶을 것인지 고도화 방향 설정. (현재는 트리 필터링을 위해 구조화된 속성으로 추가하는 것이 1단계)

### 이슈 3: Step3 병합 시 `sub_section` 충돌 처리 누락 (가장 치명적인 결함)

*   **기존 분석의 한계**: `_entity_key()`에 `sub_section`을 포함시켜 식별자를 분리하라고 제안했습니다.
*   **왜 치명적인가?**: Step 2.1 (테이블 추출)은 규칙에 의해 `sub_section` 없이 엔티티를 생성하고, Step 2.2 (LLM 처리)는 `sub_section`을 잘 추출해냈다고 가정합시다. 이때 두 엔티티가 `merge_chunk_extractions`에서 만나면 어떻게 될까요?
    *   키(`type+name+spec+sub_section`)가 다르므로 **동일 공종임에도 별개의 엔티티로 분리되어 중복 생성**됩니다.
*   **코드 검증**: `merge_chunk_extractions()` 로직(`step3_relation_builder.py:120`)은 동음이의어(이름은 같으나 소제목이 다른/없는 경우)에 대한 해상도(Resolution) 처리가 없습니다.
*   **💡 진정한 아키텍처 해결책**: 
    *   `_entity_key`를 분리하는 동시에, **병합 시 불완전한 속성의 상속(Inheritance/Resolution) 로직**이 체계적으로 구현되어야 합니다. (예: 이름과 스펙이 완벽히 일치할 때 빈 `sub_section`을 채워넣는 스마트 병합 구현)

### 이슈 4: 복합 청크(D) 경계 케이스의 LLM 혼란 방지

*   **기존 분석의 한계**: D 청크(소제목이 2개 이상 섞인 청크) 처리를 위한 하드코딩 패치 필요성만 언급.
*   **왜 복잡한가?**: 한 청크 안의 텍스트 전부를 던져주고, 소제목이 다른 표 2개를 동시에 주면 LLM은 표 1의 내용에 표 2의 소제목을 뒤섞어버리는 할루시네이션(Hallucination)을 일으킬 확률이 큽니다.
*   **💡 진정한 아키텍처 해결책**: 
    *   `build_user_prompt` 단위에서 **"청크 단위 지시"가 아닌 "표 단위/문맥 단위 프롬프팅"으로 분할**해야 합니다. 즉 Prompt Chunking이 파이프라인 청크보다 더 세밀하게 들어가야 LLM의 집중도가 보장됩니다.

### 이슈 5 & 6: SQL 핫픽스의 자동화 및 파이프라인 품질 게이트

*   **기존 분석**: DB 내 정규식 쿼리를 통한 수작업 범용화 제안.
*   **진단**: 근본적으로 "파이프라인 로직 결함으로 뱉어진 쓰레기 데이터를 DB에서 SQL로 몰래 청소하는 것" 자체가 안티패턴(Anti-pattern)입니다. 
*   **💡 진정한 아키텍처 해결책**: 
    *   DB 적재 스크립트 실행 직전(Step 3 마지막), 메모리 상에서 Validation이 필수입니다. 
    *   `assert` 또는 Pydantic Validation을 통해 `sub_section` 채움률(Fill-rate) 목표치를 강제 검사하는 **Quality Gate Middleware** 도입. 허용 누락률 초과 시 배치(Batch)를 Fail 처리하고 운영자에게 알림.

---

## 🚀 M37 심층 아키텍처 로드맵 (수정판)

단순 코드 패스(Patch)가 아닌, **파이프라인의 데이터 정합성(Data Integrity)을 100% 설계로 보장**하기 위한 로드맵입니다.

```text
[Phase 1] 파이프라인 계약 강제 및 파서 보완 (최우선)
├── schemas.py → Entity 모델 및 LLMEntity에 sub_section 필드 강력한 타입으로 추가 지정
└── Step 1 개조 → 표 바로 위 텍스트(Heading 텍스트)를 포착하여 table.context_heading 메타로 묶어두기

[Phase 2] Prompt Engineering 격리 및 지능형 병합 (핵심)
├── step2 → LLM에 table_id(숫자)가 아닌 context_heading(실제 텍스트)를 직접 전달하여 할루시네이션 방지
├── step2 → 복합 청크(다중 표)인 경우, 단일 Call이 아닌 표 단위로 분리하여 LLM Query (인지 과부하 방지)
└── step3 → `_entity_key` に `sub_section` 반영 및 동음이의어(sub_section만 누락된 형제 엔티티) 대상 지능형 병합(Smart Merge) 룰 추가

[Phase 3] 방어적 프로그래밍과 자동화된 검증 (운영)
├── step3 → DB Flush 전 Pipeline Quality Gate (Fill-rate가 95% 미만이면 에러 발생)
└── 범용 백필 SQL 스크립트 (과거 데이터 정리용)
```

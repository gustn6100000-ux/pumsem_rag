# Phase 4: 데이터 정합성 분석 보고서

> **일시**: 2026-02-13 23:14  
> **대상**: 강판 전기아크용접(표 13-2-4) 원본 vs 챗봇 결과물 비교  
> **작성 목적**: 원본 품셈서와 RAG 챗봇 출력 간 데이터 불일치의 근본 원인 규명 및 개선안 수립

---

## 1. 현상 요약

### 1.1 사용자 보고 증상

| 항목                        | 원본 PDF                                   | 챗봇 결과                                    |
| --------------------------- | ------------------------------------------ | -------------------------------------------- |
| **제목**                    | 강판 전기아크용접 **1. 전기아크용접(V형)** | 강판 전기아크용접(10, **SCH** 인력(인))      |
| **규격 표기**               | 두께(mm)                                   | SCH ← **오류** (강판에 SCH 미사용)           |
| **두께 10 하향_용접공**     | 0.087                                      | 0.087 (첫 테이블) / **0.048** (둘째 테이블)  |
| **불일치 값 (둘째 테이블)** | 원본에 없음                                | 0.048, 0.062, 0.073 등                       |
| **"상향" 자세**             | 표에 없음                                  | 0.069, 0.021 출력 ← **존재하지 않는 데이터** |

### 1.2 핵심 문제 정의

> 하나의 표(13-2-4)에 **V형**과 **U형** 두 가지 용접 유형이 있는데,  
> 데이터 파이프라인이 이를 구분 없이 같은 이름의 엔티티로 추출하여  
> **서로 다른 데이터가 혼재**된 결과를 출력했다.

---

## 2. 근본 원인 분석 (Root Cause)

### 2.1 원본 PDF 구조

```
[표 13-2-4] 강판 전기아크용접
├─ 1. 전기아크용접(V형)('93년 보완)  ← chunk C-0956-B 기반
│   - 자세: 하향 / 횡향 / 입향
│   - 두께: 3~15mm
│   - 항목: 용접봉사용량, 인력, 소요전력
│
└─ 2. 전기아크용접(U형)              ← chunk C-0956-M 기반
    - 자세: 하향 / 횡향 / 입향 / (상향?)
    - 두께: 3~15mm
    - 항목: 용접봉소비량, 인력, 소요전력
```

### 2.2 문제의 엔티티 비교

| 엔티티 ID  | 이름                                     | 출처 chunk   | 용접 유형     |
| ---------- | ---------------------------------------- | ------------ | ------------- |
| **W-0996** | 강판 전기아크용접(10, SCH **인 력**(인)) | C-0956-**B** | V형 (정확)    |
| **W-0997** | 강판 전기아크용접(10, SCH **인력**(인))  | C-0956-**M** | U형 (다른 표) |

- 이름 차이: `"인 력"` vs `"인력"` (공백 유무) → **사실상 같은 이름으로 보이지만 다른 데이터**
- 검색 시 둘 다 반환 → LLM이 혼합하여 출력

### 2.3 데이터 대조표 (두께 10mm 인력)

| 직종          | W-0996 (V형) | 원본 V형 | 일치? | W-0997 (U형) | 원본 V형 | 일치? |
| ------------- | ------------ | -------- | ----- | ------------ | -------- | ----- |
| 하향_용접공   | **0.087**    | 0.087    | ✅     | **0.048**    | 0.087    | ❌     |
| 하향_특별인부 | **0.020**    | 0.020    | ✅     | **0.013**    | 0.020    | ❌     |
| 횡향_용접공   | **0.106**    | 0.106    | ✅     | **0.062**    | 0.106    | ❌     |
| 횡향_특별인부 | **0.025**    | 0.025    | ✅     | **0.017**    | 0.025    | ❌     |
| 입향_용접공   | **0.121**    | 0.121    | ✅     | **0.073**    | 0.121    | ❌     |
| 입향_특별인부 | **0.030**    | 0.030    | ✅     | **0.022**    | 0.030    | ❌     |
| 상향_용접공   | -            | -        | -     | **0.069**    | 없음     | ❌     |
| 상향_특별인부 | -            | -        | -     | **0.021**    | 없음     | ❌     |

> W-0997(U형)의 값은 원본 V형 표와 불일치. U형 표의 값이 별도 존재할 것으로 추정.

---

## 3. 구조적 원인 4가지

### 3.1 원인 ①: V형/U형 미분리 추출

```
[표 13-2-4] 내 소제목 구조:
  "1. 전기아크용접(V형)" → chunk C-0956-B ~ L
  "2. 전기아크용접(U형)" → chunk C-0956-M ~ N

문제: 두 소제목을 별도 WorkType으로 구분하지 않음
결과: 같은 "강판 전기아크용접(10, SCH 인력(인))" 이름으로 2개 엔티티 생성
```

- **step1_table_extractor.py**의 `extract_from_a_table()`, `extract_from_matrix_table()`에서 소제목(V형/U형) 구분이 엔티티명에 반영되지 않음

### 3.2 원인 ②: "SCH" 잘못 삽입

| 원본 구분                 | 실제 의미            | DB 저장                  |
| ------------------------- | -------------------- | ------------------------ |
| 강판 두께(mm): 3, 4, 5... | 강판 두께 (밀리미터) | "10, **SCH**" ← 오류     |
| 강관 SCH: 10, 20, 30...   | 파이프 스케줄 번호   | "200, **SCH** 40" ← 정확 |

- **원인**: `step1_table_extractor.py`의 매트릭스 추출(`extract_from_matrix_table`)에서 강관용접(13-2-3)의 헤더 패턴(구경×SCH)을 강판 테이블에도 동일 적용
- **영향**: 모든 13-2-4 WorkType 124개 전부 "SCH" 포함

### 3.3 원인 ③: Chunk Text 누락 (43.1%)

| 지표                                 | 수치                    |
| ------------------------------------ | ----------------------- |
| **전체 chunk**                       | 2,105건                 |
| **text 비어있는 chunk**              | 908건 (**43.1%**)       |
| **13-2-4 chunk** (강판 전기아크용접) | 14건 중 **13건 text=0** |
| **text가 있는 chunk**                | C-0956-A만 220자        |

- **영향**: "전체 보기" 시 chunk text가 없어 LLM이 관계(relationship) 데이터에만 의존
- **원인**: 테이블이 주된 내용인 chunk에서 text 필드를 별도로 저장하지 않는 파이프라인 설계

### 3.4 원인 ④: normalized_name 기준 중복 엔티티

| 지표                      | 수치          |
| ------------------------- | ------------- |
| 전체 WorkType             | 4,733건       |
| normalized_name 중복 그룹 | 90건          |
| 추정 중복 엔티티 총수     | ~180건 (3.8%) |

- 이름 정규화(`normalized_name`) 과정에서 공백만 제거하므로, `"인 력"` → `"인력"`으로 정규화되어 같은 값이 됨
- 그러나 DB에는 정규화 전 이름으로 각각 저장되어 **사실상 중복**

---

## 4. 영향 범위

### 4.1 직접 영향

| 대상                                      | 영향                                                  |
| ----------------------------------------- | ----------------------------------------------------- |
| **강판 전기아크용접 전체** (124 WorkType) | "SCH" 오기, V/U형 미분리                              |
| **동일 패턴 섹션** (예: 다른 복합 표)     | 같은 파이프라인으로 추출된 유사 섹션에 동일 문제 가능 |
| **"전체 보기" 기능**                      | text 없는 chunk에서 불완전 응답                       |

### 4.2 간접 영향

| 기능            | 영향                                                |
| --------------- | --------------------------------------------------- |
| **벡터 검색**   | SCH 포함된 이름으로 임베딩 → 강관/강판 혼동 가능    |
| **키워드 검색** | "두께 10" 검색 시 V형, U형 모두 반환 → 혼란         |
| **비용 산출**   | 잘못된 수량(U형 값)으로 견적 계산 시 오차 발생 가능 |

---

## 5. 개선안

### 5.1 단기 조치 (Edge Function 레벨)

#### A. 결과 Deduplication

**목적**: 같은 규격의 중복 WorkType이 검색되면-→ 이름 유사도 기반으로 하나만 반환

```typescript
// 검색 결과에서 normalized_name 기준 중복 제거
function deduplicateWorkTypes(results: EntityResult[]): EntityResult[] {
    const seen = new Map<string, EntityResult>();
    for (const r of results) {
        const normName = r.name.replace(/\s+/g, '').toLowerCase();
        const existing = seen.get(normName);
        if (!existing || r.similarity > existing.similarity) {
            seen.set(normName, r);  // 유사도 높은 쪽 유지
        }
    }
    return Array.from(seen.values());
}
```

**적용 위치**: `targetSearch()`, `graphClarify()` 결과 반환 전
**효과**: 사용자에게 보이는 중복 제거 (DB 수정 불필요)

#### B. 메시지 문구 수정

**문제**: "3개 하위 절, 총 6개 작업" 메시지에서 하위 절이 선택지에 안 보임
**수정**: WorkType만 표시할 때는 하위 절 언급 제거

```typescript
// 기존 (L1122-1123)
if (workTypes.length > 0 && childSections.length > 0) {
    clarifyMessage = `**${sectionPath}** 품셈에는 ${childSections.length}개 하위 절, 
                      총 ${workTypes.length}개 작업이 있습니다.`;
}

// 수정안
if (workTypes.length > 0 && childSections.length > 0) {
    if (workTypes.length <= 10) {
        // WorkType 개별 표시 시 → 작업 수만 안내
        clarifyMessage = `**${sectionPath}** 품셈은 ${workTypes.length}개 작업으로 
                          분류되어 있습니다.\n어떤 작업의 품셈을 찾으시나요?`;
    } else {
        // 하위 절 단위로 표시 시 → 절 수 + 작업 수 안내
        clarifyMessage = `**${sectionPath}** 품셈에는 ${childSections.length}개 
                          분류, 총 ${workTypes.length}개 작업이 있습니다.
                          \n분류를 선택해 주세요.`;
    }
}
```

---

### 5.2 중기 조치 (데이터 패치)

#### C. 13-2-4 엔티티명에서 "SCH" 제거 + V/U형 구분 추가

```sql
-- 1단계: "SCH" 제거 + 두께(mm) 표기로 변경
UPDATE graph_entities 
SET name = REPLACE(name, ', SCH ', ', 두께 ')
WHERE source_section = '13-2-4' AND name LIKE '%SCH%';

-- 2단계: V형/U형 구분 추가 (chunk 기반)
-- C-0956-B~L → V형, C-0956-M~N → U형
UPDATE graph_entities 
SET name = REPLACE(name, '강판 전기아크용접(', '강판 전기아크용접-V형(')
WHERE source_section = '13-2-4' 
AND properties::text LIKE '%C-0956-B%'
OR properties::text LIKE '%C-0956-C%'
OR properties::text LIKE '%C-0956-D%';

UPDATE graph_entities 
SET name = REPLACE(name, '강판 전기아크용접(', '강판 전기아크용접-U형(')
WHERE source_section = '13-2-4' 
AND properties::text LIKE '%C-0956-M%'
OR properties::text LIKE '%C-0956-N%';
```

**효과**: 검색 시 V형/U형이 명확히 구분되어 사용자가 올바른 데이터 선택 가능

#### D. Chunk Text 보강

```sql
-- 13-2-4 하위 chunk에 최소한의 구분 텍스트 추가
UPDATE graph_chunks SET text = '1. 전기아크용접(V형) 테이블 데이터'
WHERE id IN ('C-0956-B','C-0956-C','C-0956-D','C-0956-E','C-0956-F',
             'C-0956-G','C-0956-H','C-0956-I','C-0956-J','C-0956-K','C-0956-L');

UPDATE graph_chunks SET text = '2. 전기아크용접(U형) 테이블 데이터'
WHERE id IN ('C-0956-M','C-0956-N');
```

---

### 5.3 장기 조치 (파이프라인 개선)

#### E. step1_table_extractor.py 수정

| 문제          | 수정 위치                     | 수정 내용                                                             |
| ------------- | ----------------------------- | --------------------------------------------------------------------- |
| 소제목 미반영 | `extract_from_a_table()`      | chunk 내 소제목(1. V형, 2. U형 등)을 WorkType 이름에 포함             |
| SCH 오적용    | `extract_from_matrix_table()` | 강판(plate) 테이블에서는 "두께(mm)" 사용, 강관(pipe)에서만 "SCH" 사용 |
| Text 미저장   | chunk 생성 로직               | 테이블 chunk에도 원문 텍스트 또는 구조화된 요약 저장                  |

#### F. 전체 DB 정합성 검증 스크립트

```python
# 검증 항목:
# 1. normalized_name 중복 그룹 → 실제 다른 데이터인지 확인
# 2. "SCH" 포함 엔티티 중 강관이 아닌 것 → 플래그
# 3. text=0 chunk → 원본 PDF 대조 후 보강 대상 목록 생성
# 4. V형/U형 같은 소제목 분리가 필요한 섹션 식별
```

---

## 6. 우선순위 및 실행 계획

| 순서  | 조치                             | 난이도 | 영향 범위        | 소요 시간 |
| ----- | -------------------------------- | ------ | ---------------- | --------- |
| **1** | A. Deduplication (Edge Function) | 낮음   | 검색 결과 전체   | 30분      |
| **2** | B. 메시지 문구 수정              | 낮음   | UX               | 10분      |
| **3** | C. 13-2-4 엔티티명 패치          | 중간   | 해당 섹션 124건  | 1시간     |
| **4** | D. Chunk Text 보강               | 중간   | 해당 섹션 13건   | 30분      |
| **5** | E. 파이프라인 수정               | 높음   | 전체 재추출 필요 | 1일+      |
| **6** | F. 전체 검증 스크립트            | 높음   | 전체 DB 4,733건  | 반나절    |

---

## 7. 부록: SQL 검증 쿼리

### 중복 엔티티 확인

```sql
SELECT properties->>'normalized_name' as norm_name, 
       count(*) as cnt, 
       array_agg(id) as entity_ids,
       array_agg(name) as names
FROM graph_entities 
WHERE type = 'WorkType'
GROUP BY properties->>'normalized_name'
HAVING count(*) > 1
ORDER BY cnt DESC
LIMIT 20;
```

### "SCH" 포함 비강관 엔티티 식별

```sql
SELECT ge.id, ge.name, ge.source_section, gc.title
FROM graph_entities ge
LEFT JOIN (SELECT DISTINCT ON (section_id) section_id, title FROM graph_chunks ORDER BY section_id) gc
ON ge.source_section = gc.section_id
WHERE ge.name LIKE '%SCH%'
AND gc.title NOT LIKE '%강관%'
ORDER BY ge.source_section;
```

### Empty chunk 비율 (섹션별)

```sql
SELECT section_id, title, 
       count(*) as chunks, 
       count(*) FILTER (WHERE length(text)=0 OR text IS NULL) as empty,
       round(100.0 * count(*) FILTER (WHERE length(text)=0 OR text IS NULL) / count(*), 0) as empty_pct
FROM graph_chunks 
GROUP BY section_id, title
HAVING count(*) FILTER (WHERE length(text)=0 OR text IS NULL) > 0
ORDER BY chunks DESC
LIMIT 20;
```

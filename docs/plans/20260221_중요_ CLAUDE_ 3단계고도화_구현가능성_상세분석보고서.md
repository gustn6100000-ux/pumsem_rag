# 건설품셈 RAG 시스템 — 3단계 고도화 구현 가능성 및 상세 분석 보고서

**작성일**: 2026-02-21
**분석 대상**: 3단계 고도화 구현 계획서 (Phase 1: 노임단가 / Phase 2: 듀얼 모델 라우팅 / Phase 3: 복합 추론)
**분석 방법**: 실제 코드베이스(`edge-function/*.ts`, `pipeline/sql/*.sql`) 전수 확인 기반 검증

---

## 1. 분석 요약

| Phase | 구현 가능성 | 핵심 이슈 | 수정 필요 사항 |
|-------|:----------:|-----------|---------------|
| **Phase 1** (노임단가 사전연산) | ✅ 100% | 즉시 구현 가능 | `findBestCostMatch()` 헬퍼 추가, `related_name` 정제 |
| **Phase 2** (듀얼 모델 라우팅) | ⚠️ 80% | 분기 위치 오류, reasoner system role 미지원 가능성 | `handleChat` Route 4 직전에 삽입, system→user prefix 폴백 |
| **Phase 3** (복합 추론 허용) | ⚠️ 70% | 환각 억제 vs 우회 추론 규칙이 논리적으로 모순 | SYSTEM_PROMPT 직접 주입 대신 Reasoner 마스터플랜 경유로 한정 |

---

## 2. Phase 1: 노임단가 사전연산 — 상세 검증

### 2-1. 현재 코드 상태 확인

**대상 파일**: `index.ts:356-373` (answerPipeline의 `[4-1]` 블록)

```typescript
// 현재 코드 (index.ts:358-371)
const laborNames = relationsAll.flat()
    .filter(r => r.relation === "REQUIRES_LABOR")
    .map(r => r.related_name)
    .filter(Boolean);
if (laborNames.length > 0) {
    const laborCosts = await fetchLaborCosts(laborNames);
    if (laborCosts.length > 0) {
        context += "\n\n## [2026년 노임단가]\n";
        context += "| 직종 | 노임단가(원/일) |\n|---|---:|\n";
        laborCosts.forEach(lc => {
            context += `| ${lc.job_name} | ${lc.cost_2026.toLocaleString()} |\n`;
        });
    }
}
```

**문제점**: 단가표만 context에 주입하고, `(투입수량 × 노임단가 = 금액)` 곱셈을 LLM에게 위임 → LLM 연산 환각 발생

### 2-2. 계획서 diff 검증 결과 — 방향은 정확, 보정 3건 필요

계획서에서 제안한 diff(백엔드 사전연산 로직)는 기술적 방향이 올바르며 즉시 구현 가능합니다.
단, 아래 3건의 보정이 반드시 필요합니다.

---

#### 보정 1) `laborNames` 변수명 충돌 및 타입 혼동

**문제 코드** (계획서 diff):
```typescript
const laborNames = relationsAll.flat()
    .filter(r => r.relation === "REQUIRES_LABOR")
    .map(r => ({
        name: r.related_name,
        quantity: (r.properties as any)?.quantity ?? 0,
        unit: (r.properties as any)?.unit ?? "인",
        work_type: (r.properties as any)?.work_type_name ?? "",
    }))
    .filter(Boolean);  // ← 객체는 항상 truthy → 필터 무의미
```

**문제**:
- 기존 `laborNames`는 `string[]`이었으나, 변경 후 `{name, quantity, unit, work_type}[]` 객체 배열로 타입이 바뀜
- `.filter(Boolean)`은 객체에 대해 항상 `true` → 실질적으로 무효 코드
- 바로 아래에서 `laborNames.map(l => l.name)`으로 접근하므로 동작은 하지만, 변수명이 혼란스러움

**보정안**:
```typescript
// 변수명을 laborItems로 변경하여 의도 명확화
const laborItems = relationsAll.flat()
    .filter(r => r.relation === "REQUIRES_LABOR")
    .map(r => {
        const props = (r.properties || {}) as any;
        return {
            name: r.related_name || "",
            quantity: parseFloat(props.quantity) || 0,  // 문자열→숫자 안전 변환
            unit: props.unit ?? "인",
            work_type: props.work_type_name ?? "",
            per_unit: props.per_unit ?? "",
            source_spec: props.source_spec ?? "",
        };
    })
    .filter(item => item.name);  // 이름이 빈 문자열인 항목 제거

const uniqueJobNames = [...new Set(laborItems.map(l => l.name))];
```

---

#### 보정 2) `related_name` 정제 로직 누락 — **치명적 누락**

**근거**: `index.ts:65-70`의 `renderMatrixTable()` 내부에서 확인된 현재 코드:

```typescript
// index.ts:65-70 — renderMatrixTable 내부
const rows: Row[] = items.map((item) => {
    const props = (item.properties || {}) as any;
    let specFallback = "-";
    if (item.related_name.includes('_')) specFallback = item.related_name.split('_')[0];
    const spec = props.source_spec || props.spec || props.per_unit || props.work_type_name || specFallback;
    const itemName = item.related_name.includes('_') ? item.related_name.split('_')[1] : item.related_name;
    //                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //                                                 spec prefix 분리: "200_SCH_40_용접공" → "용접공"
```

**문제**:
`related_name`은 `"200_SCH_40_용접공"` 형태로 spec prefix가 포함될 수 있습니다.
계획서의 diff에서는 `l.name`(= `r.related_name`)을 정제 없이 그대로 `fetchLaborCosts()`에 전달합니다.
`fetchLaborCosts()`는 `graph.ts:325`에서 LIKE 패턴을 생성하는데:

```typescript
// graph.ts:325
const patterns = jobNames.map(name => name.replace(/\s+/g, '%'));
// "200_SCH_40_용접공" → "200_SCH_40_용접공" (공백이 없으므로 변환 안 됨)
// → labor_costs 테이블에서 "200_SCH_40_용접공"을 ILIKE 매칭 → 매칭 실패!
```

**보정안**:
```typescript
// laborItems 생성 시 name 정제 포함
const rawName = r.related_name || "";
const cleanName = rawName.includes('_')
    ? rawName.split('_').slice(-1)[0]  // 마지막 '_' 이후 = 직종명
    : rawName;
return {
    name: cleanName,
    rawName: rawName,  // 원본 보존 (디버깅용)
    // ...
};
```

**이 보정 없이 배포하면**: `fetchLaborCosts()`에서 `"200_SCH_40_용접공"`을 검색하여 매칭 실패 → 단가 0원 → 전체 산출 금액이 0원으로 출력되는 **서비스 장애** 발생.

---

#### 보정 3) `costMap` 1:N 매칭 문제

**근거**: `graph.ts:323-337`의 `fetchLaborCosts()`:

```typescript
// graph.ts:325-329
const patterns = jobNames.map(name => name.replace(/\s+/g, '%'));
const { data, error } = await supabase
    .from("labor_costs")
    .select("job_name, cost_2026")
    .or(patterns.map(p => `job_name.ilike.%${p}%`).join(','));
```

**문제**:
`related_name = "용접공"`에 대해 `labor_costs` 테이블에서 ILIKE `%용접공%` 매칭 시:
- `"용접공"` ← 정확 매칭
- `"플랜트용접공"` ← 부분 매칭
- `"특수용접공"` ← 부분 매칭

**복수 행이 반환**됩니다. 계획서에서:

```typescript
const costMap = new Map(laborCosts.map(lc => [lc.job_name, lc.cost_2026]));
```

`Map`은 동일 key에 대해 마지막 값만 보존하므로, `"용접공"` key에 `"특수용접공"`의 단가가 덮어쓰일 수 있습니다.
그러나 여기서는 key가 `lc.job_name`(DB의 직종명)이므로 key 자체는 고유합니다.
문제는 **역방향 매칭**: `laborItems`의 `"용접공"`에 대해 `costMap`에서 어떤 key를 선택할지 결정하는 로직이 없습니다.

**보정안**: Phase 4.1 계획서에서 작성한 `findBestCostMatch()` 헬퍼를 반드시 적용:

```typescript
function findBestCostMatch(
    jobName: string,
    costMap: Map<string, number>
): { name: string; cost: number } | null {
    // 1) 정확 일치
    if (costMap.has(jobName)) {
        return { name: jobName, cost: costMap.get(jobName)! };
    }
    // 2) 공백 제거 정확 일치
    const normalized = jobName.replace(/\s+/g, '');
    for (const [key, cost] of costMap) {
        if (key.replace(/\s+/g, '') === normalized) {
            return { name: key, cost };
        }
    }
    // 3) 부분 문자열 포함 (shorter ⊂ longer)
    for (const [key, cost] of costMap) {
        const keyNorm = key.replace(/\s+/g, '');
        if (keyNorm.includes(normalized) || normalized.includes(keyNorm)) {
            return { name: key, cost };
        }
    }
    // 4) 매칭 실패
    return null;
}
```

### 2-3. Phase 1 종합 판정

| 항목 | 판정 | 비고 |
|------|:----:|------|
| diff 방향성 | ✅ 정확 | 백엔드 사전연산 → LLM 복사 출력 전략 유효 |
| `laborNames` 타입 | ⚠️ 보정 필요 | 변수명 변경 + `parseFloat` 안전 변환 |
| `related_name` 정제 | ❌ 치명적 누락 | `split('_')` 정제 없이 배포하면 단가 0원 장애 |
| `costMap` 매칭 | ⚠️ 보정 필요 | `findBestCostMatch()` 헬퍼 추가 |
| `llm.ts` 프롬프트 강화 | ✅ 정확 | "사전연산 테이블 그대로 복사" 지시 적절 |
| 기존 코드 파급효과 | ✅ 안전 | `search.ts`, `graph.ts`, `clarify.ts` 변경 없음 |

**결론**: 보정 3건을 반영하면 **즉시 구현 및 배포 가능**.

---

## 3. Phase 2: 듀얼 모델 라우팅 — 상세 검증

### 3-1. DeepSeek API 호환성 확인

**현재 설정** (`config.ts:12-13`):
```typescript
export const DEEPSEEK_API_KEY = Deno.env.get("DEEPSEEK_API_KEY") || "";
export const DEEPSEEK_URL = "https://api.deepseek.com/chat/completions";
```

**현재 호출 방식** (`llm.ts:125-137`):
```typescript
const response = await fetch(DEEPSEEK_URL, {
    method: "POST",
    headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${DEEPSEEK_API_KEY}`,
    },
    body: JSON.stringify({
        model: "deepseek-chat",      // ← 이것만 "deepseek-reasoner"로 변경
        messages,
        temperature: 0.3,
        max_tokens: 4096,
    }),
});
```

**검증 결과**:
- ✅ API 엔드포인트: `https://api.deepseek.com/chat/completions` → chat과 reasoner 모두 동일 URL 사용 가능
- ✅ API Key: 동일한 키 사용 가능 — 별도 키 발급 불필요
- ✅ `model` 파라미터 변경만으로 모드 전환 가능

### 3-2. classifyComplexity() 함수 — 적절성 검증

**삽입 위치**: `clarify.ts` — ✅ 적절
**이유**: 기존 `analyzeIntent()`와 독립적인 순수 함수이며, `clarify.ts`에 의도 분석 관련 로직이 집중되어 있으므로 관심사 일치.

**키워드 기반 점수 체계 검증**:

| 기준 | 점수 | 평가 |
|------|:----:|------|
| 질문 길이 80자 초과 | +1 | ✅ 합리적 — 복합 조건 질문은 대체로 길다 |
| 질문 길이 150자 초과 | +1 | ✅ 합리적 |
| 복수 공종 키워드 (≥2) | +2 | ✅ 핵심 지표 — "덕트 해체 + 보온 철거" 감지 |
| 조건 키워드 (할증, 고소 등) | 각 +1 | ⚠️ 과민 가능 — "고소작업"만 언급해도 +1, 단순 질문도 complex 판정 가능 |
| 물리량 단위 패턴 | +1 | ✅ 합리적 |
| 물성 키워드 (두께, 외경 등) | +1 | ✅ 합리적 |
| 가이드 요청 키워드 | +1 | ⚠️ "기준" 같은 일반 단어가 포함되면 오탐 가능 |

**보정 권장**:
- 임계값 3점은 약간 낮을 수 있음 → 초기에는 **4점**으로 시작하고, 로그 분석 후 조정 권장
- 조건 키워드 점수를 개별 +1이 아닌, `matchedConditions.length >= 2`일 때 +2로 묶으면 단일 조건 질문의 오탐 방지

### 3-3. ⚠️ Warning A: `deepseek-reasoner`의 system role 제한

**문제**:
DeepSeek Reasoner API는 `system` role 메시지를 **지원하지 않거나 무시할 수 있습니다**.
계획서의 `generateReasoningGuide()`에서:

```typescript
const messages = [
    { role: "system" as const, content: REASONER_SYSTEM_PROMPT },  // ← 무시될 수 있음
    ...history.slice(-3).map(msg => ({ ... })),
    { role: "user" as const, content: question },
];
```

**확인 필요 사항**:
DeepSeek Reasoner가 system role을 지원하는지 API 문서 확인. 지원하지 않을 경우:

**폴백 전략**:
```typescript
// system role을 첫 번째 user 메시지에 합침
const messages = [
    {
        role: "user" as const,
        content: `[시스템 지시]\n${REASONER_SYSTEM_PROMPT}\n\n[사용자 질문]\n${question}`,
    },
];
```

**추가 주의점**:
- `temperature` 파라미터: reasoner 모드에서는 **자동 제어**되므로 명시하면 에러 발생 가능 → 제거 필요
- `max_tokens`: reasoner는 기본 32K까지 지원하므로 계획서의 8192는 적절

### 3-4. ⚠️ Warning B: `handleChat()` 분기 삽입 위치 — **구조적 오류**

**계획서 원문**: "analyzeIntent() 호출 직후 삽입"

**실제 `handleChat()` 라우팅 순서** (`index.ts:800-931`):

```
analyzeIntent()
  ↓
Route 1: entity_id 직접 조회 (칩 클릭)           ← L800~
Route 2: section_id full_view                     ← L820~
  ↓
greeting 처리                                      ← L840~
cost_calculate → entity 재귀 호출                  ← L851~
modify_request → 수량/공종 변경                    ← L868~
report_request → 산출서 재귀 호출                  ← L902~
clarify_needed → graphClarify                      ← L919~
  ↓
Route 4: search → searchPipeline                   ← L930
```

**문제**:
`analyzeIntent()` 직후에 `complexity === "complex"` 분기를 삽입하면:

1. `entity_id`가 주어진 상태에서 복잡한 질문 → Route 1 우회 → **칩 클릭 동작 깨짐**
2. `cost_calculate` intent인데 복잡도 3점 이상 → Reasoner 경로로 빠짐 → **기존 노임단가 사전연산(Phase 1) 무시**
3. `clarify_needed` intent인데 복잡도 3점 이상 → 명확화 절차 건너뜀 → **규격 미확인 상태에서 Reasoner 가동**

**올바른 삽입 위치**: Route 4(`searchPipeline`) 직전, 즉 `index.ts:930` 바로 위:

```typescript
// index.ts:929 부근 — Route 4 직전에 삽입

// ─── Route 3.5: 복합 질문 → Reasoner 경로 ───
const complexity = classifyComplexity(question, analysis);
console.log(`[handleChat] complexity=${complexity}, intent=${analysis.intent}`);

if (complexity === "complex") {
    console.log(`[handleChat] 🧠 사고 모드(deepseek-reasoner) 가동`);
    // ... Reasoner 마스터플랜 → 다중 검색 → Chat 최종 답변
    return complexAnswerPipeline(question, analysis, history, startTime);
}

// ═══ Route 4: search → searchPipeline (기존 단순 경로) ═══
return searchPipeline(analysis, question, history, startTime, answerOptions);
```

**이유**: 이 위치라면:
- ✅ Route 1 (entity_id 직접) → 정상 작동
- ✅ cost_calculate → Phase 1 사전연산 경로 → 정상 작동
- ✅ clarify_needed → 명확화 절차 → 정상 작동
- ✅ intent가 `search`이면서 복잡도가 높을 때만 Reasoner 가동

### 3-5. ⚠️ Warning C: `targetSearch`, `generateEmbedding` export 확인

계획서의 complex 경로에서 사용하는 함수들:

```typescript
const taskEmbedding = await generateEmbedding(task.search_keywords.join(" "));
const taskEntities = await targetSearch(analysis, taskEmbedding, rawQuery);
```

**`search.ts` export 상태 확인 결과**:

```typescript
// search.ts 상단 — export 여부 확인 필요
export async function targetSearch(...): Promise<EntityResult[]>  // ← export 되어 있는지?
function generateEmbedding(...): Promise<number[]>                // ← export 안 되어 있을 가능성
```

**확인 필요 사항**:
- `targetSearch`: `index.ts`에서 이미 import하여 `searchPipeline` 내부에서 사용 중이라면 export 확인됨
- `generateEmbedding`: `search.ts` 내부 전용 함수일 가능성 → export 추가 필요

**대안**: `generateEmbedding`이 export 되어 있지 않다면, `search.ts`에서 export를 추가하거나, `targetSearch`에 키워드만 전달하는 래퍼 함수를 만들어 임베딩 생성을 내부에서 처리:

```typescript
// search.ts에 추가
export async function searchByKeywords(
    keywords: string[],
    analysis: IntentAnalysis
): Promise<EntityResult[]> {
    const embedding = await generateEmbedding(keywords.join(" "));
    return targetSearch(analysis, embedding, keywords.join(" "));
}
```

### 3-6. Phase 2 종합 판정

| 항목 | 판정 | 비고 |
|------|:----:|------|
| API 호환성 (동일 URL, 동일 Key) | ✅ 정확 | `model` 파라미터 변경만으로 모드 전환 |
| `classifyComplexity()` | ✅ 구현 가능 | 임계값 4점으로 보수적 시작 권장 |
| `generateReasoningGuide()` | ⚠️ 보정 필요 | system role → user prefix 폴백, temperature 제거 |
| `handleChat()` 분기 위치 | ❌ 구조적 오류 | Route 4 직전으로 이동 필수 |
| `targetSearch` / `generateEmbedding` | ⚠️ 확인 필요 | export 상태에 따라 래퍼 함수 추가 |
| Reasoner 응답 파싱 | ⚠️ 방어 필요 | JSON.parse 실패 시 기본 search 경로로 폴백 |
| 비용 예측 (월 +₩2,400) | ✅ 현실적 | 20% 복합 질문에만 reasoner 사용 |

**결론**: Warning B(분기 위치)를 수정하면 **구현 가능**. system role 제한은 API 문서 확인 후 대응.

---

## 4. Phase 3: 복합 추론 파이프라인 — 상세 검증

### 4-1. 도메인 수학 공식 주입 — ✅ 즉시 적용 가능

SYSTEM_PROMPT에 추가하는 공식:
```
- 원통 표면적: π × 외경(m) × 길이(m) = ㎡
- 강판 중량: π × 외경(m) × 두께(m) × 비중(7.85) × 길이(m) = kg/m
- 1톤 환산 길이: 1000kg ÷ (단위중량 kg/m) = m
- 면적 환산: 원형 단면 → π × (D/2)² = ㎡
```

**평가**: 이 공식들은 사실에 기반한 고정값(비중 7.85 등)이므로 환각 위험 없이 LLM이 참조할 수 있습니다.
단, **LLM이 곱셈을 직접 수행**하므로 Phase 1과 동일한 연산 환각 위험이 있습니다.

**권장**: 공식은 SYSTEM_PROMPT에 넣되, 실제 계산은 **Reasoner 마스터플랜의 `calculations` 필드를 백엔드에서 실행**하는 구조가 이상적:

```typescript
// Reasoner가 반환한 calculations를 백엔드에서 eval
parsedGuide.calculations.forEach(calc => {
    // π × 1.3 × L = ㎡ → 백엔드에서 안전하게 계산
    // 결과를 context에 "계산 완료: 표면적 = 4.08㎡" 형태로 주입
});
```

### 4-2. IntentAnalysis 타입 확장 — ✅ 안전

```typescript
// types.ts 변경
intent: "search" | "clarify_needed" | ... | "complex_estimate";  // 추가
complexity?: "simple" | "complex";                                 // 추가
```

**파급효과 분석**:
- TypeScript union type 확장이므로 기존 코드에 **영향 없음**
- `clarify.ts`의 `analyzeIntent()`가 반환하는 intent에 `"complex_estimate"`가 추가되려면, `INTENT_SYSTEM_PROMPT`(라인 36-92)에도 해당 intent를 설명해야 함
- 단, Phase 2의 `classifyComplexity()`가 intent와 독립적으로 복잡도를 판단하므로, `"complex_estimate"` intent를 추가하지 않고도 듀얼 라우팅은 작동함

### 4-3. ⚠️ Warning D: 환각 억제 vs 우회 추론 — **최대 리스크 영역**

#### 현재 시스템의 핵심 안전장치

`llm.ts:7-11` (SYSTEM_PROMPT):
```
"답변 시 반드시 제공된 컨텍스트의 데이터만 사용하며,
 컨텍스트에 없는 정보는 추측하지 않습니다."
```

`llm.ts:63-67` ([금지 사항]):
```
"- 컨텍스트에 없는 수치나 기준을 임의로 생성하지 않습니다."
"- '일반적으로', '보통', '대략' 등 모호한 표현 대신 정확한 수치를 사용합니다."
```

#### Phase 3에서 추가하려는 규칙

```
"품셈 DB에 정확히 없을 경우:
 - '해당 규격은 품셈에 없습니다'로 끝내지 말고,
 - 성질이 가장 유사한 상위 품셈을 차용하되,
 - 근거를 명시하세요."
```

#### 모순 분석

이 두 규칙은 **논리적으로 양립 불가능**합니다:

| 상황 | 규칙 A (환각 억제) | 규칙 B (우회 추론) | LLM 판단 |
|------|-------------------|-------------------|----------|
| 1300mm 덕트 → DB에 없음 | "없다고 답하라" | "유사 품셈을 차용하라" | **충돌** |
| 4T 강판 철거 → DB에 없음 | "추측하지 마라" | "철골재 철거를 준용하라" | **충돌** |
| 단순 질문 → DB에 있음 | "컨텍스트만 사용" | (해당 없음) | 정상 |

LLM은 매번 "이건 context에 있는 데이터인가, 없으니 우회해야 하는가"를 **자체 판단**해야 합니다.
이 판단 자체가 환각의 온상이 됩니다:
- "1300mm 덕트"가 context에 없을 때, LLM이 **"비슷한 게 있으니 이걸 써야지"** 라고 자의적으로 판단
- 때로는 실제로 DB에 있는데도 **"없다고 판단하고 다른 것을 차용"** → 정확한 데이터 무시

#### 해결 방향: Reasoner 마스터플랜 경유로 한정

```
❌ 위험한 접근: SYSTEM_PROMPT에 "우회 추론 허용" 직접 삽입
   → LLM이 자의적으로 우회 판단 → 환각 → 기존 S급 정확도 붕괴

✅ 안전한 접근: Reasoner 마스터플랜 → DB 실검색 → context에 실제 데이터만 주입
   → Reasoner: "4T 덕트 → 철골재 철거 품셈을 검색하라" (search_tasks 생성)
   → 백엔드: search_tasks로 DB 검색 → 실제 엔티티/관계 데이터 획득
   → Chat: context에 있는 DB 데이터만으로 답변 (기존 규칙 유지)
```

**이 구조에서는**:
- "우회 추론"은 **Reasoner(사고 모드)**가 담당 → 검색 키워드/공식 가이드만 생성
- "데이터 출력"은 **Chat(비사고 모드)**가 담당 → context에 있는 실제 DB 데이터만 사용
- SYSTEM_PROMPT의 환각 억제 규칙은 **그대로 유지** → 기존 정확도 보존

### 4-4. ⚠️ Warning E: `[금지 사항]` 섹션과의 충돌

Phase 3의 우회 추론을 SYSTEM_PROMPT에 직접 넣으면, 기존 금지 사항과 정면 충돌합니다:

**현재 금지 사항** (`llm.ts:63-68`):
```
- 컨텍스트에 없는 수치나 기준을 임의로 생성하지 않습니다.
- "일반적으로", "보통", "대략" 등 모호한 표현 대신 정확한 수치를 사용합니다.
```

**Phase 3 우회 추론 시 불가피한 표현**:
- "해당 규격은 일반 OO 범위를 **벗어나므로**" ← 모호한 판단
- "△△ 품셈을 **준용합니다**" ← context에 없는 판단 근거

**조건부 완화가 필요한 경우**: Reasoner 마스터플랜 경유 구조를 채택하면, Chat 단계에서는 여전히 "context에 있는 데이터만 사용"하므로 금지 사항 수정이 불필요합니다.
단, Reasoner가 생성한 `reasoning_summary`를 context에 포함시킬 때, Chat에게 "이 요약은 참고 정보이며 직접 인용하지 마라"는 가드레일 추가 권장:

```typescript
combinedContext += `## [AI 추론 가이드 (참고용 — 직접 인용 금지)]\n`;
combinedContext += `${parsedGuide.reasoning_summary}\n\n`;
combinedContext += `## [DB 검색 결과 (아래 데이터만 사용하여 답변)]\n`;
// ... 실제 DB 검색 결과
```

### 4-5. Phase 3 종합 판정

| 항목 | 판정 | 비고 |
|------|:----:|------|
| 도메인 수학 공식 주입 | ✅ 안전 | 고정 상수(비중 7.85 등) → 환각 위험 없음 |
| IntentAnalysis 타입 확장 | ✅ 안전 | union type 확장, 기존 코드 무영향 |
| 우회 추론 허용 규칙 (SYSTEM_PROMPT) | ❌ 위험 | 환각 억제 규칙과 논리적 모순 → **Reasoner 경유로 한정** |
| 금지 사항 섹션 충돌 | ❌ 위험 | Reasoner 구조 채택 시 수정 불필요 |
| 다중 공종 분해 | ✅ Reasoner 의존 | `search_tasks` 배열로 자연스럽게 구현 가능 |

**결론**: 도메인 수학 공식은 즉시 추가 가능. 우회 추론 규칙은 **SYSTEM_PROMPT가 아닌 Reasoner 마스터플랜 전용으로 격리**해야 안전.

---

## 5. 전체 파급효과 매트릭스

### 5-1. 파일별 변경 영향 범위

| 파일 | Phase 1 | Phase 2 | Phase 3 | 변경 수준 |
|------|:-------:|:-------:|:-------:|:---------:|
| `index.ts` | ✏️ L356-373 수정 | ✏️ L929 분기 추가 | — | 중 |
| `llm.ts` | ✏️ L82-92 수정 | ✏️ 함수 추가 | ✏️ SYSTEM_PROMPT 추가 | 중 |
| `clarify.ts` | — | ✏️ 함수 추가 | — | 소 |
| `types.ts` | — | ✏️ 타입 확장 | — | 소 |
| `search.ts` | — | ⚠️ export 확인 | — | 소 |
| `graph.ts` | — | — | — | **변경 없음** |
| `context.ts` | — | — | — | **변경 없음** |
| `resolve.ts` | — | — | — | **변경 없음** |
| `config.ts` | — | — | — | **변경 없음** |

### 5-2. 기존 Route별 영향 분석

| 기존 Route | Phase 1 | Phase 2 | Phase 3 |
|-----------|:-------:|:-------:|:-------:|
| Route 1 (entity_id 직접) | ✅ 무영향 | ✅ 무영향 (분기 이전) | ✅ 무영향 |
| Route 2 (section_id full_view) | ✅ 무영향 | ✅ 무영향 (분기 이전) | ✅ 무영향 |
| cost_calculate | ✅ 사전연산 적용 | ✅ 무영향 (분기 이전) | ✅ 무영향 |
| clarify_needed | ✅ 무영향 | ✅ 무영향 (분기 이전) | ✅ 무영향 |
| Route 4 (search) | ✅ 무영향 | ⚠️ complex 시 우회 | ⚠️ 공식 추가 영향 |

---

## 6. 권장 구현 순서

```
Phase 1 (즉시 — 1일)
  ├─ index.ts: 사전연산 로직 + findBestCostMatch()
  ├─ llm.ts: cost_calculate 프롬프트 강화
  └─ 배포 후 검증: "강관용접 200mm SCH 40 10개소 노무비"
       ↓
Phase 2-1 (1~2일)
  ├─ clarify.ts: classifyComplexity() 추가 (임계값 4점)
  ├─ llm.ts: generateReasoningGuide() 추가
  ├─ DeepSeek Reasoner API system role 지원 여부 확인
  └─ 단위 테스트: complexity 점수 로깅 확인
       ↓
Phase 2-2 (1일)
  ├─ index.ts: handleChat Route 4 직전에 complex 분기 삽입
  ├─ search.ts: generateEmbedding export 확인/추가
  └─ 배포 후 검증: "원형 덕트 4T 1300mm 해체" → Reasoner 로그 확인
       ↓
Phase 3 (2~3일)
  ├─ llm.ts: SYSTEM_PROMPT에 도메인 수학 공식만 추가
  ├─ Reasoner SYSTEM_PROMPT에 우회 추론 규칙 격리
  ├─ ❌ Chat SYSTEM_PROMPT에는 우회 추론 규칙 넣지 않음
  └─ 배포 후 검증: NotebookLM 비교 테스트
```

---

## 7. 최종 결론

### 핵심 판정

**계획서 전체의 아키텍처 방향은 정확합니다.** "Reasoner가 추론, Chat이 출력"이라는 역할 분리는 "환각 억제 + 복합 추론"이라는 상충 목표를 양립시키는 유일한 구조입니다.

### 반드시 수정해야 하는 3가지

1. **Phase 1 — `related_name` 정제**: `"200_SCH_40_용접공"` → `"용접공"` 변환 없이 배포하면 단가 0원 장애 발생
2. **Phase 2 — 분기 위치**: `analyzeIntent()` 직후가 아닌 **Route 4 직전**에 삽입해야 기존 라우팅 보존
3. **Phase 3 — 우회 추론 규칙 격리**: SYSTEM_PROMPT에 직접 넣으면 기존 S급 정확도 붕괴 → **Reasoner 전용으로 격리**

### 수정하면 좋은 2가지

4. `classifyComplexity()` 임계값을 3점 → **4점**으로 보수적 시작
5. `deepseek-reasoner` 호출 시 `temperature` 제거 + system role 폴백 준비

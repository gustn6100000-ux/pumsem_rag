# Phase 4: 데이터 정합성 개선 — 상세 구현 계획서

> **일시**: 2026-02-13 23:18  
> **근거문서**: `20260213_Phase4_데이터정합성_분석보고서.md`  
> **목표**: 품셈 원본 PDF와 챗봇 결과물 간 데이터 불일치를 해소하고, 전체 DB의 구조적 정합성을 확보한다.

---

## Phase 구성 개요

| Phase  | 이름                    | 범위              | 소요시간 | 리스크 |
| ------ | ----------------------- | ----------------- | -------- | ------ |
| **4A** | Edge Function 즉시 수정 | `index.ts` 코드만 | 40분     | 낮음   |
| **4B** | DB 데이터 패치          | SQL 직접 수정     | 1.5시간  | 중간   |
| **4C** | 추출 파이프라인 개선    | Python 코드 수정  | 4시간+   | 높음   |

> **실행 전략**: 4A → 4B → 4C 순서.  
> 4A는 **코드만 수정**하므로 즉시 배포 가능. DB에 영향 없음.  
> 4B는 **SQL UPDATE 실행**으로 기존 데이터를 직접 수정. 백업 권장.  
> 4C는 **Python 추출기 수정** 후 재추출. 전체 영향이 크므로 별도 세션 필요.

---

## Phase 4A: Edge Function 즉시 수정

### 4A-1. WorkType Deduplication (중복 제거)

**문제**: `normalized_name`이 같지만 미세한 이름 차이("인 력" vs "인력")로 중복 WorkType이 검색 결과에 모두 나타남.

**영향 규모**: DB 전체 90그룹, ~180건 (4,733 WorkType의 3.8%)

**수정 파일**: `index.ts`

**수정 위치**: 새 유틸리티 함수 추가 (L390 부근, `chunkTextFallbackSearch` 다음)

```typescript
// ─── E-2.5. WorkType 중복 제거 ───
// Why: 같은 표에서 V형/U형 등 소제목이 분리 추출되어
//      "인 력(인)" vs "인력(인)" 같은 미세 차이로 중복 엔티티 존재.
//      검색 결과에서 normalized_name 기준으로 가장 유사도 높은 것만 유지.
function deduplicateResults(results: EntityResult[]): EntityResult[] {
    const seen = new Map<string, EntityResult>();
    for (const r of results) {
        // 정규화: 공백 제거 + 소문자
        const normKey = r.name.replace(/\s+/g, '').toLowerCase();
        const existing = seen.get(normKey);
        if (!existing || r.similarity > existing.similarity) {
            seen.set(normKey, r);
        }
    }
    return Array.from(seen.values());
}
```

**적용 위치 3곳**:

| #   | 함수                     | 위치                               | 적용 방법                                             |
| --- | ------------------------ | ---------------------------------- | ----------------------------------------------------- |
| 1   | `targetSearch()`         | 최종 return 전                     | `return deduplicateResults(allResults);`              |
| 2   | `graphClarify()` Step 2  | WorkType 목록 생성 후 (L1083 이후) | `workTypes = deduplicateResults(workTypes.map(...));` |
| 3   | `graphClarify()` Phase 3 | 결과 정렬 후 (L1350 부근)          | `const deduped = deduplicateResults(scored);`         |

**적용 상세 (targetSearch)**:

```typescript
// 현재 (L1485~)
async function targetSearch(...): Promise<EntityResult[]> {
    // ... 1~4단계 검색 ...
    return allResults; // ← 여기서 중복 포함 반환
}

// 수정
async function targetSearch(...): Promise<EntityResult[]> {
    // ... 1~4단계 검색 ...
    return deduplicateResults(allResults); // ← 중복 제거 후 반환
}
```

**적용 상세 (graphClarify Step 2 — L1039~1083)**:

```typescript
// 현재
let workTypes = (exactWTs || []) as any[];
// ... 하위 절 탐색으로 workTypes 갱신 ...

// 수정: 하위 절 WorkType 취합 후 dedup
// L1083 이후에 추가
const uniqueWTs = new Map<string, any>();
for (const wt of workTypes) {
    const normKey = wt.name.replace(/\s+/g, '').toLowerCase();
    if (!uniqueWTs.has(normKey)) {
        uniqueWTs.set(normKey, wt);
    }
}
workTypes = Array.from(uniqueWTs.values());
console.log(`[graphClarify] Step 2: dedup 후 ${workTypes.length}개 WorkType`);
```

---

### 4A-2. 메시지 문구 수정

**문제**: "3개 하위 절, 총 6개 작업" 메시지에서 하위 절이 선택지에 안 보여 혼란

**수정 위치**: L1120-1128

```typescript
// ── 현재 코드 (L1120-1128) ──
let clarifyMessage: string;
if (workTypes.length > 0 && childSections.length > 0) {
    clarifyMessage = `**${sectionPath}** 품셈에는 ${childSections.length}개 하위 절, 총 ${workTypes.length}개 작업이 있습니다.\n어떤 항목의 품셈을 찾으시나요?`;
} else if (workTypes.length > 0) {
    clarifyMessage = `**${sectionPath}** 품셈은 ${workTypes.length}개 작업으로 분류되어 있습니다.\n어떤 작업의 품셈을 찾으시나요?`;
} else {
    clarifyMessage = `**${sectionPath}** 품셈의 상세 작업이 개별 등록되어 있지 않습니다.\n아래 \"전체 내용 보기\" 버튼으로 해당 절의 품셈 데이터를 확인해 주세요.`;
}

// ── 수정 코드 ──
let clarifyMessage: string;
if (workTypes.length > 0 && childSections.length > 0) {
    if (workTypes.length <= 10) {
        // WorkType 개별 표시 모드 → 하위 절 언급 제거
        clarifyMessage = `**${sectionPath}** 품셈은 ${workTypes.length}개 작업으로 분류되어 있습니다.\n어떤 작업의 품셈을 찾으시나요?`;
    } else {
        // 하위 절 단위로 표시 모드 → 절+작업 수 안내
        clarifyMessage = `**${sectionPath}** 품셈에는 ${childSections.length}개 분류(총 ${workTypes.length}개 작업)가 있습니다.\n분류를 선택해 주세요.`;
    }
} else if (workTypes.length > 0) {
    clarifyMessage = `**${sectionPath}** 품셈은 ${workTypes.length}개 작업으로 분류되어 있습니다.\n어떤 작업의 품셈을 찾으시나요?`;
} else {
    clarifyMessage = `**${sectionPath}** 품셈의 상세 작업이 개별 등록되어 있지 않습니다.\n아래 \"전체 내용 보기\" 버튼으로 해당 절의 품셈 데이터를 확인해 주세요.`;
}
```

**효과**:
- WT ≤ 10 → "6개 작업으로 분류되어 있습니다" (하위 절 언급 없음)
- WT > 10 → "3개 분류(총 15개 작업)가 있습니다. 분류를 선택해 주세요."

---

### 4A-3. _debug 필드 제거 (프로덕션 클린업)

**수정 대상**: 6곳

| #   | 위치       | 내용                                                              |
| --- | ---------- | ----------------------------------------------------------------- |
| 1   | L992       | `ClarifyResult` interface에서 `_debug?` 필드 제거                 |
| 2   | L1213 부근 | `graphClarify` Strategy 4 내 `debugInfo` 수집 코드 전체 제거      |
| 3   | L1367      | `graphClarify` multiple section return에서 `_debug` 제거          |
| 4   | L1407      | `graphClarify` single section + multi WT return에서 `_debug` 제거 |
| 5   | L1455      | `graphClarify` few results return에서 `_debug` 제거               |
| 6   | L2122-2125 | `handleChat` clarify_needed response에서 `_debug` 제거            |

**수정 방법**: 각 위치에서 `_debug` 관련 코드를 삭제. `debugInfo` 변수와 수집 로직도 함께 제거.

---

### 4A 검증 계획

| 테스트         | 쿼리                             | 기대 결과                            |
| -------------- | -------------------------------- | ------------------------------------ |
| 중복 제거 확인 | "강판 전기아크용접 두께 10 인력" | WorkType 1개만 반환 (V형)            |
| 메시지 확인    | "공통장비 품셈" → 공통장비 선택  | "6개 작업으로 분류" (하위 절 미언급) |
| 회귀 테스트    | "강관용접 200mm SCH 40"          | 기존과 동일 결과                     |
| 회귀 테스트    | "콘크리트 타설"                  | 기존과 동일 결과                     |
| _debug 미출력  | 모든 쿼리                        | response에 _debug 필드 없음          |

---

## Phase 4B: DB 데이터 패치

### 전제조건

- Phase 4A 배포 완료 후 실행
- 패치 전 DB 백업 (또는 rollback SQL 준비)

### 4B-1. 13-2-4 섹션: V형/U형 구분 추가

**목적**: 같은 이름으로 저장된 V형/U형 데이터를 구분하여 검색 정확도 확보

**대상**: source_section = '13-2-4'의 WorkType 124건

**chunk→유형 매핑**:
```
V형 chunks: C-0956-B, C-0956-C, C-0956-D, C-0956-E, C-0956-F,
            C-0956-G, C-0956-H, C-0956-I, C-0956-J, C-0956-K, C-0956-L
U형 chunks: C-0956-M, C-0956-N
```

**SQL**:
```sql
-- Rollback 준비: 현재 상태 백업
CREATE TABLE IF NOT EXISTS _backup_graph_entities_13_2_4 AS
SELECT * FROM graph_entities WHERE source_section = '13-2-4';

-- Step 1: V형 엔티티에 "-V형" 접미어 추가
UPDATE graph_entities
SET name = REPLACE(name, '강판 전기아크용접(', '강판 전기아크용접-V형('),
    properties = jsonb_set(
        properties,
        '{welding_type}',
        '"V형"'
    )
WHERE source_section = '13-2-4'
AND (
    properties::text LIKE '%C-0956-B%'
    OR properties::text LIKE '%C-0956-C%'
    OR properties::text LIKE '%C-0956-D%'
    OR properties::text LIKE '%C-0956-E%'
    OR properties::text LIKE '%C-0956-F%'
    OR properties::text LIKE '%C-0956-G%'
    OR properties::text LIKE '%C-0956-H%'
    OR properties::text LIKE '%C-0956-I%'
    OR properties::text LIKE '%C-0956-J%'
    OR properties::text LIKE '%C-0956-K%'
    OR properties::text LIKE '%C-0956-L%'
);

-- Step 2: U형 엔티티에 "-U형" 접미어 추가
UPDATE graph_entities
SET name = REPLACE(name, '강판 전기아크용접(', '강판 전기아크용접-U형('),
    properties = jsonb_set(
        properties,
        '{welding_type}',
        '"U형"'
    )
WHERE source_section = '13-2-4'
AND (
    properties::text LIKE '%C-0956-M%'
    OR properties::text LIKE '%C-0956-N%'
);

-- Step 3: 수정 결과 확인
SELECT name, count(*) FROM graph_entities
WHERE source_section = '13-2-4' AND type = 'WorkType'
GROUP BY name ORDER BY name LIMIT 20;
```

**Rollback SQL** (문제 발생 시):
```sql
-- 원본 복원
DELETE FROM graph_entities WHERE source_section = '13-2-4';
INSERT INTO graph_entities SELECT * FROM _backup_graph_entities_13_2_4;
DROP TABLE _backup_graph_entities_13_2_4;
```

---

### 4B-2. "SCH" → 올바른 규격 표기 변경

**문제**: 강판 전기아크용접의 규격은 "두께(mm)"이지만 "SCH"로 오기

**분석 결과**: SCH 포함 비강관 엔티티 = **42개 섹션, 1,271건**

**접근**: 전체 1,271건 일괄 변경은 위험. **13-2-4 섹션만 우선 패치** (124건)

```sql
-- 13-2-4만: "SCH" → "두께" 변경
UPDATE graph_entities
SET name = REPLACE(name, ', SCH ', ', 두께 '),
    properties = jsonb_set(
        properties,
        '{spec}',
        to_jsonb(REPLACE(properties->>'spec', 'SCH', '두께'))
    )
WHERE source_section = '13-2-4'
AND name LIKE '%, SCH %';

-- 확인
SELECT id, name FROM graph_entities
WHERE source_section = '13-2-4' AND type = 'WorkType'
AND name LIKE '%10%인력%'
ORDER BY id;
```

**예상 결과**:
- 수정 전: `강판 전기아크용접(10, SCH 인력(인))`
- 수정 후: `강판 전기아크용접-V형(10, 두께 인력(인))`

> ⚠️ **나머지 1,147건** (41개 섹션)은 각 섹션별로 "SCH"가 올바른 표기인지 확인 후 패치. Phase 4C에서 일괄 처리.

---

### 4B-3. Chunk Text 최소 보강 (13-2-4)

**문제**: 14개 chunk 중 13개 text 비어있음 → "전체 보기" 기능에서 원문 참조 불가

```sql
-- V형 chunk에 최소 식별 텍스트 추가
UPDATE graph_chunks
SET text = '1. 전기아크용접(V형)(''93년 보완) 테이블 데이터. 두께 3~15mm, 자세: 하향/횡향/입향, 항목: 용접봉사용량(kg), 인력(인), 소요전력(kWh)'
WHERE id IN ('C-0956-B','C-0956-C','C-0956-D','C-0956-E','C-0956-F',
             'C-0956-G','C-0956-H','C-0956-I','C-0956-J','C-0956-K','C-0956-L')
AND (text IS NULL OR length(text) = 0);

-- U형 chunk에 최소 식별 텍스트 추가
UPDATE graph_chunks
SET text = '2. 전기아크용접(U형) 테이블 데이터. 두께 3~15mm, 자세: 하향/횡향/입향/상향, 항목: 용접봉소비량(kg), 인력(인), 소요전력(kWh)'
WHERE id IN ('C-0956-M','C-0956-N')
AND (text IS NULL OR length(text) = 0);

-- 확인
SELECT id, title, length(text) as text_len, left(text, 80) as preview
FROM graph_chunks WHERE id LIKE 'C-0956%' ORDER BY id;
```

---

### 4B 검증 계획

| 테스트    | 쿼리                        | 기대 결과              |
| --------- | --------------------------- | ---------------------- |
| V형 검색  | "강판 전기아크용접 두께 10" | V형 엔티티만 우선 반환 |
| U형 구분  | "강판 전기아크용접 U형"     | U형 엔티티만 반환      |
| 전체 보기 | 강판 전기아크용접 전체 보기 | V형/U형 구분되어 출력  |
| 원본 대조 | V형 두께 10 하향_용접공     | 0.087 (원본 일치)      |
| 회귀      | "강관용접 200mm SCH 40"     | 영향 없음 (다른 섹션)  |

---

## Phase 4C: 추출 파이프라인 개선 (장기)

### 4C-1. step1_table_extractor.py 수정

**대상 파일**: `phase2_extraction/step1_table_extractor.py`

**수정 항목 3가지**:

#### (a) 매트릭스 추출에서 "SCH" 조건부 적용

**현재**: `extract_from_matrix_table()`에서 모든 매트릭스 테이블에 "SCH" 표기
**수정**: 섹션 타이틀에 "강관" 포함 여부로 분기

```python
# extract_from_matrix_table() 내부
def _determine_spec_prefix(section_title: str) -> str:
    """강관이면 SCH, 강판이면 두께, 기타면 규격"""
    if '강관' in section_title:
        return 'SCH'
    elif '강판' in section_title:
        return '두께'
    else:
        return ''  # 기본: 접두어 없음
```

#### (b) 소제목(V형/U형) 반영

**현재**: chunk 내 "1. 전기아크용접(V형)" 같은 소제목이 엔티티명에 미반영
**수정**: chunk의 `text` 또는 `title` 필드에서 소제목 패턴 탐지

```python
import re

def _extract_sub_title(chunk_text: str) -> str | None:
    """chunk 텍스트에서 소제목 추출. 예: '1. 전기아크용접(V형)' → 'V형'"""
    pattern = r'\d+\.\s*\S+\(([^)]+형)\)'
    match = re.search(pattern, chunk_text or '')
    if match:
        return match.group(1)  # "V형", "U형", "L형" 등
    return None
```

#### (c) 테이블 chunk에 text 보존

**현재**: 테이블 구조만 추출하고 text 필드는 비워둠
**수정**: 테이블의 주(注)와 계산예를 text로 저장

---

### 4C-2. 전체 정합성 검증 스크립트

**새 파일**: `phase2_extraction/step6_data_validator.py`

```python
"""Phase 4C: 전체 DB 정합성 검증

검증 항목:
1. normalized_name 중복 → 같은 데이터? 다른 데이터?
2. SCH 포함 엔티티 → 강관인가? 아닌가?
3. text=0 chunk → 보강 대상 목록
4. 소제목 분리 필요 섹션 식별
5. 관계 데이터의 수치 원본 대조 (샘플링)
"""
```

**출력**: `phase2_output/validation_report.json`

---

### 4C-3. 재추출 대상 선별

4B에서 패치한 13-2-4는 수동 수정으로 충분.
나머지 41개 섹션(1,147건)은 step1_table_extractor.py 수정 후 **해당 섹션만 재추출**.

| 재추출 대상 (상위 5)    | 건수 | 비고                              |
| ----------------------- | ---- | --------------------------------- |
| 13-1-1 플랜트 배관 설치 | 97   | SCH 올바름 (강관) → 재추출 불필요 |
| 13-2-6 응력제거         | 89   | SCH 확인 필요                     |
| 13-1-2 관만곡 설치      | 87   | SCH 올바름 (강관) → 재추출 불필요 |
| 8-2-12 크러셔           | 84   | SCH 의미 확인 필요                |
| 9-5-4 수치지도 작성     | 78   | SCH은 무엇? → 확인 필요           |

---

## 전체 실행 타임라인

```
Phase 4A (40분)
│
├─ 4A-1. deduplicateResults() 함수 추가            [10분]
├─ 4A-2. 메시지 문구 수정                           [5분]
├─ 4A-3. _debug 필드 제거                           [10분]
├─ 4A-V. 배포 + 검증                                [15분]
│
Phase 4B (1.5시간)
│
├─ 4B-0. 백업 테이블 생성                            [5분]
├─ 4B-1. V형/U형 구분 SQL 실행                      [15분]
├─ 4B-2. "SCH" → "두께" 변경 (13-2-4만)            [10분]
├─ 4B-3. Chunk Text 보강 (13-2-4만)                 [10분]
├─ 4B-V. 검증 쿼리 + 챗봇 테스트                     [30분]
│
Phase 4C (별도 세션)
│
├─ 4C-1. step1_table_extractor.py 수정              [2시간]
├─ 4C-2. step6_data_validator.py 작성               [1시간]
├─ 4C-3. 대상 섹션 재추출 + 검증                      [1시간+]
```

---

## 리스크 및 대응

| 리스크                                    | 확률 | 대응                                                                                                                                 |
| ----------------------------------------- | ---- | ------------------------------------------------------------------------------------------------------------------------------------ |
| **4A: dedup이 정당한 동명 엔티티도 제거** | 낮음 | normalized_name 기준이므로 "완전 동일명"만 해당. 다른 source_section이면 서로 다른 검색 맥락에서 나오므로 동시에 나올 확률 극히 낮음 |
| **4B: SQL 패치 오적용**                   | 중간 | 백업 테이블 생성 → 문제 시 즉시 rollback                                                                                             |
| **4B: 기존 검색에 영향**                  | 중간 | 엔티티명 변경(V형/U형 추가)으로 기존 ILIKE 패턴 깨질 수 있음 → "강판 전기아크용접" 부분은 유지되므로 큰 영향 없음                    |
| **4C: 재추출 시 기존 관계 깨짐**          | 높음 | 해당 섹션의 entity+relationship을 먼저 삭제 후 재생성 → 트랜잭션 처리 필수                                                           |

---

## 성공 기준

| 기준                                                 | Phase | 측정 방법                  |
| ---------------------------------------------------- | ----- | -------------------------- |
| "강판 전기아크용접 두께 10 인력" → 하향_용접공 0.087 | 4A+4B | 챗봇 테스트                |
| U형 데이터가 V형과 혼합되지 않음                     | 4B    | 챗봇 테스트                |
| "SCH" 미표시 (강판 섹션)                             | 4B    | 챗봇 + DB 쿼리             |
| 메시지에 "하위 절" 불필요 언급 없음                  | 4A    | 챗봇 테스트                |
| _debug 필드 미출력                                   | 4A    | 챗봇 응답 확인             |
| 회귀 테스트 3건 Pass                                 | 4A    | 강관용접, 콘크리트, 잡철물 |

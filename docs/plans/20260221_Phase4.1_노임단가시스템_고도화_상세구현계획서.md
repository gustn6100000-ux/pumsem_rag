# Phase 4.1: 2026년 건설 노임단가 시스템 적용 및 고도화 상세 구현 계획서

**작성일**: 2026-02-21
**목적**: LLM 연산 환각(Math Hallucination) 방지를 위한 백엔드 사전 연산 체계 구축 + System Prompt 강화 + 프론트엔드 Quick Action UI

---

## 1. 현재 상태 진단

### 1-1. 현재 노임단가 파이프라인 흐름

```
[cost_calculate intent]
  → handleChat (index.ts:851-866)
    → last_entity_id로 answerPipeline 재귀 호출
      → expandGraph → REQUIRES_LABOR 관계 수집
      → fetchLaborCosts(jobNames) → labor_costs 테이블 조회
      → context에 "## [2026년 노임단가]" 단가표만 주입
        | 직종 | 노임단가(원/일) |
      → generateAnswer(LLM) → LLM이 수량×단가 곱셈을 직접 수행
```

### 1-2. 핵심 문제점

| 문제 | 위치 | 증상 |
|------|------|------|
| **LLM 곱셈 환각** | `llm.ts:82-91` | `0.05인 × 215,907 = 10,795` 인데 LLM이 `14,393`으로 출력 |
| **수량-단가 매칭 부재** | `index.ts:358-371` | 단가표만 별도 주입, REQUIRES_LABOR의 quantity와 연결 안 됨 |
| **per_unit 미반영** | `index.ts:358-371` | `per_unit`(개소당/m당) 정보가 노무비 context에 미포함 |
| **프롬프트 테이블 포맷 불안정** | `llm.ts:88` | 6열 테이블인데 LLM이 열을 자의적으로 변경/분해 |

---

## 2. 구현 목표

1. **백엔드 사전 연산**: `answerPipeline`에서 `(수량 × 단가 = 금액)`을 JS로 직접 계산하여 **완성된 테이블**을 LLM context에 주입
2. **System Prompt 강화**: LLM이 사전 연산 테이블을 **그대로 복사**하도록 강제
3. **프론트엔드 Quick Action**: `[💵 노무비 계산]` 칩 버튼 추가 (Phase 4.2 이후 — 본 계획서는 백엔드 우선)

---

## 3. 작업 순서 및 상세 구현

### Step 1. 백엔드 사전 연산 로직 (`index.ts`)

#### Step 1-1. REQUIRES_LABOR 관계에서 수량-직종 매핑 구조 추출

**대상**: `index.ts:356-373` (answerPipeline의 `[4-1]` 블록)

**현재 코드**:
```typescript
// index.ts:358-371
const laborNames = relationsAll.flat()
    .filter(r => r.relation === "REQUIRES_LABOR")
    .map(r => r.related_name)
    .filter(Boolean);
if (laborNames.length > 0) {
    const laborCosts = await fetchLaborCosts(laborNames);
    if (laborCosts.length > 0) {
        context += "\n\n## [2026년 노임단가]\n";
        context += "| 직종 | 노임단가(원/일) |\n|---|---:|\n";
        laborCosts.forEach(lc => {
            context += `| ${lc.job_name} | ${lc.cost_2026.toLocaleString()} |\n`;
        });
    }
}
```

**변경안**:
```typescript
// index.ts:356-400 (교체)
if (effectiveIntent === "cost_calculate" || effectiveIntent === "report_request") {
    // [4-1a] REQUIRES_LABOR 관계에서 직종별 투입수량 추출
    const laborRelations = relationsAll.flat()
        .filter(r => r.relation === "REQUIRES_LABOR");

    const laborNames = laborRelations
        .map(r => r.related_name)
        .filter(Boolean);

    if (laborNames.length > 0) {
        const laborCosts = await fetchLaborCosts(laborNames);

        if (laborCosts.length > 0) {
            // [4-1b] 직종명 → 단가 매핑 (LIKE 매칭 결과를 정규화)
            const costMap = new Map<string, number>();
            laborCosts.forEach(lc => costMap.set(lc.job_name, lc.cost_2026));

            // [4-1c] 사용자 지정 수량 (시공 수량: 50m, 10개소 등)
            const userQty = opts?.answerOptions?.quantity
                || opts?.analysis?.quantity
                || 1;

            // [4-1d] 사전 연산 테이블 생성
            context += "\n\n## [2026년 노무비 산출표]\n";
            context += `> 시공수량: ${userQty}${userQty === 1 ? " (1개소당 기준)" : ""}\n\n`;
            context += "| 직종명 | 투입수량(인) | 2026 노임단가(원) | 금액(원) | 비고 |\n";
            context += "| --- | ---: | ---: | ---: | --- |\n";

            let totalCost = 0;

            laborRelations.forEach(rel => {
                const props = (rel.properties || {}) as any;
                const rawName = rel.related_name || "";
                // related_name이 "spec_직종명" 형태일 수 있으므로 정제
                const jobName = rawName.includes('_')
                    ? rawName.split('_').slice(1).join('_')
                    : rawName;

                const qty = parseFloat(props.quantity) || 0;
                const perUnit = props.per_unit || "";
                const sourceSpec = props.source_spec || props.work_type_name || "";

                // labor_costs 테이블과 fuzzy 매칭 (공백 제거 비교)
                const matchedCost = findBestCostMatch(jobName, costMap);
                const unitCost = matchedCost?.cost ?? 0;

                // 핵심 연산: 투입수량 × 시공수량 × 노임단가
                const totalQty = qty * userQty;
                const amount = Math.round(totalQty * unitCost);
                totalCost += amount;

                const remark = [
                    perUnit ? `${perUnit}` : "",
                    sourceSpec ? `규격:${sourceSpec}` : "",
                ].filter(Boolean).join(", ");

                context += `| ${jobName} | ${totalQty} | ${unitCost.toLocaleString()} | ${amount.toLocaleString()} | ${remark} |\n`;
            });

            context += `| **합계** | | | **${totalCost.toLocaleString()}** | |\n`;

            // [4-1e] 단가 참조표도 별도 첨부 (LLM이 출처 확인용)
            context += "\n### [참고: 2026년 노임단가 원본]\n";
            context += "| 직종 | 노임단가(원/일) |\n|---|---:|\n";
            laborCosts.forEach(lc => {
                context += `| ${lc.job_name} | ${lc.cost_2026.toLocaleString()} |\n`;
            });
        }
    }
}
```

#### Step 1-2. `findBestCostMatch` 헬퍼 함수 추가

**위치**: `index.ts` 상단 (renderMatrixTable 근처)

**이유**: `fetchLaborCosts`는 LIKE 매칭으로 `labor_costs.job_name`을 조회하므로, REQUIRES_LABOR의 `related_name`(예: "용접공")과 labor_costs의 `job_name`(예: "플랜트용접공") 간 정확한 1:1 매칭이 필요.

```typescript
/**
 * REQUIRES_LABOR.related_name과 labor_costs.job_name 간 최선 매칭
 * Why: related_name="용접공" vs job_name="플랜트용접공" 등 부분 포함 관계 처리
 */
function findBestCostMatch(
    jobName: string,
    costMap: Map<string, number>
): { name: string; cost: number } | null {
    // 1) 정확 일치
    if (costMap.has(jobName)) {
        return { name: jobName, cost: costMap.get(jobName)! };
    }
    // 2) 공백 제거 정확 일치
    const normalized = jobName.replace(/\s+/g, '');
    for (const [key, cost] of costMap) {
        if (key.replace(/\s+/g, '') === normalized) {
            return { name: key, cost };
        }
    }
    // 3) 부분 문자열 포함 (shorter ⊂ longer)
    for (const [key, cost] of costMap) {
        const keyNorm = key.replace(/\s+/g, '');
        if (keyNorm.includes(normalized) || normalized.includes(keyNorm)) {
            return { name: key, cost };
        }
    }
    // 4) 매칭 실패 → null (LLM에 "단가 미확인"으로 표시)
    return null;
}
```

**파급효과 분석**:
- `renderMatrixTable()`은 변경 없음 — 일반 검색(search intent)에서 사용되며 cost_calculate 전용 로직과 독립
- `buildContext()`도 변경 없음 — 기존 품셈 테이블 렌더링은 그대로 유지
- `fetchLaborCosts()`도 변경 없음 — 반환값을 활용하는 방식만 변경

---

### Step 2. System Prompt 강화 (`llm.ts`)

#### Step 2-1. cost_calculate 프롬프트 전면 교체

**대상**: `llm.ts:82-91`

**현재 코드**:
```typescript
if (options?.intent === "cost_calculate") {
    systemContent += `\n\n[특별 지침: 노무비 산출]
사용자가 노무비 / 인건비 계산을 요청했습니다.
1. 품셈 인력 데이터(직종, 수량, 단위)를 기반으로 노무비를 산출하세요.
2. 수량이 ${options.quantity || '미지정'}...
3. 노무비 산출 형식(반드시 이 테이블 형태로):
   | 직종 | 투입인원(인/개소) | 수량 | 총 투입(M/D) | 노임단가(원/일) | 소계(원) |
4. 컨텍스트에 [2026년 노임단가] 섹선이 있으면 해당 단가를 사용하세요.
5. 합계 행을 추가하고, 총 노무비를 굵은 글씨로 표기하세요.
6. 수량이 미지정이면 "1개소당" 기준으로 산출하세요.`;
}
```

**변경안**:
```typescript
if (options?.intent === "cost_calculate") {
    systemContent += `\n\n[특별 지침: 노무비 산출 — 사전연산 테이블 활용]

컨텍스트에 "[2026년 노무비 산출표]"가 포함되어 있습니다.
이 테이블은 시스템이 정확하게 사전 계산한 결과입니다.

**절대 규칙**:
1. 산출표의 숫자(투입수량, 노임단가, 금액, 합계)를 **절대 수정하지 마세요**.
   직접 곱셈/나눗셈을 시도하지 마세요. 사전연산 결과를 그대로 사용합니다.
2. 출력 테이블 포맷 (5열 고정, 변경 금지):

   | 직종명 | 투입수량(인) | 2026 노임단가(원) | 금액(원) | 비고(할증 등) |
   | --- | ---: | ---: | ---: | --- |

3. 합계 행은 반드시 마지막에 추가하고 **굵은 글씨**로 표기합니다.
4. 비고란의 per_unit(기준단위: 개소당/m당 등)과 source_spec(규격) 정보를 그대로 출력합니다.
5. 테이블 상단에 표번호, 출처, 시공수량을 명시합니다:
   예) 📋 **[표 13-2-3] 강관용접(200, SCH 40) — 노무비 산출** (시공수량: 50개소)
6. "[참고: 2026년 노임단가 원본]" 테이블은 출력하지 않아도 됩니다 (내부 참조용).
7. 수량이 ${options.quantity || '미지정(1개소당 기준)'}으로 적용되었습니다.`;
}
```

**핵심 변경 사유**:
- 기존: LLM에게 곱셈을 시키고 포맷도 맡김 → 연산 오류 + 포맷 변형
- 변경: 사전연산 완료 테이블을 "복사"하라고 지시 → 연산 오류 원천 차단

#### Step 2-2. report_request 프롬프트도 동일 패턴 적용

**대상**: `llm.ts:94-101`

**변경안**:
```typescript
if (options?.intent === "report_request") {
    systemContent += `\n\n[특별 지침: 산출서 형태 출력]
사용자가 산출서/내역서를 요청했습니다.
1. 컨텍스트의 "[2026년 노무비 산출표]"를 산출서 본문에 **그대로** 포함하세요.
2. 산출표의 숫자를 직접 재계산하지 마세요.
3. 산출서 구조:
   - 상단: 품셈 출처(표번호, 절), 규격, 시공수량
   - 본문: 품셈 인력 투입 테이블 + 노무비 산출 테이블
   - 하단: 합계 금액 강조 표시
4. 수량이 ${options.quantity || '미지정'}으로 적용되었습니다.
5. 표번호, 출처 정보를 상단에 명시하세요.`;
}
```

---

### Step 3. 단가 매칭 실패 안전장치

#### Step 3-1. 매칭 실패 시 context 경고 삽입

**위치**: Step 1-1의 `laborRelations.forEach` 내부

단가 매칭(`findBestCostMatch`)이 실패한 직종은 산출표에 "단가 미확인"으로 표기하되, LLM이 임의 단가를 생성하지 않도록 경고 문구를 추가합니다.

```typescript
// findBestCostMatch 결과가 null인 경우
if (!matchedCost) {
    context += `| ${jobName} | ${totalQty} | ⚠️ 단가 미확인 | - | 노임단가 DB 미등록 |\n`;
    // 합계에 포함하지 않음
} else {
    const amount = Math.round(totalQty * unitCost);
    totalCost += amount;
    context += `| ${jobName} | ${totalQty} | ${unitCost.toLocaleString()} | ${amount.toLocaleString()} | ${remark} |\n`;
}
```

#### Step 3-2. System Prompt에 미확인 직종 처리 규칙 추가

```typescript
// Step 2-1 프롬프트 하단에 추가
`8. "⚠️ 단가 미확인" 항목이 있으면:
   - 해당 직종의 금액을 임의로 추정하지 마세요.
   - "※ [직종명]의 2026년 노임단가가 DB에 등록되지 않아 해당 항목은 산출에서 제외되었습니다." 를 주석으로 표기하세요.`
```

---

### Step 4. 프론트엔드 Quick Action 칩 (Phase 4.2 연계)

> 본 계획서는 백엔드 구현을 우선하며, 프론트엔드는 설계 방향만 기술합니다.

#### Step 4-1. 칩 표시 조건

품셈 답변(answer) 응답에 REQUIRES_LABOR 관계가 1개 이상 존재할 때, 응답 JSON에 `quick_actions` 필드를 추가합니다.

**대상**: `index.ts:answerPipeline()` 응답 조립 블록 (라인 396-400)

```typescript
// [6-1] Quick Action 칩 데이터 생성
const hasLabor = relationsAll.flat().some(r => r.relation === "REQUIRES_LABOR");
const quickActions = hasLabor ? [{
    type: "cost_calculate",
    label: "💵 노무비 계산",
    payload: {
        entity_id: targetEntities[0]?.id,
        work_name: targetEntities[0]?.name,
    }
}] : [];
```

#### Step 4-2. ChatResponse 타입 확장

**대상**: `types.ts`

```typescript
export interface QuickAction {
    type: string;           // "cost_calculate"
    label: string;          // "💵 노무비 계산"
    payload: Record<string, unknown>;
}

export interface ChatResponse {
    type: "answer" | "clarify";
    answer: string;
    sources: SourceInfo[];
    search_info: SearchInfo;
    clarification?: ClarificationInfo;
    quick_actions?: QuickAction[];  // ← 신규
}
```

#### Step 4-3. 프론트엔드 칩 클릭 동작 (설계안)

```
사용자가 [💵 노무비 계산] 칩 클릭
  → POST { question: "노무비 계산해줘", entity_id: "W-0788", session_context: {...} }
  → handleChat Route 1 (entity_id 직접) → answerPipeline(cost_calculate)
  → 사전연산 산출표 포함 context → LLM 복사 출력
```

---

## 4. 수정 대상 파일 요약

| 순서 | 파일 | 변경 내용 | 영향 범위 |
|------|------|-----------|-----------|
| Step 1-1 | `edge-function/index.ts` | answerPipeline `[4-1]` 블록 → 사전연산 테이블 생성 | cost_calculate/report_request intent만 영향 |
| Step 1-2 | `edge-function/index.ts` | `findBestCostMatch()` 헬퍼 함수 추가 | 신규 함수, 기존 코드 무영향 |
| Step 2-1 | `edge-function/llm.ts` | cost_calculate 프롬프트 전면 교체 | LLM 출력 포맷만 영향 |
| Step 2-2 | `edge-function/llm.ts` | report_request 프롬프트 동기화 | LLM 출력 포맷만 영향 |
| Step 3 | `edge-function/index.ts` | 단가 미확인 안전장치 | Step 1-1 내부 로직 |
| Step 4 | `edge-function/types.ts` + `index.ts` | QuickAction 타입 + 응답 데이터 추가 | 프론트엔드 연동 준비 |

---

## 5. 파급효과 분석 (Ontological Integrity Check)

### 5-1. 안전 영역 (변경 없음)
- `search.ts`: 검색 파이프라인 — cost_calculate intent와 무관
- `graph.ts`: `expandGraph()`, `fetchLaborCosts()` — 입출력 인터페이스 불변
- `clarify.ts`: 의도 분석 — cost_calculate 판정 로직 불변
- `resolve.ts`: 절 탐색 — 무관
- `context.ts`: `makeAnswerResponse()` — 기존 인터페이스 유지 (quick_actions 필드만 선택적 추가)

### 5-2. 주의 영역
| 항목 | 위험 | 대응 |
|------|------|------|
| `userQty` 타입 | `analysis.quantity`가 string일 수 있음 | `parseFloat()` + fallback 1 적용 |
| `related_name` 형태 | `"200_SCH_40_용접공"` 같은 spec prefix 포함 가능 | `split('_').slice(1).join('_')` 정제 로직 포함 |
| `per_unit` 다중값 | 같은 공종에 "개소당"/"m당" 혼재 가능 | 비고란에 표기하고 산출은 quantity 기준으로 통일 |
| 프론트엔드 미구현 | `quick_actions` 필드 추가 시 기존 프론트 에러 가능 | optional 필드이므로 안전. `?.` 접근 필요 |

### 5-3. Phase 4 리팩토링과의 관계
본 계획서(Phase 4.1)는 Phase 4 리팩토링 계획서의 **Step 2-4 (per_unit 렌더링)**와 독립적으로 작동합니다.
- Phase 4 Step 2-4: `buildContext()`의 **일반 검색(search intent)** 시 per_unit 컬럼 추가
- Phase 4.1: `answerPipeline()`의 **cost_calculate intent** 시 사전연산 산출표 주입

두 작업은 서로 다른 코드 경로이므로 충돌 없이 병행 가능합니다.

---

## 6. 검증 방법

### 6-1. 단위 테스트 시나리오

```
[테스트 1: 기본 노무비 산출]
입력: "강관용접 200mm SCH 40 노무비 계산" (수량 미지정)
기대: 1개소당 기준 산출표, 합계 금액 = Σ(투입수량 × 노임단가)

[테스트 2: 수량 지정 노무비 산출]
입력: "강관용접 200mm SCH 40 50개소 노무비"
기대: 수량 50 적용, 각 직종 투입수량 = 품셈수량 × 50

[테스트 3: 단가 미확인 직종 포함]
입력: labor_costs에 없는 직종이 REQUIRES_LABOR에 존재
기대: "⚠️ 단가 미확인" 표시, 합계에서 제외, 주석 안내

[테스트 4: 숫자 정확성 검증]
입력: 용접공 0.287인 × 1개소 × 262,813원
기대: 금액 = 75,427원 (Math.round(0.287 × 262813))
검증: LLM 출력의 금액이 사전연산 값과 동일한지 확인
```

### 6-2. 회귀 테스트

- [ ] 일반 품셈 검색(search intent) — buildContext 테이블 렌더링 정상
- [ ] 의도 분석(clarify_needed) — 명확화 분기 정상
- [ ] 수량 변경(modify_request) — 재귀 호출 시 사전연산 재실행
- [ ] 산출서 요청(report_request) — 사전연산 테이블 포함 확인
- [ ] entity_id 직접 조회(Route 1) — cost_calculate 아닌 경우 기존 동작 유지

---

## 7. 구현 우선순위

| 우선순위 | 작업 | 예상 난이도 | 비고 |
|----------|------|-------------|------|
| **P0** | Step 1 (사전연산 로직) | 중 | 핵심 기능, LLM 환각 차단 |
| **P0** | Step 2 (프롬프트 강화) | 하 | 문자열 교체 수준 |
| **P1** | Step 3 (안전장치) | 하 | null 체크 + 경고 문구 |
| **P2** | Step 4 (Quick Action) | 중 | 프론트엔드 연동 필요 |

# Phase 4C: 추출 파이프라인 개선 — 상세 구현 계획서

> **일시**: 2026-02-14 00:15 KST  
> **근거**: Phase 4B 실행 결과, 구현계획서(Phase 4) 4C 섹션  
> **목표**: 추출 파이프라인의 구조적 결함을 수정하여, DB 데이터 정합성을 근본적으로 해결한다.

---

## 현황 진단

Phase 4B에서 **13-2-4 섹션(124건)**을 수동 패치했으나, DB 전체에는 아래 구조적 문제가 남아있습니다:

| 문제                                      | 영향 범위          | 심각도 |
| ----------------------------------------- | ------------------ | ------ |
| `source_chunk` 전부 null (4,733 WorkType) | 전체 DB            | 🔴 높음 |
| SCH 오기 (비강관 섹션에 SCH 표기)         | 20개 섹션, 1,147건 | 🟡 중간 |
| chunk 텍스트 없음 (895/2,105 = 42.5%)     | 전체 DB            | 🟡 중간 |
| 소제목(V형/U형 등) 엔티티명 미반영        | 미파악 (스캔 필요) | 🟡 중간 |
| `인 력` vs `인력` 공백 불일치             | ~90그룹, ~180건    | 🟢 낮음 |

---

## Phase 4C 구성

```
Phase 4C (총 예상 4~6시간, 별도 세션 권장)
│
├─ 4C-0. 사전 분석 — DB 전수 스캔              [30분]
├─ 4C-1. step1_table_extractor.py 수정          [2시간]
│   ├─ (a) source_chunk 기록 추가
│   ├─ (b) SCH 조건부 적용
│   ├─ (c) 소제목 반영
│   └─ (d) 테이블 chunk text 보존
├─ 4C-2. step6_data_validator.py 신규 작성      [1시간]
├─ 4C-3. 대상 섹션 재추출                       [1~2시간]
└─ 4C-V. 전체 검증 + 챗봇 회귀 테스트           [1시간]
```

---

## 4C-0. 사전 분석 — DB 전수 스캔

### 목표
패치 대상 섹션을 정확히 선별하고, 재추출 범위를 최소화합니다.

### 실행 내용

#### (1) SCH 포함 섹션 분류

```sql
-- 이미 파악된 20개 섹션 (Phase 4B에서 조회)
SELECT source_section, count(*) as wt_count, min(name) as sample
FROM graph_entities 
WHERE type = 'WorkType' AND name LIKE '%, SCH %'
GROUP BY source_section ORDER BY count(*) DESC;
```

현재 파악된 섹션별 현황:

| 섹션     | 건수 | 섹션명              | SCH 적절성           | 조치               |
| -------- | ---- | ------------------- | -------------------- | ------------------ |
| 13-2-3   | 119  | 강관용접            | ✅ SCH 정상 (강관)    | 재추출 불필요      |
| 13-1-1   | 97   | 플랜트 배관 설치    | ✅ SCH 정상 (배관)    | 재추출 불필요      |
| 13-2-6   | 89   | 응력제거            | ⚠️ 확인 필요 (열처리) | 원본 PDF 대조 필요 |
| 13-1-2   | 87   | 관만곡 설치         | ✅ SCH 정상 (배관)    | 재추출 불필요      |
| 8-2-12   | 84   | 크러셔              | ❌ SCH 오기 (장비)    | 재추출 대상        |
| 9-5-4    | 78   | 수치지도 작성       | ❌ SCH 오기 (측량)    | 재추출 대상        |
| 6-7-3#2  | 64   | 유리섬유복합관 부설 | ⚠️ 확인 필요          | 원본 대조 필요     |
| 9-3-4    | 63   | 구획정리 확정측량   | ❌ SCH 오기 (측량)    | 재추출 대상        |
| 13-2-1   | 54   | 강관절단            | ✅ SCH 정상 (강관)    | 재추출 불필요      |
| 8-1-1#4  | 48   | 냉동기 반입         | ❌ SCH 오기 (장비)    | 재추출 대상        |
| 9-3-1    | 42   | 지형현황            | ❌ SCH 오기 (측량)    | 재추출 대상        |
| 4-1-4#3  | 42   | 배관보온 해체       | ⚠️ 확인 필요 (배관)   | 원본 대조 필요     |
| 4-2-1#4  | 32   | 송풍기 설치         | ❌ SCH 오기 (장비)    | 재추출 대상        |
| 6-3-3#2  | 31   | 도장                | ❌ SCH 오기 (도장)    | 재추출 대상        |
| 4-1-1#5  | 29   | 배관 해체           | ⚠️ 확인 필요 (배관)   | 원본 대조 필요     |
| 6-3-4#2  | 26   | 절단                | ❌ SCH 오기 (절단)    | 재추출 대상        |
| 11-1-2#2 | 22   | 용접식 부설         | ⚠️ 확인 필요 (배관)   | 원본 대조 필요     |
| 9-7-4    | 21   | 경지구획정리        | ❌ SCH 오기 (측량)    | 재추출 대상        |
| 13-2-5   | 21   | 예열                | ⚠️ 확인 필요 (용접)   | 원본 대조 필요     |
| 1-1-4    | 20   | 용접공수 산정방법   | ⚠️ 확인 필요          | 원본 대조 필요     |

> [!IMPORTANT]
> **핵심 판단 기준**: 원본 PDF 표에서 열 헤더가 숫자(20, 40, 80 등)이고 그것이 **배관 스케줄(Schedule)**을 의미하면 SCH 정상. 그렇지 않으면 SCH 대신 다른 의미(두께, 직종, 수량 등)를 써야 합니다.

#### (2) 소제목 분리 필요 섹션 스캔

```sql
-- chunk 텍스트에 "V형", "U형", "L형" 등 형태 소제목이 있지만
-- 엔티티명에 반영되지 않은 섹션
SELECT DISTINCT c.id, c.title, left(c.text, 100) as preview
FROM graph_chunks c
WHERE c.text ~ '\d+\.\s*\S+\([^)]+형\)'  -- "1. 전기아크용접(V형)" 패턴
ORDER BY c.id
LIMIT 20;
```

#### (3) 공백 중복 전수 조사

```sql
-- "인 력" vs "인력" 같은 공백 차이 중복 그룹 전체
SELECT 
  REPLACE(name, ' ', '') as normalized,
  array_agg(DISTINCT name) as variants,
  count(*) as cnt
FROM graph_entities WHERE type = 'WorkType'
GROUP BY REPLACE(name, ' ', '')
HAVING count(DISTINCT name) > 1
ORDER BY count(*) DESC
LIMIT 20;
```

---

## 4C-1. `step1_table_extractor.py` 수정

> **파일**: `phase2_extraction/step1_table_extractor.py` (1,061줄, 21개 함수)

### (a) `source_chunk` 기록 추가

**문제**: 현재 모든 WorkType 엔티티의 `properties.source_chunk`가 null (4,733건 전부)

**수정 대상**: `extract_from_a_table()`, `_extract_d1_metarow()`, `_extract_d2_compound()`, `extract_from_b_table()` — 엔티티 생성하는 모든 함수

**수정 방법**:

```python
# 현재 (extract_from_a_table 내부, ~L620)
entity = Entity(
    type=EntityType.WORK_TYPE,
    name=wt_name,
    section_id=section_id,
    properties={"spec": spec_val, "unit": unit_val}
)

# 수정
entity = Entity(
    type=EntityType.WORK_TYPE,
    name=wt_name,
    section_id=section_id,
    properties={
        "spec": spec_val, 
        "unit": unit_val,
        "source_chunk": chunk_id  # ← 추가
    }
)
```

**영향 범위**: 4개 함수의 모든 Entity 생성 위치

**파급 효과(A3)**: DB에 새 속성 추가. 기존 데이터와의 호환성 문제 없음 (optional 속성). Edge Function에서 `source_chunk`를 참조하는 코드는 없으므로 무관.

---

### (b) SCH 조건부 적용

**문제**: `extract_from_matrix_table()` → `_extract_d1_metarow()`, `_extract_d2_compound()`에서 모든 매트릭스 테이블의 열 헤더를 "SCH"로 표기

**수정 대상**: `extract_from_matrix_table()` (L230)

**수정 코드**:

```python
def _determine_spec_prefix(section_title: str) -> str:
    """강관이면 SCH, 강판이면 두께, 기타면 빈 문자열.
    
    Why: 매트릭스 테이블의 열 헤더가 숫자일 때, 그 숫자의 의미가
    섹션마다 다름. 강관 섹션에서는 Schedule(SCH)이 맞지만,
    강판이나 기타 섹션에서는 두께, 구경, 또는 다른 의미.
    """
    title_lower = section_title.lower()
    if any(k in title_lower for k in ['강관', '배관', '관만곡', '절단']):
        return 'SCH'
    elif any(k in title_lower for k in ['강판']):
        return '두께'
    else:
        return ''  # 기본: 접두어 없이 숫자만 사용
```

**적용 위치**: `_extract_d1_metarow()` L330 부근, `_extract_d2_compound()` L430 부근의 이름 생성 로직

```python
# 현재 (D1 패턴)
wt_name = f"{section_title}({diameter}, SCH {sch_val})"

# 수정
spec_prefix = _determine_spec_prefix(section_title)
if spec_prefix:
    wt_name = f"{section_title}({diameter}, {spec_prefix} {sch_val})"
else:
    wt_name = f"{section_title}({diameter}, {sch_val})"
```

**파급 효과(A3)**: 
- 재추출 시 엔티티 이름이 변경됨 → 기존 관계(graph_relationships)의 `source_id`/`target_id`가 깨짐
- **반드시 해당 섹션의 entity + relationship을 삭제 후 재생성** 필요

---

### (c) 소제목(V형/U형 등) 반영

**문제**: chunk 텍스트에 "1. 전기아크용접(V형)" 소제목이 있지만 엔티티명에 미반영

**수정 대상**: `extract_from_chunk()` (L867) — 각 chunk 처리 진입점

**수정 코드**:

```python
import re

def _extract_sub_title(chunk_text: str) -> str | None:
    """chunk 텍스트에서 소제목 추출.
    
    예: '1. 전기아크용접(V형)' → 'V형'
        '2. 전기아크용접(U형)' → 'U형'
    
    Why: 하나의 섹션 안에 여러 테이블(V형, U형 등)이 있을 때,
    각 테이블의 데이터를 구분하기 위한 접미어 추출.
    """
    pattern = r'\d+\.\s*\S+\(([^)]+형)\)'
    match = re.search(pattern, chunk_text or '')
    if match:
        return match.group(1)
    return None

# extract_from_chunk() 내부에서 사용
def extract_from_chunk(chunk: dict):
    chunk_text = chunk.get("text", "")
    sub_title = _extract_sub_title(chunk_text)
    
    # ... 기존 테이블 추출 로직 ...
    
    # 엔티티 이름에 소제목 접미어 추가
    if sub_title:
        for entity in entities:
            if entity.type == EntityType.WORK_TYPE:
                # "강판 전기아크용접(10, 두께 인력(인))"
                # → "강판 전기아크용접-V형(10, 두께 인력(인))"
                entity.name = entity.name.replace(
                    f"{section_title}(",
                    f"{section_title}-{sub_title}(",
                    1  # 첫 번째만
                )
```

**파급 효과(A3)**: 엔티티 이름 변경으로 기존 관계 깨짐 → 섹션 단위 삭제 후 재생성 필요

---

### (d) 테이블 chunk에 text 보존

**문제**: 895/2,105 chunk(42.5%)의 텍스트가 비어있음

**수정 대상**: chunk 생성 로직 (step1 이전 단계, `step0_prepare_chunks.py` 또는 유사 함수)

**수정 코드**:

```python
def _generate_table_summary(table: dict, section_title: str) -> str:
    """테이블 구조로부터 요약 텍스트 생성.
    
    Why: 텍스트가 없으면 벡터 검색에서 해당 chunk가 발견되지 않고,
    "전체 보기" 기능에서 원문 참조가 불가능.
    """
    headers = table.get("headers", [])
    row_count = len(table.get("rows", []))
    header_str = ", ".join(h for h in headers[:5] if h)
    
    return f"{section_title} / 테이블 데이터. 열: {header_str}. {row_count}행."
```

> [!WARNING]
> 이 수정은 chunk 생성 단계에 있으므로, `step1_table_extractor.py`가 아닌 **상위 단계** 스크립트 수정이 필요할 수 있습니다. 정확한 위치는 실행 시 확인.

---

## 4C-2. `step6_data_validator.py` 신규 작성

> **새 파일**: `phase2_extraction/step6_data_validator.py`

### 검증 항목 5가지

| #   | 검증                                 | 출력                                    | 판정 기준    |
| --- | ------------------------------------ | --------------------------------------- | ------------ |
| 1   | `source_chunk` 채워져 있는지         | 미기록 엔티티 목록                      | 0건이면 Pass |
| 2   | SCH 포함 엔티티 → 강관/배관 섹션인지 | 비강관 SCH 목록                         | 0건이면 Pass |
| 3   | chunk `text` 비어있는지              | 빈 chunk 목록                           | 0건이면 Pass |
| 4   | 공백 기반 이름 중복                  | 중복 그룹 목록                          | 0건이면 Pass |
| 5   | 소제목 미반영 섹션                   | 소제목 패턴 있지만 엔티티명에 없는 목록 | 0건이면 Pass |

### 출력 형식

```json
{
  "run_at": "2026-02-14T...",
  "summary": {
    "total_entities": 4733,
    "total_chunks": 2105,
    "issues_found": 42
  },
  "checks": [
    {
      "check_id": "source_chunk_null",
      "status": "FAIL",
      "count": 4733,
      "sample": [...]
    },
    ...
  ]
}
```

### 실행 방법

```bash
cd phase2_extraction
python step6_data_validator.py --output ../phase2_output/validation_report.json
```

---

## 4C-3. 대상 섹션 재추출

### 전략: 섹션 단위 삭제 → 재추출 → 재삽입

```python
def reextract_section(section_id: str):
    """특정 섹션의 엔티티/관계를 삭제하고 재추출.
    
    Why: 엔티티 이름이 변경되면 기존 관계의 source_id/target_id가
    ID 불일치로 깨짐. 트랜잭션 내에서 삭제→재생성이 안전.
    """
    # Step 1: 해당 섹션의 기존 관계 삭제
    DELETE FROM graph_relationships 
    WHERE source_id IN (SELECT id FROM graph_entities WHERE source_section = :section_id);
    
    # Step 2: 해당 섹션의 기존 엔티티 삭제
    DELETE FROM graph_entities WHERE source_section = :section_id;
    
    # Step 3: 수정된 파이프라인으로 재추출
    chunks = load_chunks_for_section(section_id)
    for chunk in chunks:
        entities, relations = extract_from_chunk(chunk)
        insert_entities(entities)
        insert_relations(relations)
```

### 재추출 대상 섹션 (우선순위)

| 우선순위 | 섹션              | 건수 | 이유                 |
| -------- | ----------------- | ---- | -------------------- |
| 🔴 P1     | 8-2-12 크러셔     | 84   | SCH 완전 오기 (장비) |
| 🔴 P1     | 9-5-4 수치지도    | 78   | SCH 완전 오기 (측량) |
| 🔴 P1     | 9-3-4 구획정리    | 63   | SCH 완전 오기 (측량) |
| 🟡 P2     | 8-1-1#4 냉동기    | 48   | SCH 오기 (장비)      |
| 🟡 P2     | 9-3-1 지형현황    | 42   | SCH 오기 (측량)      |
| 🟡 P2     | 4-2-1#4 송풍기    | 32   | SCH 오기 (장비)      |
| 🟡 P2     | 6-3-3#2 도장      | 31   | SCH 오기 (도장)      |
| 🟡 P2     | 6-3-4#2 절단      | 26   | SCH 오기 (절단)      |
| 🟡 P2     | 9-7-4 경지구획    | 21   | SCH 오기 (측량)      |
| ⚪ P3     | 13-2-6 응력제거   | 89   | SCH 적절성 확인 필요 |
| ⚪ P3     | 6-7-3#2 유리섬유  | 64   | SCH 적절성 확인 필요 |
| ⚪ P3     | 4-1-4#3 배관보온  | 42   | SCH 적절성 확인 필요 |
| ⚪ P3     | 4-1-1#5 배관해체  | 29   | SCH 적절성 확인 필요 |
| ⚪ P3     | 11-1-2#2 용접부설 | 22   | SCH 적절성 확인 필요 |
| ⚪ P3     | 13-2-5 예열       | 21   | SCH 적절성 확인 필요 |
| ⚪ P3     | 1-1-4 용접공수    | 20   | SCH 적절성 확인 필요 |
| ✅ 제외   | 13-2-3 강관용접   | 119  | SCH 정상 (강관)      |
| ✅ 제외   | 13-1-1 배관설치   | 97   | SCH 정상 (배관)      |
| ✅ 제외   | 13-1-2 관만곡     | 87   | SCH 정상 (배관)      |
| ✅ 제외   | 13-2-1 강관절단   | 54   | SCH 정상 (강관)      |

> [!NOTE]
> P3 그룹(확인 필요)은 **원본 PDF 대조** 후 재추출 여부를 결정합니다.  
> 이 작업은 사용자의 도메인 지식이 필요하므로, 실행 시 사용자에게 확인 요청합니다.

---

## 4C-V. 검증 계획

| 테스트            | 쿼리/방법                            | 기대 결과              |
| ----------------- | ------------------------------------ | ---------------------- |
| source_chunk 기록 | `step6_data_validator.py` 실행       | source_chunk_null = 0  |
| SCH 정확성        | 비강관 섹션에서 SCH 포함 엔티티 검색 | 0건                    |
| 소제목 반영       | "강판 전기아크용접 V형" 검색         | V형 엔티티만 반환      |
| chunk 텍스트      | 빈 텍스트 chunk 검색                 | 대폭 감소 (목표: <10%) |
| 회귀 테스트       | "강관용접 200mm SCH 40"              | 기존과 동일 (SCH 유지) |
| 회귀 테스트       | "콘크리트 타설"                      | 영향 없음              |
| 회귀 테스트       | "강판 전기아크용접 두께 10 인력"     | Phase 4B 결과 유지     |

---

## 리스크 및 대응

| 리스크                                   | 확률 | 대응                                                                     |
| ---------------------------------------- | ---- | ------------------------------------------------------------------------ |
| **재추출 시 기존 관계 깨짐**             | 높음 | 섹션 단위 DELETE → INSERT 트랜잭션. 백업 테이블 유지                     |
| **소제목 패턴이 예상과 다른 섹션**       | 중간 | `_extract_sub_title` 정규식을 보수적으로 설정. 미매칭 시 접미어 생략     |
| **SCH 적절성 오판**                      | 중간 | P3 그룹은 사용자 확인 후 처리. 자동 판단 않음                            |
| **파이프라인 수정 → 다른 섹션에 부작용** | 중간 | 수정 함수에 `section_title` 파라미터 기반 분기 사용. 기존 로직 유지 원칙 |
| **임베딩 불일치**                        | 높음 | 이름 변경된 엔티티의 `embedding` 컬럼 재생성 필요 → 별도 스텝 추가 검토  |

---

## 성공 기준

| 기준                                     | 측정 방법   |
| ---------------------------------------- | ----------- |
| `source_chunk` 기록률 100% (재추출 섹션) | DB 쿼리     |
| 비강관 섹션 SCH 표기 0건 (P1+P2 대상)    | DB 쿼리     |
| chunk 텍스트 커버리지 ≥ 90%              | DB 쿼리     |
| 소제목 반영된 엔티티명                   | 챗봇 테스트 |
| 회귀 테스트 3건 Pass                     | 챗봇 테스트 |

---

## 실행 전 사용자 확인 필요 사항

> [!CAUTION]
> 아래 항목은 **도메인 전문 지식** 또는 **정책 결정**이 필요하므로 실행 전 확인이 반드시 필요합니다.

1. **P3 그룹 6개 섹션의 SCH 적절성**: 원본 PDF에서 해당 표의 열 헤더가 무엇을 의미하는지 확인 필요
2. **임베딩 재생성 범위**: 이름 변경된 엔티티만? 전체 재생성?
3. **재추출 우선순위**: P1 전부 먼저? 아니면 특정 섹션만?
4. **Phase 4C 실행 시점**: 별도 세션으로? 현 세션 연장으로?

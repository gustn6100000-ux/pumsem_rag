# [표 13-2-3] 강관용접 데이터 효율성 개선 계획서

> **작성일**: 2026-02-14  
> **대상**: 13-2-3 강관용접('18년 보완) — 전기아크용접 + TIG용접  
> **관련 파일**: `context.ts`, `clarify.ts`, `index.ts`, `graph.ts`

---

## 1. 문제 정의

### 1.1 현상 (스크린샷 기반)

"TIG용접 품셈" 검색 시:
- TIG용접 **규격별 인력 데이터가 출력되지 않음**
- 대신 같은 섹션의 전기아크용접 데이터가 규격별로 **개별 분리된 소형 테이블**로 표시됨
- 원본은 **구경(mm) × SCH No. 매트릭스 1개 테이블**인데, 현재는 규격 하나당 테이블 1개 생성

### 1.2 근본 원인 분석

| 문제                        | 원인                                                   | 영향 범위                                  |
| --------------------------- | ------------------------------------------------------ | ------------------------------------------ |
| **A. TIG용접 데이터 누락**  | WorkType 1개(W-0631)만 존재, REQUIRES_LABOR 관계 0건   | TIG용접 전체                               |
| **B. 출력 비효율**          | buildContext가 WorkType별 개별 테이블 생성             | 13-2-3 포함 WT 20개+ 섹션 전체 (15개 섹션) |
| **C. 매트릭스 구조 미지원** | 원본의 구경×SCH 2차원 매트릭스를 1차원 리스트로만 출력 | 품셈 전체                                  |

### 1.3 데이터 현황 (DB 분석 결과)

#### 전기아크용접 (정상 추출, 출력만 비효율)

```
13-2-3 WorkType 분포:
├── 강관용접(규격)  : 119개  ← 전기아크용접 (구경×SCH 조합)
├── TIG용접        :   1개  ← REQUIRES_LABOR 없음 ❌
├── 전기아크용접    :   1개  ← 상위 카테고리
└── 강관용접       :   1개  ← 섹션 엔티티
```

**전기아크용접 구경×SCH 매트릭스:**

| 구경(mm) | 보유 SCH 수 | SCH 목록                               |
| -------- | ----------- | -------------------------------------- |
| 15~40    | 3           | 40, 80, 160                            |
| 50~90    | 4           | 20, 40, 80, 160                        |
| 100~150  | 5           | 20, 40, 80, 120, 160                   |
| 200~600  | 9           | 20, 30, 40, 60, 80, 100, 120, 140, 160 |

→ 총 119개 WorkType × 평균 2.1개 Labor = **254개 REQUIRES_LABOR 관계**  
→ 현재: **119개 개별 테이블** 생성 (심각한 비효율)

#### TIG용접 (데이터 추출 누락)

| 항목              | 상태                                 |
| ----------------- | ------------------------------------ |
| WorkType `W-0631` | 존재 ✅                               |
| REQUIRES_LABOR    | **0건** ❌                            |
| unit_costs 원문   | TIG 전체 SCH 20~80 테이블 **존재** ✅ |
| 원본 구경 범위    | 15~600mm × SCH 20, 30, 40, 60, 80    |

**unit_costs 원문 데이터 형태 (이미 저장됨):**
```
| 구경(㎜) | SCH20 플랜트용접공 | SCH20 특별인부 | SCH40 플랜트용접공 | SCH40 특별인부 | ...
| 15      | -                | -             | 0.065            | 0.038            | ...
| 20      | -                | -             | 0.067            | 0.039            | ...
```

---

## 2. 영향 범위

동일한 "규격별 개별 테이블 비효율" 문제를 가진 섹션 (WT 20개 이상):

| 섹션         | 이름              |   WT 수 | 비고             |
| ------------ | ----------------- | ------: | ---------------- |
| 13-1-5       | Flange 취부       |     180 | 최다             |
| 9-5-4        | 수치지도 작성     |     148 |                  |
| 13-1-1       | 플랜트 배관 설치  |     125 |                  |
| 13-2-4       | 강판 전기아크용접 |     124 | 유사 구조        |
| **13-2-3**   | **강관용접**      | **122** | **본 계획 대상** |
| 13-2-6       | 응력제거          |     100 |                  |
| 8-2-12       | 크러셔            |      91 |                  |
| 13-1-2       | 관만곡 설치       |      90 |                  |
| ... (7개 더) | ...               |   24~88 |                  |

→ **15개 섹션, 총 1,500개+ WorkType**이 동일 문제 보유

---

## 3. 해결 방안

### Phase 1: TIG용접 데이터 보강 (데이터 계층)

> **목표**: TIG용접(W-0631)에 규격별 REQUIRES_LABOR 관계 추가  
> **난이도**: 중  
> **예상 작업**: 2~3시간

#### 3.1 접근 방식

unit_costs에 이미 TIG 전체 SCH별 품셈표가 존재하므로, 두 가지 선택지:

| 방식                         | 설명                                                                | 장점                      | 단점                   |
| ---------------------------- | ------------------------------------------------------------------- | ------------------------- | ---------------------- |
| **A. WorkType 세분화**       | 전기아크용접처럼 `TIG용접(200, SCH 40)` 식으로 100개+ WorkType 생성 | 기존 로직 호환            | 같은 비효율 반복       |
| **B. 매트릭스 속성 저장**    | W-0631에 properties에 전체 매트릭스 JSON 저장                       | 1개 WT로 전체 표현        | buildContext 수정 필요 |
| **C. ★ 원문 청크 직접 활용** | unit_costs의 TIG 원문 테이블을 LLM 컨텍스트에 직접 전달             | 수정 최소, 원본 형태 유지 | 그래프 탐색 우회       |

**권장: C → 즉시 적용, B → 중기 개선**

#### 3.2 Phase 1 구현 상세 (방식 C)

##### [MODIFY] `graph.ts` — expandGraph 함수

TIG용접처럼 REQUIRES_LABOR 관계가 없는 WorkType 감지 시, unit_costs에서 해당 섹션 원문을 직접 첨부:

```typescript
// expandGraph에서 labor 관계가 0건인 엔티티 감지
if (laborRelations.length === 0 && entity.type === 'WorkType') {
    // unit_costs에서 해당 섹션 원문 조회
    const fallbackChunk = await supabase
        .from('unit_costs')
        .select('content')
        .ilike('content', `%${entity.name}%`)
        .limit(1);
    
    if (fallbackChunk.data?.[0]) {
        // 원문 테이블을 컨텍스트에 직접 첨부
        entity.properties.raw_table = fallbackChunk.data[0].content;
    }
}
```

##### [MODIFY] `context.ts` — buildContext 함수

`raw_table` 속성이 있으면 원문 테이블 직접 출력:

```typescript
if (entityProps.raw_table) {
    parts.push(`**[표 ${sectionId}] 원문 품셈표**\n`);
    parts.push(entityProps.raw_table);
    parts.push("");
}
```

---

### Phase 2: 매트릭스 테이블 출력 (출력 계층)

> **목표**: 같은 섹션의 WorkType들을 원본처럼 구경×SCH 매트릭스 테이블로 병합 출력  
> **난이도**: 상  
> **예상 작업**: 4~6시간

#### 3.3 현재 출력 구조 (비효율)

```
### 강관용접(100, SCH 40)
| 직종 | 수량 | 단위 |
| 플랜트용접공 | 0.148 | 인 |
| 특별인부 | 0.086 | 인 |

### 강관용접(150, SCH 40)
| 직종 | 수량 | 단위 |
| 플랜트용접공 | 0.213 | 인 |
| 특별인부 | 0.125 | 인 |

... (119개 반복)
```

#### 3.4 목표 출력 구조 (효율적) — 원본 형태

```
### [표 13-2-3] 강관용접 전기아크용접 (개소당)

| 구경(mm) | SCH20 용접공 | SCH40 플랜트용접공 | SCH40 특별인부 | SCH80 플랜트용접공 | SCH80 특별인부 |
| -------- | ------------ | ------------------ | -------------- | ------------------ | -------------- |
| 15       | -            | 0.066              | -              | 0.075              | -              |
| 20       | -            | 0.075              | -              | 0.083              | -              |
| ...      | ...          | ...                | ...            | ...                | ...            |
| 600      | 0.848        | 1.494              | 0.875          | 2.545              | 1.490          |
```

#### 3.5 Phase 2 구현 상세

##### [MODIFY] `context.ts` — buildContext 병합 로직 추가

**Step 1: WorkType 이름 패턴 감지**

```typescript
// WorkType 이름에서 (구경, SCH) 패턴 감지
const matrixPattern = /^(.+)\((\d+),\s*(SCH\s*\d+)\)$/;
const matrixGroups = new Map<string, Map<string, Map<string, number>>>();
// key: 기본이름(강관용접), value: Map<구경, Map<직종+SCH, 수량>>
```

**Step 2: 매트릭스 데이터 수집**

```typescript
entities.forEach((entity, idx) => {
    const match = entity.name.match(matrixPattern);
    if (match) {
        const [, baseName, pipeSize, schNo] = match;
        // 해당 엔티티의 REQUIRES_LABOR에서 직종+수량 추출
        const labor = relationsAll[idx]?.filter(r => r.relation === 'REQUIRES_LABOR') || [];
        labor.forEach(l => {
            // matrixGroups[baseName][pipeSize][`${schNo} ${직종}`] = 수량
        });
    }
});
```

**Step 3: 매트릭스 테이블 렌더링**

```typescript
function renderMatrixTable(baseName: string, matrix: Map<...>): string {
    // 1. 모든 SCH+직종 컬럼 수집 및 정렬
    // 2. 구경 행 정렬 (숫자순)
    // 3. markdown 테이블 생성
    // | 구경(mm) | SCH20 용접공 | SCH40 플랜트용접공 | SCH40 특별인부 | ...
}
```

**Step 4: 기존 개별 테이블과 병합 출력 분기**

```typescript
// buildContext 내에서:
if (matrixGroups.size > 0) {
    // 매트릭스 패턴 WorkType → 통합 테이블 출력
    for (const [baseName, matrix] of matrixGroups) {
        parts.push(renderMatrixTable(baseName, matrix));
    }
} else {
    // 기존 개별 테이블 출력 (변경 없음)
}
```

##### [MODIFY] `context.ts` — 매트릭스 판단 기준

| 조건                                                        | 적용                  |
| ----------------------------------------------------------- | --------------------- |
| 같은 섹션의 WorkType 이름이 `기본이름(숫자, SCH 숫자)` 패턴 | 매트릭스 출력         |
| 패턴 불일치                                                 | 기존 개별 테이블 유지 |
| 매트릭스 셀이 5×3 이상                                      | 매트릭스 출력         |
| 매트릭스 셀이 작음                                          | 기존 개별 테이블 유지 |

---

### Phase 3: 컨텍스트 최적화 (토큰 절약)

> **목표**: LLM 컨텍스트 토큰 절약  
> **난이도**: 중  
> **예상 작업**: 1~2시간

현재 119개 WorkType × 개별 테이블 = 수천 토큰 → 매트릭스 1개 = 수백 토큰

#### 3.6 구현 상세

##### [MODIFY] `graph.ts` — expandGraph 조회 최적화

현재: 각 WorkType를 개별 엔티티로 조회 → REQUIRES_LABOR 각각 조회  
개선: 같은 섹션+같은 기본이름의 WorkType을 일괄 조회

```typescript
// 동일 패턴 WorkType 일괄 조회
const batchQuery = supabase
    .from('graph_entities')
    .select('id, name, source_section')
    .eq('source_section', sectionId)
    .eq('type', 'WorkType')
    .ilike('name', `${baseName}(%`);
```

---

## 4. 실행 계획

| 단계        | 내용                                        | 수정 파일                | 우선순위 | 예상 시간 |
| ----------- | ------------------------------------------- | ------------------------ | -------- | --------- |
| **Phase 1** | TIG용접 등 Labor 미연결 WT에 원문 청크 폴백 | `graph.ts`, `context.ts` | **즉시** | 2~3h      |
| **Phase 2** | 매트릭스 테이블 병합 출력                   | `context.ts`             | **높음** | 4~6h      |
| **Phase 3** | 일괄 조회 토큰 최적화                       | `graph.ts`               | 중       | 1~2h      |

---

## 5. 검증 계획

### 테스트 쿼리

| 검색어              | 기대 결과                                          |
| ------------------- | -------------------------------------------------- |
| TIG용접 품셈        | TIG 규격별(구경×SCH) 매트릭스 테이블 출력          |
| 강관용접 200 SCH 40 | 전기아크+TIG 양쪽 데이터가 매트릭스 형태로 출력    |
| 강관용접 전체       | 전기아크용접 전체 매트릭스 + TIG용접 전체 매트릭스 |
| Flange 취부         | (Phase 2 적용 시) 매트릭스 출력 검증               |

### API 테스트

```powershell
$body = '{"question":"TIG용접 200mm SCH 40 품셈"}';
$resp = Invoke-WebRequest -Uri '...' -Method POST ...
# 기대: TIG용접 규격별 인력 데이터 포함 응답
```

### 출력 비교

| 항목                | Phase 1 전   | Phase 1 후    | Phase 2 후   |
| ------------------- | ------------ | ------------- | ------------ |
| TIG용접 인력 데이터 | ❌ 없음       | ✅ 원문 테이블 | ✅ 매트릭스   |
| 전기아크용접 표시   | 119개 개별표 | 119개 개별표  | 1개 매트릭스 |
| 컨텍스트 토큰       | ~5000        | ~5500         | ~800         |

---

## 6. 리스크 및 주의사항

> [!WARNING]
> Phase 2 매트릭스 출력은 `buildContext`의 핵심 로직 변경이므로, 
> 기존 개별 테이블 출력과의 **하위 호환성**을 반드시 유지해야 합니다.
> 매트릭스 패턴이 아닌 WorkType은 기존 방식 그대로 출력.

> [!IMPORTANT]
> TIG용접 데이터가 unit_costs 원문에만 존재하므로,  
> Phase 1(원문 폴백)을 먼저 적용해야 TIG 검색이 정상 동작합니다.

> [!NOTE]
> 이 개선은 13-2-3 뿐 아니라 15개 유사 섹션(Flange 취부, 강판 전기아크용접 등)에
> 동일하게 적용되어 전체 시스템의 출력 효율을 크게 향상시킵니다.
